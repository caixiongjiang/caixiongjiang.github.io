<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on 🌀riba2534&#39;s Blog</title>
    <link>https://blog.riba2534.cn/blog/</link>
    <description>Recent content in Blogs on 🌀riba2534&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 20 Sep 2021 09:40:54 +0800</lastBuildDate><atom:link href="https://blog.riba2534.cn/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数字货币双币投资策略入门</title>
      <link>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%8F%8C%E5%B8%81%E6%8A%95%E8%B5%84%E7%AD%96%E7%95%A5%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 20 Sep 2021 09:40:54 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%8F%8C%E5%B8%81%E6%8A%95%E8%B5%84%E7%AD%96%E7%95%A5%E5%85%A5%E9%97%A8/</guid>
      <description>数字货币双币投资策略入门 很多数字货币交易平台提供的理财产品中，有一种叫「双币理财」的产品。这种产品声称：无论比特币上涨或者下跌，用户总能赚得 BTC 或者 USDT 的收益。举个例子，我们打开币安提供的双币理财页面：双币投资
随后截个图，研究一下里面的信息，在图中，BTC 现货的价格是 47205，交割日是 2021年9月24日（写文章时的日期是2021年9月20日）。如果我投入 1BTC，在9月24日交割的时间：
 如果 BTC 现货的价格大于等于 48000，你就会收到 48172.8USDT（赚了，因为你投入BTC时的成本价是47205） 如果 BTC 现货的价格小于 48000，你就会收到 1.0036BTC（赚了，因为你投入了1BTC，现在获得的BTC更多了）  乍一看是不是有点不相信，世上真有这稳赚不赔的好事？这种理财方式的原理是什么呢，是不是有隐藏的风险，带着这些疑问，我最近探究了一下，有一些心得，和大家分享。
期权(Option) 定义 为什么要讲期权呢？细心的读者可能在上文中的图中发现，里面有一个行权价格，这个价格意味着什么呢，这就不得不说到期权。
期权英文为 option，大家都知道，option 有选择的意思，期权实质上是一种选择权。通俗的解释一下，期权有两个字，一个是 期，一个是 权，期代表期限，权代表权利，期权的购买方，在某个期限，会得到某个权利。举个例子：
假设现在BTC现货价格是 4w 美元，小A向小B购买了一张纸，这张纸上写了一句话：三天后，小A可以以 4.5w 美元的价格向小B购买1BTC。这张纸本身值 100 美元，这 100 美元需要由小A支付给小B。那么时间来到了三天后，有两种情况：
 BTC 价格变成了 5w 美元，这时候小A拿着这张纸找小B，用4w美元买到一个BTC，然后在市场上用5w美元的价格卖出去，这时候小A就赚了1w美元，当然这1w还得减去当时买这张纸的100美元费用。但是小B就哭了，卖纸得了 100美元，现在却得在时长上花5w美元买一个BTC，用4w的价格卖出去，亏损1w美元。这个过程称为行权，这 100 美元被称为 权利金。 BTC价格变成了 3w 美元，这时候小A就有了选择权，明明在市场上可以以更便宜的价格买入BTC，为啥要找小B买呢。这时候，小A就可以选择不行权，这时候，小A就相当于亏了 100 美元，而小B这边，由于没人来找自己行权，赚了 100 美元。  在上面这个例子中，这张纸就是期权，上面记录了一个约定，由小A来选择是否执行。
那么这时候，我们考虑一下，对于小A来说，在这场交易中，最大的亏损也就是 100 美金，但是如果BTC猛涨，小A的收益理论上来说是无限大的。但是对于小B来说，在这场交易中，最多赚 100 美金，但是如果亏损，理论上来说，亏损是无限的。
那，是不是作为期权的卖方，很不划算，这个问题我们等会讨论。
看涨期权 解释完了期权，再来解释一下什么叫看涨期权。
看涨期权，举个例子，就是你觉得比特币会涨。以上文中的小A举例，现在BTC的价格是 4w 美元，小A就去买入一张看涨期权，约定：在 7 天后，可以以 4.</description>
    </item>
    
    <item>
      <title>数据密集型应用系统设计_分布式系统的挑战</title>
      <link>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/</link>
      <pubDate>Thu, 09 Sep 2021 17:34:48 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/</guid>
      <description>分布式系统的挑战 本章对分布式系统可能出现的故障做了一个全面、近乎悲观的总结。故障可能来自网络问题、时钟时序问题等，并讨论这些问题的可控程度。
故障与部分失效 计算机设计一个非常谨慎的选择是：如果发生了某种内部错误，宁愿使计算机全部崩溃，而不是返回一个错误的结果，错误的结果往往更难处理。计算机隐藏了一切模糊的物理世界，呈现一个理想化的物理模型，以数学的方式完美运行。
但是涉及到多个节点时，情况发生了根本性的变化。对于这种分布式系统，理想化的标准模型不再适用，我们必须面对一个可能混乱的现实：在一个现实世界中，各种各样的事情都可能出错。
在分布式系统中，可能出现系统的一部分工作正常，但其他某些部分出现难以预测的故障，我们称之为「部分失效」。问题的难点就在于这种失效是不确定性的：如果涉及多个节点和网络，几乎肯定会碰到有时候网络正常，有时候则莫名的失败，这种不确定性和部分失效大大提高了分布式系统的复杂性
云计算和超算 关于如何构建大规模计算系统有以下几种不同的思路：
 规模的一个极端是高性能计算（HPC）。包含成千上万个CPU的超级计算机构建出一个庞大的集群，通常用于计算密集型的科学任务 另一个极端是云计算。虽然云计算的定义并非那么明确，但是通常他具有一下特征：  多租户数据中心 通用计算机 用 IP 以太网链接 弹性/按需资源分配   传统企业一般处于这两个极端之间  不同集群构建方式所对应的错误处理方法也不同，对于高性能计算，通常会定期对任务进行快照，然后保存在持久性存储上，当某个节点出现故障，就干脆让系统停下来，等故障节点修复之后，从最近的快照点继续执行，
本书重点是基于互联网的服务系统，这些系统与高性能计算有许多不同之处：
 我们的互联网服务都是在线的，需要随时（7X24h）不间断运行，为用户提供低延迟服务，任何服务不可用的情况，都是不可取的。相比之下，对于高性能计算，比如天气模拟这种离线任务则可以暂停下来然后重启，影响相对较小 高性能计算通常采用专有硬件，每个节点的可靠性很高，节点之间主要通过共享内存来进行通信，或者远程内存直接访问（RDMA）等技术进行通信。而云计算中的节点大多数是由通用机器构建，且成本相对低廉 大型数据中心通常基于IP和以太网，采用 Clos 拓扑结构提供等分带宽。他们可以为 HPC 特定工作负载提供了更好的性能。 系统越大，其中局部组件失效的概率就越大，在长时间运行期间，我们几乎总是可以假定某些东西发生了失效。 如果系统可以容忍某些失败的节点，而使整体继续工作，则对系统运行帮助极大，例如：支持滚动升级（我们目前就是这样做的） 对于全球分散部署的多数据中心，通信需要经过广域网，与本地网络相比，速度更慢且更加不可靠，而高性能计算通常假设所有节点位置靠近，紧密相连。  要是分布式系统可靠工作，就必然面临部分失效，这就需要依靠系统软件系统来提供容错机制。在分布式系统中，怀疑，悲观和偏执狂才能生存。
不可靠的网络 本书主要关注分布式无共享系统，即通过网络连接多个节点。所以有以下几点假定：
 网络是跨节点通信的唯一路径 每台机器都有自己的内存和磁盘 一个机器不能直接访问另一台机器的内存或磁盘，除非通过网络发起请求  互联网以及大多数数据中心的内部网络都是异步网络，这种网络中，一个节点可以发送消息到另一个节点，但是网络并不保证它什么时候到达，甚至一定到达。发送之后，有很多事情可能出错：
 请求可能已经丢失（比如有人拔掉网线） 请求可能正在某个队列中等待，无法马上发送 远程节点已经失效 远程接收节点可能暂时无法响应 远程接收节点已经完成了请求处理，但是回复却在网络中 丢失/延迟  处理这种问题，我们一般采用超时机制：在等待了一段时间后，如果仍旧没有收到回复则放弃，并且认为响应不会到达。但是，即使判断他超时，仍然不清楚远程节点是否接收到了请求
现实中的网络故障 一些系统研究和大量的侧面证据表明，网络问题出人意料的普遍，包括哪些由公司运营的数据中心。一家中型数据中心完成的调查发现，没有有12次网络故障，其中有一半涉及单台机器。一家中型数据中心调查发现，每月大约有12次网络故障。
 在头条内部，我们也经常经历由机房故障导致的网络不可用，服务报警等。。大家应该也遇到很多次了
 我们必须处理或者测试网络故障，例如：集群可能死锁，即使网络恢复了也无法提供服务，甚至可能误删数据。如果触发了一些软件未定义的情形，则发生了任何意外都不奇怪。
处理网络故障并不意味着总是需要复杂的容错设施：假定你的网络非常可靠，而万一出现问题，一种简单的方法是向用户提供错误信息。前提是，必须非常清楚接下来软件应该如何应对，以确保系统最终可以恢复。
我们推荐人为有计划的触发网络问题，以测试系统的反应。
 在字节内部，我们总是进行容灾演练，这一点做的还是不错的
 检测故障 许多系统都需要自动检测节点失效这样的功能，例如：
 负载均衡器需要避免向已失效的节点继续分发请求 对于主从复制的分布式数据库，如果主节点失效，我们需要将某个节点提升成主节点。但，网络的不准确性很难准确判断节点是否失效 由于网络的不准确性使得判断节点是否失效变的非常困难，而只有在某些特定场景下，获取可以明确的知道哪里错了 假设可以登录节点，但发现服务器上没有监听目标端口（可能进程挂了），那操作系统会返回 RST 或 FIN 标志的数据包来辅助关闭或拒绝 TCP 链接。如果节点在处理请求的过程中发生了崩溃，就很难知道节点处理了多少数据 如果服务进程崩溃，但是os仍在运行，可以通过脚本通知其他节点，以便新节点能快速接管而跳过等待超时。HBase 使用了这种方法  总之，如果出了问题，你可能会在应用堆栈的某个级别拿到了一个关于错误的回复，但是最好假定最终收不到任何错误报告，接下来尝试重试，等待超时之后，如果还是没有收到响应，则最终声明节点已经失效。</description>
    </item>
    
    <item>
      <title>数字货币期现套利入门</title>
      <link>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E6%9C%9F%E7%8E%B0%E5%A5%97%E5%88%A9%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 24 Aug 2021 22:28:10 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E6%9C%9F%E7%8E%B0%E5%A5%97%E5%88%A9%E5%85%A5%E9%97%A8/</guid>
      <description>数字货币期现套利入门 我的博客一直定义为技术博客，但是最近几个月经历了币圈的毒打之后，我决定也写一写其他的内容，比如投资理财相关（仅代表个人理解，写错了别打我）。
最近接触了一种风险很小的一种币圈的投资理财方式，叫做「期现套利」，把原理在这里做一个记录。
 期现套利是指某种期货合约，当期货市场与现货市场在价格上出现差距，从而利用两个市场的价格差距，低买高卖而获利。理论上，期货价格是商品未来的价格，现货价格是商品目前的价格，按照经济学上的同一价格理论，两者间的差距，即“基差”（基差=现货价格－期货价格）应该等于该商品的持有成本。一旦基差与持有成本偏离较大，就出现了期现套利的机会。其中，期货价格要高出现货价格，并且超过用于交割的各项成本，如运输成本、质检成本、仓储成本、开具发票所增加的成本等等。 期现套利主要包括正向买进期现套利和反向买进期现套利两种。
 前置知识 本文需要一点前置知识：
 你需要知道什么是数字货币，这个利用搜索引擎可以了解，如果想深入了解一下区块链原理，这里推荐一门课 《区块链技术与应用》 讲的特别好（技术面），我就是看了这个课然后去币圈亏钱的 你需要知道如何交易数字货币，常用的比如 币安、火币 等（打不开请科学上网） 你需要知道 交割合约 以及 永续合约 的含义，可以看  数字货币合约交易基础知识 币圈的永续合约怎么理解？   你需要知道永续合约中 资金费率 的概念，下图是币安中 ETH/USDT 永续合约交易对的信息：  可以看到右上角显示资金费率 0.0602% ，那这个资金费率含义是什么呢？
我们可以看一下，火币上面是怎么解释资金费率的？ 资金费用说明
 永续合约没有到期或交割，需要通过“资金费用机制”来让合约价格锚定现货价格。 永续合约每8小时为一期，每期结束时进行结算。即00:00-8:00为一期，结算时间为8:00；8:00-16:00为一期，结算时间为16:00；16:00-次日00:00为一期，结算时间为00:00。以上时间均为GMT+8时间。 只有在结算时持有仓位的用户，才需要收取或支付资金费；如果在结算前已经平仓，则不需要收取或支付资金费用。 结算时，用户应当收取还是支付资金费用，由本期的资金费率以及该用户的持仓情况决定。当资金费率为正值时，多仓将支付资金费用，空仓将收取资金费用；当资金费率为负值时，多仓将收取资金费用，空仓将支付资金费用。 资金费用完全在用户之间进行结算，平台不会从中收取任何费用。
  资金费用的计算 用户将收取或支付的资金费用计算方式如下： 资金费用 = 净持仓量 * 合约面值 / 结算价 * 资金费率 其中，净持仓量 = 持有多仓数量（张） – 持有空仓数量（张）。 当资金费率大于0时，净持仓量大于0的用户需要支付资金费，净持仓量小于0的用户会收取资金费； 当资金费率小于0时，净持仓量大于0的用户会收取资金费，净持仓量小于0的用户需要支付资金费。
 简单一点来说，就是到了合约交割的时间，交易所系统就会通过一定的机制，让合约价格锚定现货价格，如果当前市场上多头比较多，那么就由多头给空头支付资金费率，反之由空投给多头支付资金费率，记住这句话，这是我们套利的关键，再简单一点来说，如果 资金费率 &amp;gt; 0，那么就是多头给空头进行支付资金费率，交易所不从中收取费用。
套利原理原理 说起来，套利原理非常简单，即</description>
    </item>
    
    <item>
      <title>数据密集型应用系统设计_数据存储与检索</title>
      <link>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</link>
      <pubDate>Fri, 09 Jul 2021 21:32:17 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</guid>
      <description>数据存储与检索 从最基本的层面看，数据库只需要做两件事：
 向它插入数据时，它就保存数据 查询数据时，它就返回数据  本章主要从数据库的角度来探讨：
 如何存储输入的数据 收到查询请求时，如何重新找到数据  作为一名普通的开发人员，我们不太可能从头实现一个自己的存储引擎，但是我们在做技术选型的时候，需要从众多的存储引擎中选一个最适合自己应用的，就需要对各种存储引擎底层机制有一个大概的了解。
我们将研究两个存储引擎家族：
 日志结构的存储引擎 面向页的存储引擎（如 B-Tree）  数据库的核心：数据结构 一个简单的例子： 1 2 3 4 5 6 7 8 9  #!/bin/bash  de_set() { echo &amp;#34;$1,$2&amp;#34; &amp;gt;&amp;gt;database } db_get() { grep &amp;#34;^$1,&amp;#34; database | sed -e &amp;#34;s/^$1,//&amp;#34; | tail -n 1 }   我们实现了一个简单的 kv 存储的数据库，key 可以是任意值，value可以是一个 json，我们每次查找，都会获取key的最新值返回。
我们来看一下这样做的特点
 每次对数据进行追加，且旧值不会被覆盖，最后一次的值就是最新的值 这种追加到文件末尾的方式通常足够高效，许多数据库内部也是使用日志（log），日志是一个仅支持追加式更新的数据文件，但是一个真正的数据库需要考虑的更多（并发控制、回收磁盘、控制日志文件大小） 虽然写入的时候高效，但是如果日志文件产生了大量记录， do_get 性能会非常差，他只能进行 O(n) 扫描全表  那如何快速查找我们想要找的 key 的值呢，那就需要一个数据结构来索引它，最基本的想法就是存一些额外的数据，作为这些元数据的路标，帮助我们定位，但是引入额外的数据结构来维护索引，也是有开销的，每次写入数据不仅仅是简单的追加数据，还需要更新索引，因此任何类型的索引都会降低写入速度。</description>
    </item>
    
    <item>
      <title>Go Linq 使用</title>
      <link>https://blog.riba2534.cn/blog/2021/go-linq%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 25 May 2021 02:35:34 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/go-linq%E4%BD%BF%E7%94%A8/</guid>
      <description>前言 最近我负责了一个新项目，大概流程是从 DB 里拿出一堆数据之后，得到一个包含字段很多的结构体的 List，然后需要对这个 List 进行一系列的过滤，包括但不限于类似 sql 中的 where、group by、select 、按照某个字段排序、求并补交集之类的操作。
如果让我自己写，我肯定是一个一个条件慢慢写，但是代码库我是接手的别人的，我看了下现有的实现，大呼牛逼，原来目前对于这种操作已经有了成熟的解决方案了。
那就是：LINQ
Go-linq 介绍 语言集成查询（Language Integrated Query），缩写为 LINQ，是微软的一项技术，并且被应用在了 C# 中，它直接将一些列的查询操作集成在了编程语言中，使得开发者筛选数据的时候可以大大加快速度。详见：语言集成查询
在 Golang 中，语言本身并没有内置这种操作，不过好在有开源社区帮助我们实现了一个库 ahmetb/go-linq ，详细的支持的函数列表和操作可以看这里： https://pkg.go.dev/github.com/ahmetb/go-linq/v3
特性如下：
 没有使用任何第三方依赖，只使用了go 原生库 通过迭代器模式实现了惰性求值 并发安全 支持泛型方法 支持 array、slice、map、string、channel 和自定义集合类  go-linq 提供的方法可以按照是否支持泛型分为两大类。泛型方法都以 T 结尾。非泛型方法需要将函数的入参类型限制为 interface{} 并做类型断言。
基本使用 牛刀小试 首先，肯定是先引入包：
1  go get github.com/ahmetb/go-linq/v3   引入之后，就可以在项目里面用起来了。
我们找个例子先试一试，假设我要筛选出一个数组中的所有偶数，可以对比一下自己写和使用库的写法的区别：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>博客迁移至hugo</title>
      <link>https://blog.riba2534.cn/blog/2021/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3hugo/</link>
      <pubDate>Sat, 08 May 2021 18:07:05 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3hugo/</guid>
      <description>背景 两年前把个人博客从 WordPress 迁移到 Typecho ，当时的想法是觉得 WordPress 功能太复杂，维护太麻烦，所以就迁移到了相对小型的博客 Typecho，同样也是 PHP 开发的。当时采用了一个很漂亮的 HandSome 主题，但是后面我越来越发现博客的关键在于内容与质量，好不好看应该是其次的，我有点本末倒置了。
所以我打算换一种博客展示形式了
为什么不再是 Typecho? 说一说采用 Typecho 的缺点：
 由于工作后个人精力的原因，空闲时间并不多，没有很多时间维护服务器，所以需要一种更简单的博客维护方式。 目前的 Typecho 博客还放在腾讯云的一台服务器上，这个服务器再过一年多就过期了，而我又不经常更新与维护，导致了目前服务器版本还停留在 Ubuntu16.04，可能会存在很多历史问题，我懒得修 LAMP 这种动态博客的方式有点陈旧，我还会经常忘记 MySQL 的密码，长此以往，等到服务器快过期的时候一定是一个灾难。 我现在觉得博客应该专注于内容，不想搞那么些花里胡哨的东西，需要寻找一种新的博客展示方式。 现在静态博客比较流行，也比较流行 Serverless 的概念，我想试试  我的需求 我目前对博客的需求是：
 简洁：我希望功能与页面都简洁，能突出博客的内容即可，但是也不能太丑。 支持完整的 MarkDown 语法与数学公式支持 容易维护：我不想花费太多时间在服务器的维护上，也不想整天被黑客盯上，冲着我的网站扫个不停。 费用低一点：目前使用的云服务器是腾讯云的学生机，在毕业前我考虑到了毕业后没有学生优惠这件事，一下子买了好几年，但是总会过期的，过期后的 1C1G 的机器，一月好像顶我现在一年的费用，为了维护一个博客，不值得这样。 数据存储不希望使用数据库：放在云服务器上的 MySQL，比较危险，万一哪天服务器被黑了，直接给我删库我咋办，可以做一个定时备份，但是这样比较麻烦，使用 Markdown 这种文件存储的方式更好一些。 希望通过 Git 进行版本控制：写的多了，就知道版本控制的重要性了。 内容可以长时间存在，防止年久失修丢数据，目前来看，GitHub 可以满足这一点。  为什么是 Hugo? 经过我的一番调研，最终落在了 Hexo 和 Hugo 这两个静态页面生成器身上，由于我目前从事 Golang 开发，对 Go 语言比较熟悉，最后就选择 Hugo 了。(听说文章多了 Hexo 渲染的会很慢？)</description>
    </item>
    
    <item>
      <title>BitTorrent简介</title>
      <link>https://blog.riba2534.cn/blog/2021/bittorrent%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 11 Apr 2021 17:09:13 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/bittorrent%E7%AE%80%E4%BB%8B/</guid>
      <description>BitTorrent 简介 从 P2P 说起 经常在网上飙车的老司机应该都知道 BT 下载，但是有时候拿到了种子却下载不动，会不会很抓狂，是不是还觉得是自己网不行，那作为一个合格的老司机，我们需要探究一下下载不动的原因是什么，BT的运作方式是怎样的，如果你也有这样的疑惑，那么，系好安全带，我们一起来了解一下什么是 BT。
2001年4月，程序员布莱姆·科恩设计了一种协议，然后在2001年7月2日，他发布了 BitTorrent 客户端的第一个实现。
BT(BitTorrent)是 P2P 的一种实现，P2P也叫「对等网络」（英语：peer-to-peer， 简称P2P），是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种网络形式。在P2P网络环境中，彼此连接的多台计算机之间都处于对等的地位，各台计算机有相同的功能，无主从之分，每个节点既充当服务器，为其他节点提供服务，也能作为客户端，享用其他节点提供的服务。
P2P有着很广泛的应用，比如 P2P金融（雾），区块链，BT下载等。它的关键字是去中心化，依靠用户群（peers）来互相传输数据，符合这种特征的都可以称之为 P2P。
BitTorrent 大家肯定有在互联网上下载各种资源的经历，比如电影电视剧，我们在网上一搜，就会搜到一些不知名的小网站，网站上通常会提供一个叫做「种子」的东西，我们使用时只需要把种子下载到电脑上，通常是一个后缀为 .torrent 的文件， 然后用迅雷或者其他的下载工具下载。
   搜索词 网站界面          在实际操作中，如果我们使用迅雷进行下载，有时候会发现种子下不动，有时候发现下的特别慢，有时候还被提示资源敏感，无法下载，还有时候迅雷提示你开会员可以加速（这个时候开一个会员基本就可以满速下载了，因为迅雷已经把资源提前下载到自己服务器了），我们可能产生一些疑惑：
  种子是什么？
  为什么资源有时候下不动，有时候速度那么慢？
  如何才能让我的BT下载速度变快？
  为了解决这个疑问，我们需要了解一下 BT 协议，全称是 BitTorrent，这个协议被设计用来实现 P2P(Peer to Peer) 下载。普通的 HTTP/FTP 下载使用 TCP/IP 协议，BitTorrent 协议是架构于 TCP/IP 协议之上的一个P2P文件传输通信协议，是一个应用层协议。
传统的下载是客户端请求服务器获取资源，下载方和资源提供方的角色很清楚。这样做的优点是简单，易于理解，我要下载东西，我就去请求服务器，缺点也很明显：
  一旦服务器故障，大家都无法下载
  服务器带宽有限，下载的人多速度必然下降</description>
    </item>
    
    <item>
      <title>LeetCode 327 区间和的个数（树状数组、线段树）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Sat, 07 Nov 2020 16:41:38 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：区间和的个数
给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。 区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。
说明: 最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。
示例:
输入: nums = [-2,5,-1], lower = -2, upper = 2,输出: 3 解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。思路 (树状数组) $O(nlogn)$
这道题一个很直观的做法就是记录前缀和，然后使用双层循环遍历所有的区间，时间复杂度$O(n^2)$。我们考虑如何来优化这个这个双层循环，我们在固定子数组的右边界的时候，采用遍历的方式求出所有区间和在[lower,upper]之间的数组个数，我们可以以更优的方式求解所有可行的区间。假设右区间为A[j]，前缀和为preSum[j]，其实我们需要求的是所有preSum[j] - upper &amp;lt;= preSum[i] &amp;lt;= preSum[j] - lower(i&amp;lt;j)的个数。求某一个区间内的个数，我们可以使用树状数组或者线段树来求解。
我们每次读到一个数，先把合法区间内前缀和的个数求出来（区间查询），然后将当前前缀和出现的次数加上一（单点更新）。因为只需要上面两个操作，所以可以使用树状数组来减少代码难度。整体代码思路如下：
 求出数组的前缀和数组（包括0），并将前缀和数组离散化。 使用三个哈希表，分别记录每一个前缀和离散化后的大小，以该数字为右边界对应的左边界前缀和的区间[preSum[j] - upper,preSum[j] - lower]对应的区间左右端点离散化后的值。  lower_bound查找大于等于preSum[j] - upper最小值对应的下标；</description>
    </item>
    
    <item>
      <title>LeetCode LCP18 早餐组合（贪心，思路）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-lcp18-%E6%97%A9%E9%A4%90%E7%BB%84%E5%90%88%E8%B4%AA%E5%BF%83%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 15 Sep 2020 00:56:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-lcp18-%E6%97%A9%E9%A4%90%E7%BB%84%E5%90%88%E8%B4%AA%E5%BF%83%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：早餐组合
小扣在秋日市集选择了一家早餐摊位，一维整型数组 staple 中记录了每种主食的价格，一维整型数组 drinks 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 x 元。请返回小扣共有多少种购买方案。
注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1
示例 1：
 输入：staple = [10,20,5], drinks = [5,5,2], x = 15
输出：6
解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是： 第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15； 第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15； 第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12； 第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10； 第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10； 第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。</description>
    </item>
    
    <item>
      <title>LeetCode 37 解数独（dfs）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%ACdfs/</link>
      <pubDate>Tue, 15 Sep 2020 00:53:33 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%ACdfs/</guid>
      <description>题目链接：解数独
编写一个程序，通过已填充的空格来解决数独问题。
一个数独的解法需遵循如下规则：
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  空白格用 &#39;.&#39; 表示。
一个数独。
答案被标成红色。
Note:
 给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。  思路 经典的解数独游戏。
首先记录下来所有的需要填数字的坐标信息，然后从第一个需要填数的地方开始填数，依次判断数字 1-9 ，当前位置是否可以填数，可以的话填数，继续搜索下一层，最后回溯的时候需要取消填数继续试。如果找到答案，就记录一下，这里可以剪枝。
要判断一个地方能不能填数字，要满足：
 这一行中有没有相同数字 这一列中有没有相同数字 当前的小9宫格中，有没有相同数字（对当前坐标*3和/3的操作是为了确定当前小九宫格的起始点坐标）  如果满足这个条件，证明这个地方可以填数。
具体看代码
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  class Solution { public: vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; point; vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; ans; bool flag; bool check(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board, int k, int step) { for (int i = 0; i &amp;lt; 9; i++) if (board[point[step].</description>
    </item>
    
    <item>
      <title>Go Channel 详解</title>
      <link>https://blog.riba2534.cn/blog/2020/go-channel-%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 01 Sep 2020 11:13:34 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/go-channel-%E8%AF%A6%E8%A7%A3/</guid>
      <description>Go Channel 详解 Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。
它的操作符是箭头 &amp;lt;- 。
1 2  ch &amp;lt;- v // 发送值v到Channel ch中 v := &amp;lt;-ch // 从Channel ch中接收数据，并将数据赋值给v   (箭头的指向就是数据的流向)
就像 map 和 slice 数据类型一样, channel必须先创建再使用:
1  ch := make(chan int)   Channel类型 Channel类型的定义格式如下：
1  ChannelType = ( &amp;#34;chan&amp;#34; | &amp;#34;chan&amp;#34; &amp;#34;&amp;lt;-&amp;#34; | &amp;#34;&amp;lt;-&amp;#34; &amp;#34;chan&amp;#34; ) ElementType .   它包括三种类型的定义。可选的&amp;lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。
1 2 3  chan T // 可以接收和发送类型为 T 的数据 chan&amp;lt;- float64 // 只可以用来发送 float64 类型的数据 &amp;lt;-chan int // 只可以用来接收 int 类型的数据   &amp;lt;-总是优先和最左边的类型结合。(The &amp;lt;- operator associates with the leftmost chan possible)</description>
    </item>
    
    <item>
      <title>超级码力在线编程大赛初赛 第2场 题解</title>
      <link>https://blog.riba2534.cn/blog/2020/%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B-%E7%AC%AC2%E5%9C%BA-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Sun, 30 Aug 2020 13:05:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B-%E7%AC%AC2%E5%9C%BA-%E9%A2%98%E8%A7%A3/</guid>
      <description>超级码力在线编程大赛初赛 第2场 题解 下面的题解仅代表个人观点，出了问题，概不负责。
比赛链接：https://tianchi.aliyun.com/oj/15165469968503404?spm=5176.15098393.J_6210563800.8.6b8b5cd6dK6WtT
1. 三角魔法 描述 小栖必须在一个三角形中才能施展魔法，现在他知道自己的坐标和三个点的坐标，他想知道他能否施展魔法
 −109&amp;lt;=x,y&amp;lt;=109 点在边上也属于三角形内  示例 输入: triangle = [[0,0],[2,0],[1,2]] point= [1,1]输出: &amp;quot;Yes&amp;quot;输入: triangle = [[0,0],[2,0],[1,1]] point= [2,1]输出: &amp;quot;No&amp;quot;思路 判断是否在三角形内，模板题。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  class Vector2d { public: double x_; double y_; public: Vector2d(double x, double y) : x_(x), y_(y) {} Vector2d() : x_(0), y_(0) {} //二维向量叉乘, 叉乘的结果其实是向量，方向垂直于两个向量组成的平面，这里我们只需要其大小和方向  double CrossProduct(const Vector2d vec) { return x_ * vec.</description>
    </item>
    
    <item>
      <title>LeetCode 214 最短回文串(kmp、next应用)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2kmpnext%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sat, 29 Aug 2020 02:41:03 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2kmpnext%E5%BA%94%E7%94%A8/</guid>
      <description>题目链接：最短回文串
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
示例 1:
输入: &amp;quot;aacecaaa&amp;quot;输出: &amp;quot;aaacecaaa&amp;quot;示例 2:
输入: &amp;quot;abcd&amp;quot;输出: &amp;quot;dcbabcd&amp;quot;思路 kmp
首先我们回归一下 kmp 中 next 数组的含义：
 next[i] 代表 从 [0,i-1] 的最长的相同真前后缀的长度  那么对于这个题目而言，已知题目让我们在字符串前面增加字符让他变成回文串。
我们知道，对于一个回文串而言，它的所有的前缀和后缀是相同的。
假设现在给出的字符串是：abacd，可以确定把字符串的逆序加在这个字符串前面一定回文，比如 dcabaabacd 就一定是个回文串，但是我们可以发现原串的前缀和逆序后的后缀 有重合，对于刚刚给出的例子来说。原串是 abacd，逆序是 dcaba，则前后缀重合的部分是 aba，那么我们拼字符串的时候，这一块就不用动，只需要把原串中 aba后面的字符串 cd 逆序后的字符串 dc 加在原串前，变成 dcabacd 就是答案。
如何求得这个原串的前缀和逆序后的后缀的最大长度呢，正好kmp的next数组就是专门干这个事的，我们给原串和逆序串中间加一个 # 号(防止出现原串中字符都相同的情况)，组成一个新串，然后对这个新串求 next，则新的next数组的最后的值就是最长真前后缀的长度。
知道这个长度后，只需要把这个长度之后的串逆序，加在原串前即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: vector&amp;lt;int&amp;gt; nxt; void get_next(string &amp;amp;p) { int len = p.</description>
    </item>
    
    <item>
      <title>Linux内核数据结构</title>
      <link>https://blog.riba2534.cn/blog/2020/linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 28 Aug 2020 01:49:53 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>Linux 内核数据结构 获得源码 目前，Linux 内核的源码维护在 GitHub 上，地址为：https://github.com/torvalds/linux
 克隆到本地  git clone https://github.com/torvalds/linux 本书使用的源码版本为 2.6.34 ，所以切换到对应 Tag：  cd linuxgit checkout v2.6.34或者直接在：https://github.com/torvalds/linux/releases/tag/v2.6.34 下载
Linux 源码树根目录说明 $ tree -L 1.├── arch # 特定体系结构的源码├── block # 块设备 I/O 层├── COPYING # 内核许可证（GNU GPL v2）├── CREDITS # 内核代码开发者列表├── crypto # 加密 API├── Documentation # 内核源码文档├── drivers # 设备驱动程序├── firmware # 使用某些驱动程序而需要的设备固件 ├── fs # VFS 和各种文件系统├── include # 内核头文件├── init # 内核引导和初始化├── ipc # 进程间通信代码├── Kbuild # 用于编译Linux内核文件，对makefile进行了扩充 ├── kernel # 像调度程序这样的核心子系统├── lib # 通用内核函数├── MAINTAINERS # 维护者列表以及如何提交内核更改的说明文件├── Makefile # makefile├── mm # 内存管理子系统和vm ├── net # 网络子系统 ├── README # README├── REPORTING-BUGS # Linux内核常见问题解答 ├── samples # 示例├── scripts # 编译内核所用的脚本 ├── security # Linux安全模块├── sound # 语音子系统├── tools # 在Linux开发中有用的工具├── usr # 早期用户空间代码（所谓的 inittranfs）└── virt # 虚拟化基础结构21 directories, 7 files内核数据结构简介 介绍通用数据结构中最有用的几个：</description>
    </item>
    
    <item>
      <title>LeetCode 332 重新安排行程(输出欧拉路经)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%E8%BE%93%E5%87%BA%E6%AC%A7%E6%8B%89%E8%B7%AF%E7%BB%8F/</link>
      <pubDate>Thu, 27 Aug 2020 02:00:55 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%E8%BE%93%E5%87%BA%E6%AC%A7%E6%8B%89%E8%B7%AF%E7%BB%8F/</guid>
      <description>题目链接：重新安排行程
给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。
说明:
 如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGA&amp;rdquo;] 与 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGB&amp;rdquo;] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程。  示例 1:
输入: [[&amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;], [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;], [&amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;], [&amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;]]输出: [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;]示例 2:
输入: [[&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;],[&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]]输出: [&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]解释: 另一种有效的行程是 [&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]。但是它自然排序更大更靠后。思路 看到类似于「一笔画问题」，第一时间想到欧拉路。
 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。 具有欧拉回路的无向图称为欧拉图。 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。  因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。
所以我们可以直接从起点进行 DFS，然后但是要注意走过的边不能重复走，直到走完所有边最后就是答案。
官方题解的实现比较骚，没想到。
用了一个哈希到优先队列的映射，一个字符串映射一个最小堆，这样就可以根据贪心思路来保证字典序了。
搞一个栈存答案，因为是dfs从后网前回溯，所以答案是反着的，最后反转一下即可。
关于欧拉路的判断，可以看 NYOJ42 一笔画问题(欧拉路+并查集)
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: unordered_map&amp;lt;string, priority_queue&amp;lt;string, vector&amp;lt;string&amp;gt;, greater&amp;lt;string&amp;gt;&amp;gt;&amp;gt; e; vector&amp;lt;string&amp;gt; stk; void dfs(string u) { while (!</description>
    </item>
    
    <item>
      <title>LeetCode 491 递增子序列(枚举子集)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/</link>
      <pubDate>Tue, 25 Aug 2020 01:22:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/</guid>
      <description>题目链接：递增子序列
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
示例:
输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]说明:
 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。  思路 先看一眼数据范围，是15，猜一下复杂度，大概 $2^{15}$ 能过，应该就是二进制枚举子集了。
关于枚举子集，可以看我之前写的博客 ：二进制枚举子集详解
枚举子集可以求出，所有的组合方式。接下来我们只需要判断
 这个序列是不是一个递增序列 去重  关于判断是否是一个递增序列，我们只需要找一个比较小的数 t ，其值一直跟随当前遍历的数的值，如果遍历到的数小于t，则这肯定是一个递减序列。
关于去重，可以用 unordered_map 做一个 string 的映射，比如现在有列表 [1,12,-3,4]，我们给每个数字加上分隔符，变成一个字符串 1|12|-3|4，将这个值进行映射，可以保证不重复。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsequences(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; unordered_map&amp;lt;string, int&amp;gt; mp; int n = nums.</description>
    </item>
    
    <item>
      <title>LeetCode 679 24 点游戏(暴力，递归)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-679-24-%E7%82%B9%E6%B8%B8%E6%88%8F%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92/</link>
      <pubDate>Sat, 22 Aug 2020 01:57:03 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-679-24-%E7%82%B9%E6%B8%B8%E6%88%8F%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：24 点游戏
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
示例 1:
输入: [4, 1, 8, 7]输出: True解释: (8-4) * (7-1) = 24示例 2:
输入: [1, 2, 1, 2]输出: False注意:
 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。  思路 首先括号可以直接忽略掉，因为我们可以从数组中任意取数并组合。括号没啥用。</description>
    </item>
    
    <item>
      <title>LeetCode 529 扫雷游戏（DFS）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-529-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8Fdfs/</link>
      <pubDate>Thu, 20 Aug 2020 01:59:22 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-529-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8Fdfs/</guid>
      <description>题目链接：扫雷游戏
让我们一起来玩扫雷游戏！
给定一个代表游戏板的二维字符矩阵。 &amp;lsquo;M&amp;rsquo; 代表一个未挖出的地雷，&amp;lsquo;E&amp;rsquo; 代表一个未挖出的空方块，&amp;lsquo;B&amp;rsquo; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（&amp;lsquo;1&amp;rsquo; 到 &amp;lsquo;8&amp;rsquo;）表示有多少地雷与这块已挖出的方块相邻，&amp;lsquo;X&amp;rsquo; 则表示一个已挖出的地雷。
现在给出在所有未挖出的方块中（&amp;lsquo;M&amp;rsquo;或者&amp;rsquo;E&amp;rsquo;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：
 如果一个地雷（&amp;lsquo;M&amp;rsquo;）被挖出，游戏就结束了- 把它改为 &amp;lsquo;X&amp;rsquo;。 如果一个没有相邻地雷的空方块（&amp;lsquo;E&amp;rsquo;）被挖出，修改它为（&amp;lsquo;B&amp;rsquo;），并且所有和其相邻的未挖出方块都应该被递归地揭露。 如果一个至少与一个地雷相邻的空方块（&amp;lsquo;E&amp;rsquo;）被挖出，修改它为数字（&amp;lsquo;1&amp;rsquo;到&#39;8&amp;rsquo;），表示相邻地雷的数量。 如果在此次点击中，若无更多方块可被揭露，则返回面板。  示例 1：
输入: [[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],[&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]Click : [3,0]输出: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]解释:示例 2：
输入: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]Click : [1,2]输出: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]解释:注意：</description>
    </item>
    
    <item>
      <title>HTTPS握手过程</title>
      <link>https://blog.riba2534.cn/blog/2020/https%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 19 Aug 2020 02:36:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/https%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</guid>
      <description>HTTPS 原理  HTTPS  HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。 SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF(InternetEngineering Task Force，Internet 工程任务组)的手中。 TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。   加密方案  对称加密  加密双方使用同一密钥进行加密解密   非对称加密  分为公钥和私钥 公钥和私钥成对出现 用公钥加密的数据只有对应私钥可以解密 用私钥加密的数据只有对应公钥可以解密 公钥一般用于加密和验证签名 私钥一般用于解密和进行数字签名     SSL握手过程   握手过程图   客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 指定版本，加密组件列表（所使用的加密算法以及密钥长度等）    服务端发送 Server Hello 给客户端。服务端从客户端给出的ssl版本以及加密算法等信息，返回加密算法，这个加密算法一定是client发送给server加密算法的子集。    服务器发送 Certificate 报文，其中包含带有服务端公钥的证书。   证书可以由服务端自行制作，或者使用第三方权威机构(CA)颁发的证书。但是自己制作的证书需要客户端验证才可以用。这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。    服务器发动 Server Hello Done 的报文通知客户端，最初阶段的SSL握手协商结束。    SSL第一次握手结束之后，客户端解析证书（客户端的TLS完成），如果证书有问题，就发出警告。拿到服务端的公钥。以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret （预主密钥）的随机密码串。该报文已用步骤 3 中的公钥进行加密。    客户端发送 Change Cipher Spec 报文，该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。    客户端发送 Finshed 报文。该报文包含连接至今的全部报文的校验值。此次握手是否成功，要以服务端是否可以正确解析该报文作为判定标准。    服务端同样发送 Change Cipher Spec 报文    服务端同样发送 Finshed 报文    服务端和客户端的 Finshed 报文交换文笔后，SSL 连接就算建立完成了。从此处开始，进行应用层的协议，即发送HTTP请求。     SSL握手中密钥的交换关键点    假设传输双方 A 为客户端，B 为服务端    最终的传输是以对称加密来传输信息的，而对称加密所用的密钥是非对称加密握手获得的    B要把自己的公钥传给A，但是为了防止被中间人篡改，所以找到了CA，一般情况下B把自己的域名在CA处进行认证，然后由CA颁发一个证书，里面含有已经生成好了的公钥和私钥。    A的浏览器里面已经内置了CA机构的公钥，所以用这个公钥可以从证书中解出B的公钥    然后A把最终要使用的对称加密密钥，用公钥加密传给B    B收到后，就可以用对称加密进行传输了     HTTPS传输过程中的一些问题  怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？  CA证书   如何保证证书不被篡改？  首先，CA机构的公钥是人尽皆知的，中间人可以解密这个证书，拿到B的公钥。但是他无法把自己的公钥替换成B的制作证书，因为制作证书需要CA机构的私钥，中间人肯定是没有的。所以CA机构的存在是防止中间人伪造服务端的公钥。   数字证书的内容  包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。   验证证书安全性过程    当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。    然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。     缺点  HTTPS网络成本消耗较高 服务端和客户端都需要进行额外的计算     既然HTTPS很安全，那么网络抓包软件（Charles）如何抓到https请求的包的？  伪造证书 Charles作为一个“中间人代理”，当浏览器和服务器通信时，Charles接收服务器的证书，但动态生成一张证书发送给浏览器，也就是说Charles作为中间代理在浏览器和服务器之间通信，所以通信的数据可以被Charles拦截并解密。由于Charles更改了证书，浏览器校验不通过会给出安全警告，必须安装Charles的证书后才能进行正常访问。 最关键的点，Charles能伪造证书的前提是，客户端主动在自己的机器上安装证书。   参考资料  数字签名是什么？ 浅谈Charles抓取HTTPS原理  理解公钥与私钥 HTTP和HTTPS协议，看一篇就够了     </description>
    </item>
    
    <item>
      <title>LeetCode 647 回文子串(Manacher)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher/</link>
      <pubDate>Wed, 19 Aug 2020 02:35:42 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher/</guid>
      <description>题目链接：回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：
输入：&amp;quot;abc&amp;quot;输出：3解释：三个回文子串: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;示例 2：
输入：&amp;quot;aaa&amp;quot;输出：6解释：6个回文子串: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;提示：
 输入的字符串长度不会超过 1000 。  思路 首先这题长度不超过1000，那$O(n^2)$ 算法肯定能做。
但是标程肯定是用 Manacher 算法来做的。
关于此算法原理，可以看 最长回文子串——Manacher 算法
首先给原串间隔的添加一个不相关的符号隔开。
在这里我们知道几点关键点即可：
 p[i] 代表以第 i 个位置为中心的最长回文半径（包括 i） p[i]-1 代表，原串中以第 i 个位置为中心的最长回文串长度 pos 代表当前最右边为 max_right 元素时的回文串中心 max_right 代表当前访问到的所有回文子串，所能触及的最右一个字符的位置。  对于本题，我们可以知道所有的 p[i] ，则 p[i]-1 就是当前位置最长回文串长度，我们对于每个位置的长度向上取整除以2，累加起来就是不同子串数量。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Solution { public: vector&amp;lt;int&amp;gt; p; int pos, max_right; string init(string s) { string ans = &amp;#34;#&amp;#34;; for (char ch : s) ans = ans + ch + &amp;#39;#&amp;#39;; return ans; } int countSubstrings(string s) { int ans = 0; s = init(s); p.</description>
    </item>
    
    <item>
      <title>LeetCode 5 最长回文子串(Manacher)  </title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher-/</link>
      <pubDate>Wed, 19 Aug 2020 02:34:55 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher-/</guid>
      <description>题目链接：最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &amp;quot;babad&amp;quot;输出: &amp;quot;bab&amp;quot;注意: &amp;quot;aba&amp;quot; 也是一个有效答案。示例 2：
输入: &amp;quot;cbbd&amp;quot;输出: &amp;quot;bb&amp;quot;思路 Manacher 算法模板题，关于此算法原理，可以看 最长回文子串——Manacher 算法
首先给原串间隔的添加一个不相关的符号隔开。
在这里我们知道几点关键点即可：
 p[i] 代表以第 i 个位置为中心的最长回文半径（包括 i） p[i]-1 代表，原串中以第 i 个位置为中心的最长回文串长度 pos 代表当前最右边为 max_right 元素时的回文串中心 max_right 代表当前访问到的所有回文子串，所能触及的最右一个字符的位置。  本题我们只需要求出来最大的 p[i] 的位置即可，然后构造答案。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  class Solution { public: vector&amp;lt;int&amp;gt; p; int pos, max_right; string init(string s) { string ans = &amp;#34;#&amp;#34;; for (char ch : s) ans = ans + ch + &amp;#39;#&amp;#39;; return ans; } string longestPalindrome(string s) { s = init(s); p.</description>
    </item>
    
    <item>
      <title>LeetCode 546 移除盒子(区间dp，记忆化搜索)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-546-%E7%A7%BB%E9%99%A4%E7%9B%92%E5%AD%90%E5%8C%BA%E9%97%B4dp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sat, 15 Aug 2020 12:32:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-546-%E7%A7%BB%E9%99%A4%E7%9B%92%E5%AD%90%E5%8C%BA%E9%97%B4dp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</guid>
      <description>题目链接：移除盒子
给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &amp;gt;= 1），这样一轮之后你将得到 k*k 个积分。 当你将所有盒子都去掉之后，求你能获得的最大积分和。
示例：
输入：boxes = [1,3,2,2,2,3,4,3,1]输出：23解释：[1, 3, 2, 2, 2, 3, 4, 3, 1] ----&amp;gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) ----&amp;gt; [1, 3, 3, 3, 1] (1*1=1 分) ----&amp;gt; [1, 1] (3*3=9 分) ----&amp;gt; [] (2*2=4 分)提示：
 1 &amp;lt;= boxes.length &amp;lt;= 100 1 &amp;lt;= boxes[i] &amp;lt;= 100  思路 区间dp，记忆化搜索。
令 $dp[l][r][k]$ 表示消除区间 $[l,r]$ 内的所有盒子，以及消除 $r$ 之后 $k$ 个等于 $A_r$ 的盒子组成的序列的最大积分，则当前值为 $A_r$ 的盒子有 $(k+1)$ 个，产生的价值为：$(k+1)^2$，则：</description>
    </item>
    
    <item>
      <title>LeetCode 336 回文对（字典树，思路）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-336-%E5%9B%9E%E6%96%87%E5%AF%B9%E5%AD%97%E5%85%B8%E6%A0%91%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Thu, 06 Aug 2020 09:28:51 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-336-%E5%9B%9E%E6%96%87%E5%AF%B9%E5%AD%97%E5%85%B8%E6%A0%91%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：回文对
给定一组唯一的单词， 找出所有*不同* 的索引对 (i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。
示例 1:
输入: [&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;]输出: [[0,1],[1,0],[3,2],[2,4]] 解释: 可拼接成的回文串为 [&amp;quot;dcbaabcd&amp;quot;,&amp;quot;abcddcba&amp;quot;,&amp;quot;slls&amp;quot;,&amp;quot;llssssll&amp;quot;]示例 2:
输入: [&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;]输出: [[0,1],[1,0]] 解释: 可拼接成的回文串为 [&amp;quot;battab&amp;quot;,&amp;quot;tabbat&amp;quot;]思路  枚举所有的串，利用某种数据结构，存储后缀是否存在 对于每个串，假设一个串的取值范围是 [0,m-1]，以 j为界，把串分成两个子串 [0,j-1]和 [j,m-1] 处理这两个子串，如果 [0,j-1]是回文串，那么只需要找到 [j,m-1]这个串的镜像串，这样就可以组成一个大回文串。同理 [j,m-1]回文，那么只需要找到 [0,j-1]的镜像串，保存答案即可。  对于存储后缀，可以用哈希也可以用字典树，对于这种如果数据量太大的话，无意字典树更节省空间。
本代码采用标程中给的字典树。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  class Solution { public: struct node { int ch[26]; int flag; node() { flag = -1; memset(ch, 0, sizeof(ch)); } }; vector&amp;lt;node&amp;gt; tree; void insert(string &amp;amp;s, int id) { int len = s.</description>
    </item>
    
    <item>
      <title>LeetCode 337 打家劫舍 III（树形dp）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii%E6%A0%91%E5%BD%A2dp/</link>
      <pubDate>Wed, 05 Aug 2020 01:07:53 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii%E6%A0%91%E5%BD%A2dp/</guid>
      <description>题目链接：打家劫舍 III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
示例 1:
输入: [3,2,3,null,3,null,1]3/ \2 3\ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.示例 2:
输入: [3,4,5,1,3,null,1]3/ \4 5/ \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.思路 树形dp裸题。
题目给出一棵二叉树，每一个点有一个权值，你需要选择树上的一些点，选择的两个点不能相邻，问可以取到的最大权值是多少。这个题意大概是 POJ2342 的变形。
我们定义：
 dp[node][0] 代表以 node为根，不选 node 这个点可以取到的最大权值。 dp[node][1] 代表以 node为根，选择 node 这个点可以取到的最大权值。  遍历其子节点，记为 son，则可以得到状态转移方程：</description>
    </item>
    
    <item>
      <title>LeetCode 207 课程表(拓扑排序)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 04 Aug 2020 01:19:39 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接：课程表
你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]
给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？
示例 1:
输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2:
输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。提示：
 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &amp;lt;= numCourses &amp;lt;= 10^5  思路 这种有先决顺序的工程安排问题一般就是拓扑排序，这道题是拓扑排序的裸题。
方法1：删入度，bfs
拓扑排序有一个显然的算法，每次删除有向无环图中的入度为0的点，直到没有入度为0的点为止。因为如果存在环，则一个点必将同时有入度和出度。
所以这个算法在实现的时候可以使用一个队列，每次把入度为0的点加入队列中，然后遍历这个点所有的出边，并删除掉这个点的入度。如果点的进队次数等于点数，则证明此图无环。
方法2：深搜
每一个点开始进行深搜，如果搜到了自己，则存在环。
不存在环时再搜的过程中需要标记路线。
代码 bfs删入度：</description>
    </item>
    
    <item>
      <title>LeetCode 632 最小区间(贪心，堆)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E5%A0%86/</link>
      <pubDate>Mon, 03 Aug 2020 01:50:13 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E5%A0%86/</guid>
      <description>题目链接：最小区间
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a &amp;lt; d-c 或者在 b-a == d-c 时 a &amp;lt; c，则区间 [a,b] 比 [c,d] 小。
示例 1:
输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]输出: [20,24]解释: 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。注意:
 给定的列表可能包含重复元素，所以在这里升序表示 &amp;gt;= 。 1 &amp;lt;= k &amp;lt;= 3500 -105 &amp;lt;= 元素的值 &amp;lt;= 105 对于使用Java的用户，请注意传入类型已修改为List&amp;lt;List&amp;gt;。重置代码模板后可以看到这项改动。  思路 题意可以等价转化为：从k个数组中每个数组中找出一个数，使得其中的最大值与最小值的差值最小。</description>
    </item>
    
    <item>
      <title>LeetCode 392 判断子序列(dp)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97dp/</link>
      <pubDate>Mon, 27 Jul 2020 01:32:09 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97dp/</guid>
      <description>题目链接：判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &amp;lt;=100）。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&amp;quot;ace&amp;quot;是 &amp;quot;abcde&amp;quot;的一个子序列，而 &amp;quot;aec&amp;quot;不是）。
**示例 1:**s = &amp;quot;abc&amp;quot;, t = &amp;quot;ahbgdc&amp;quot;
返回 true.
**示例 2:**s = &amp;quot;axc&amp;quot;, t = &amp;quot;ahbgdc&amp;quot;
返回 false.
后续挑战**:**
如果有大量输入的 S，称作S1, S2, &amp;hellip; , Sk 其中 k &amp;gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
致谢:
特别感谢 @pbrother 添加此问题并且创建所有测试用例。
思路 方案1：双指针 直接模拟，挨个试就行
方案2：dp 定义 dp[i][j]表示从位置 i开始往后的字符 j第一次出现的位置。则在状态转移过程中，如果t中位置为 i的字符就是 j，则$dp[i][j]=j$，否则$dp[i][j]=dp[i+1][j]$，所以需要从后往前枚举。</description>
    </item>
    
    <item>
      <title>LeetCode 410 分割数组的最大值(二分,dp)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%BA%8C%E5%88%86dp/</link>
      <pubDate>Sat, 25 Jul 2020 17:31:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%BA%8C%E5%88%86dp/</guid>
      <description>题目链接：分割数组的最大值
给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。
注意: 数组长度 n 满足以下条件:
 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  示例:
输入:nums = [7,2,5,10,8]m = 2输出:18解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。思路 方案一：二分 枚举满足题意的和的最大值，每一次check按照贪心原则最大化分段，如果最后分段出来的段的数量大于0，代表右区间可以缩小，反之左区间增大。
时间复杂度：$O(n*log(sum-max_n))$
方案二：dp 定义 dp[i][j]表示把前$i$个数分成$j$段，所能达到的段内和的最大值最小的值。
则考虑第 j段的范围，可以枚举k，把第 j段分为：[0,k]和 [k+1,j]这两段，则 dp[i][j]的值就等于 [0,k]这一段的最优解的值与 [k+1,j]这一段的和的最大值，枚举k，使这个值最小即可，即：
$ dp[i][j] = min(dp[i][j], max(dp[k][j - 1], sub[i] - sub[k]))$
对于 [k+1,j]这一段的和，可以预处理出前缀和，直接做减法得到。
时间复杂度：$O(n^2m)$
代码 方案一：二分代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public: bool check(vector&amp;lt;int&amp;gt; &amp;amp;nums, int m, int target) { long long i = 0, sum = 0; while (i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>NSQ使用入门</title>
      <link>https://blog.riba2534.cn/blog/2020/nsq%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 27 Jun 2020 00:54:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/nsq%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</guid>
      <description>NSQ使用入门 简介 消息队列是进程间通信或同一进程不同线程间进行通信一种方式，可以将服务异步化，对流量进行整形，削峰填谷，是高并发、大数据场景下不可或缺的中间件；使得消息生产者和消费者解耦，方便系统模块化设计。
NSQ是一个基于Go语言的分布式实时消息平台，它基于MIT开源协议发布，由bitly公司开源出来的一款简单易用的消息中间件。 官方和第三方还为NSQ开发了众多客户端功能库，如官方提供的基于HTTP的nsqd、Go客户端go-nsq、Python客户端pynsq、基于Node.js的JavaScript客户端nsqjs、异步C客户端libnsq、Java客户端nsq-java以及基于各种语言的众多第三方客户端功能库。
特性   Distributed NSQ提供了分布式的，去中心化，且没有单点故障的拓扑结构，稳定的消息传输发布保障，能够具有高容错和HA（高可用）特性。
  Scalable易于扩展NSQ支持水平扩展，没有中心化的brokers。内置的发现服务简化了在集群中增加节点。同时支持pub-sub和load-balanced 的消息分发。
  Ops FriendlyNSQ非常容易配置和部署，生来就绑定了一个管理界面。二进制包没有运行时依赖。官方有Docker image。
  Integrated高度集成官方的 Go 和 Python库都有提供。而且为大多数语言提供了库。
  消息不持久化，全在内存。可配置&amp;ndash;mem-queue-size来超出阈值的消息写到硬盘
  保证at least once投递。nsqd没挂的前提下，由于超时，连接断开，重新入队等原因，消息可能多次投递，client自己保证消费消息的操作是具有幂等性的。
  值得注意的是，重要的是 nsqd 和 nsqlookupd 守护进程被设计成独立运行，没有相互之间的沟通或协调。
  概念 Topic ：一个topic就是程序发布消息的一个逻辑键，当程序第一次发布消息时就会创建topic。
Channels ：channel与消费者相关，是消费者之间的负载均衡，channel在某种意义上来说是一个“队列”。每当一个发布者发送一条消息到一个topic，消息会被复制到所有消费者连接的channel上，消费者通过这个特殊的channel读取消息，实际上，在消费者第一次订阅时就会创建channel。Channel会将消息进行排列，如果没有消费者读取消息，消息首先会在内存中排队，当量太大时就会被保存到磁盘中。
Messages：消息构成了我们数据流的中坚力量，消费者可以选择结束消息，表明它们正在被正常处理，或者重新将他们排队待到后面再进行处理。每个消息包含传递尝试的次数，当消息传递超过一定的阀值次数时，我们应该放弃这些消息，或者作为额外消息进行处理。
nsqd：nsqd 是一个守护进程，负责接收，排队，投递消息给客户端。它可以独立运行，不过通常它是由 nsqlookupd 实例所在集群配置的（它在这能声明 topics 和 channels，以便大家能找到）。
nsqlookupd：nsqlookupd 是守护进程负责管理拓扑信息。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息。有两个接口：TCP 接口，nsqd 用它来广播。HTTP 接口，客户端用它来发现和管理。注：是消费者查询去哪里取消息，而不是生产者查询生产消息到哪里去
每个nsqd具有与nsqlookupd的长期TCP连接，在该连接上它定期推送其状态。此数据用于通知nsqlookupd将为消费者提供哪些nsqd地址。对于消费者，将公开HTTP /查找端点以进行轮询。
对于nsqlookupd，通过运行多个实例来实现高可用性。它们不直接相互通信，数据被认为最终是一致的。消费者轮询所有已配置的nsqlookupd实例并将响应联合起来。陈旧，不可访问或其他故障节点不会使系统停止运行。
nsqadmin：nsqadmin 是一套 WEB UI，用来汇集集群的实时统计，并执行不同的管理任务。 常用工具类：</description>
    </item>
    
    <item>
      <title>LeetCode 210 课程表 II（拓扑排序）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 17 May 2020 00:57:15 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接：课程表 II
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
示例 1:
输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:
输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明:
 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。  提示:
 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。  思路 这题算是一个拓扑排序的裸题。如果存在环，就输出空，不存在环就输出正确的顺序。</description>
    </item>
    
    <item>
      <title>LeetCode 560 和为K的子数组(前缀和，思路)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 15 May 2020 00:47:06 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：和为K的子数组
给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :
 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。  思路 有多少个子数组的区间和为 k，假设要统计区间 $[l,r]$ 中的区间和为 k 的数量，我们先对数组求一个前缀和，易得： $$sum[r]-sum[l-1]=k$$ 移项得： $$sum[l-1]=sum[r]-k$$ 其中k是题目中已经给出的，sum[r]是当前求的前缀和的那一项，所以我们只需要累加sum[l-1]的个数即可。用一个哈希存一下前缀和的个数，求前缀和时因为满足l&amp;lt;r，所以不需要开数组，一直累加即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int subarraySum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { unordered_map&amp;lt;long long, int&amp;gt; mp; mp[0] = 1; long long sum = 0, ans = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>LeetCode 236 二叉树的最近公共祖先(递归)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%80%92%E5%BD%92/</link>
      <pubDate>Sun, 10 May 2020 01:00:01 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。说明:
 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。  思路 乍一看是LCA的板子题，对于LCA问题，我们一般用 离线tarjan或者在线倍增来处理，或者用树链剖分
这几种算法，可以在我的ACM模板中找到 最近公共祖先</description>
    </item>
    
    <item>
      <title>LeecCode 221 最大正方形(dp)</title>
      <link>https://blog.riba2534.cn/blog/2020/leeccode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2dp/</link>
      <pubDate>Fri, 08 May 2020 01:56:15 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leeccode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2dp/</guid>
      <description>题目链接：最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4思路 定义dp[i][j]代表以当前坐标(i,j)为正方形右下角的点的最大边长。
我们只需要考虑矩阵中为1的点，只有为1的点才会对答案产生影响，易得dp[i][0]=dp[0][j]=1
对于其他的点，可以由左,上,左上转移过来，对这三个值取最小值，再加上当前点就是答案。即：
$dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { public: int maximalSquare(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;matrix) { if (matrix.</description>
    </item>
    
    <item>
      <title>LeetCode 572 另一个树的子树(dfs,树哈希)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91dfs%E6%A0%91%E5%93%88%E5%B8%8C/</link>
      <pubDate>Thu, 07 May 2020 02:05:57 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91dfs%E6%A0%91%E5%93%88%E5%B8%8C/</guid>
      <description>题目链接：另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
示例 1: 给定的树 s:
 3/ \4 5/ \1 2给定的树 t：
 4 / \1 2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
示例 2: 给定的树 s：
 3/ \4 5/ \1 2/0给定的树 t：
 4/ \1 2返回 false。
思路 方法一：
刚一看这个题，没啥思路，一看难度是简单，就试着写了一发暴力，结果还过了，还超越了70%，那这题基本考察点应该就是暴力dfs了。</description>
    </item>
    
    <item>
      <title>LeetCode 983 最低票价(dp)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7dp/</link>
      <pubDate>Wed, 06 May 2020 01:14:04 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7dp/</guid>
      <description>题目链接：最低票价
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
 一张为期一天的通行证售价为 costs[0] 美元； 一张为期七天的通行证售价为 costs[1] 美元； 一张为期三十天的通行证售价为 costs[2] 美元。  通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
示例 1：
输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, .</description>
    </item>
    
    <item>
      <title>MySQL基础学习笔记</title>
      <link>https://blog.riba2534.cn/blog/2020/mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 05 May 2020 16:01:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>MySQL 基础学习笔记 我的MySQL学习笔记，记录一些MySQL的基础知识。目录在下面：
SQL 语句与种类  DDL（Data Definition Language）数据库定义语言：如 create drop alter DML（Data Manipulation Language）数据操纵语言：如 select insert update delete DCL（Data Control Language）数据控制语言：如 commit rollback grant revoke  我们使用的 SQL 语句中，有 90% 属于 DML
MySQL 数据类型 整数类型：
   类型 占用的存储空间（单位：字节） 无符号数取值范围 有符号数取值范围 含义     TINYINT 1 0 ~ 2⁸-1 -2⁷ ~ 2⁷-1 非常小的整数   SMALLINT 2 0 ~ 2¹⁶-1 -2¹⁵ ~ 2¹⁵-1 小的整数   MEDIUMINT 3 0 ~ 2²⁴-1 -2²³ ~ 2²³-1 中等大小的整数   INT（别名：INTEGER） 4 0 ~ 2³²-1 -2³¹ ~ 2³¹-1 标准的整数   BIGINT 8 0 ~ 2⁶⁴-1 -2⁶³ ~ 2⁶³-1 大整数    浮点类型：</description>
    </item>
    
    <item>
      <title>LeetCode 98 验证二叉搜索树（递归，中序遍历）</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 05 May 2020 01:03:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目链接：验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。  示例 1:
输入:2/ \1 3输出: true示例 2:
输入:5/ \1 4/ \3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4 。思路 方法一：
首先考虑递归的解法，要保证满足二叉搜索树的条件。需要保证左子树的每一个值都要小于当前节点，右子树的每一个值，都要大于当前节点。我们可以维护一个最小值和最大值的范围，当一个点满足小于最大值且大于最小值就是一颗BST。
方法二：
对这棵树进行一次中序遍历，如果是一颗BST，那么遍历结果肯定是一个递增的序列，我们检查一下这个序列是不是递增的即可。
代码 方法一：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: bool dfs(TreeNode *root, long long minn, long long maxx) { if (!</description>
    </item>
    
    <item>
      <title>LeetCode 45 跳跃游戏 II(贪心)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Mon, 04 May 2020 01:56:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii%E8%B4%AA%E5%BF%83/</guid>
      <description>题目链接：跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
示例:
输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明:
假设你总是可以到达数组的最后一个位置。
思路 题目已经给出总是可以到达最后一个位置。
我们考虑贪心的思路，比如样例，第一个数字为2，所以能到达的最大区间为 [i+1,i+nums[i]] ，也就是能跳到的范围为 [1,2]，我们肯定是想尽量到达的比较远，那么我们就从1,2这个区间选出跳的最远的，以这个点为起跳点进行跳，也就是样例中下标为1这个位置的值3，它所能到达的范围是[2,4]，由于2这个位置上一次起跳已经能跳到了，所以就是跳到下标为3或者4的地方时，下标需要加一。
我们维护一个当前能跳到的最远位置maxPos，和当前能跳到的边界end（在不超过end的范围内不用额外跳），遍历一遍数组即可。时间复杂度为$O(n)$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int maxPos = 0, n = nums.size(), end = 0, step = 0; for (int i = 0; i &amp;lt; n - 1; ++i) { if (maxPos &amp;gt;= i) { maxPos = max(maxPos, i + nums[i]); if (i == end) { end = maxPos; ++step; } } } return step; } };   </description>
    </item>
    
    <item>
      <title>各种加密算法流程</title>
      <link>https://blog.riba2534.cn/blog/2020/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 02 May 2020 11:54:48 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B/</guid>
      <description>说到密码，我们第一个想到的就是登陆账户的密码，但是从密码学的角度来看，这种根本就不算合格的密码。
为什么呢，因为我们的账户密码，是依靠隐蔽性来达到加密作用：密码藏在我心里，你不知道，所以你登不上我的账户。
然而密码技术认为，「保密」信息总有一天会被扒出来，所以加密算法不应该依靠「保密」来保证机密性，而应该做到：即便知道了加密算法，依然无计可施。说的魔幻一点就是，告诉你我的密码，你依然不知道我的密码。
最玄学的就是 Diffie-Hellman 密钥交换算法，我当初就觉得很惊奇，两个人当着你的面互相报几个数字，他们就可以拥有一个共同的秘密，而你却根本不可能算出来这个秘密。下文会着重介绍一下这个算法。
本文讨论的密码技术要解决的主要是信息传输中的加密和解密问题。要假设数据传输过程是不安全的，所有信息都在被窃听的，所以发送端要把信息加密，接收方收到信息之后，肯定得知道如何解密。有意思的是，如果你能够让接收者知道如何解密，那么窃听者不是也能够知道如何解密了吗？
下面，我们会介绍对称加密算法、密钥交换算法、非对称加密算法、数字签名、公钥证书，看看解决安全传输问题的一路坎坷波折。
一、对称性加密 对称性密码，也叫共享密钥密码，顾名思义，这种加密方式用相同的密钥进行加密和解密。
比如我说一种最简单的对称加密的方法。首先我们知道信息都可以表示成 0/1 比特序列，也知道相同的两个比特序列做异或运算的结果为 0。
那么我们就可以生成一个长度和原始信息一样的随机比特序列作为密钥，然后用它对原始信息做异或运算，就生成了密文。反之，再用该密钥对密文做一次异或运算，就可以恢复原始信息。
这是一个简单例子，不过有些过于简单，有很多问题。比如密钥的长度和原始信息完全一致，如果原始信息很大，密钥也会一样大，而且生成大量真随机比特序列的计算开销也比较大。
当然，有很多更复杂优秀的对称加密算法解决了这些问题，比如 Rijndael 算法、三重 DES 算法等等。它们从算法上是无懈可击的，也就是拥有巨大的密钥空间，基本无法暴力破解，而且加密过程相对快速。
但是，一切对称加密算法的软肋在于密钥的配送。加密和解密用同一个密钥，发送方必须设法把密钥发送给接收方。如果窃听者有能力窃取密文，肯定也可以窃取密钥，那么再无懈可击的算法依然不攻自破。
所以，下面介绍两种解决密钥配送问题最常见的算法，分别是 Diffie-Hellman 密钥交换算法和非对称加密算法。
二、密钥交换算法 我们所说的密钥一般就是一个很大的数字，算法用这个数加密、解密。问题在于，信道是不安全的，所有发出的数据都会被窃取。换句话说，有没有一种办法，能够让两个人在众目睽睽之下，光明正大地交换一个秘密，把对称性密钥安全地送到接收方的手中？
Diffie-Hellman 密钥交换算法可以做到。准确的说，该算法并不是把一个秘密安全地「送给」对方，而是通过一些共享的数字，双方「心中」各自「生成」了一个相同的秘密，而且双方的这个秘密，是第三方窃听者无法生成的。
也许这就是传说中的心有灵犀一点通吧。
这个算法规则不算复杂，你甚至都可以找个朋友尝试一下共享秘密，等会我会简单画出它的基本流程。在此之前，需要明确一个问题：并不是所有运算都有逆运算。
最简单的例子就是我们熟知的单向散列函数，给一个数字 a 和一个散列函数 f，你可以很快计算出 f(a)，但是如果给你 f(a) 和 f，推出 a 是一件基本做不到的事。密钥交换算法之所以看起来如此玄幻，就是利用了这种不可逆的性质。
下面，看下密钥交换算法的流程是什么，按照命名惯例，准备执行密钥交换算法的双方称为 Alice 和 Bob，在网络中企图窃取他俩通信内容的坏人称为 Hack 吧。
首先，Alice 和 Bob 协商出两个数字 N 和 G 作为生成元，当然协商过程可以被窃听者 Hack 窃取，所以我把这两个数画到中间，代表三方都知道：
现在 Alice 和 Bob 心中各自想一个数字出来，分别称为 A 和 B 吧：
现在 Alice 将自己心里的这个数字 A 和 G 通过某些运算得出一个数 AG，然后发给 Bob；Bob 将自己心里的数 B 和 G 通过相同的运算得出一个数 BG，然后发给 Alice：</description>
    </item>
    
    <item>
      <title>Linux的进程、线程、文件描述符是什么</title>
      <link>https://blog.riba2534.cn/blog/2020/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 02 May 2020 01:35:51 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>Linux的进程、线程、文件描述符是什么 说到进程，恐怕面试中最常见的问题就是线程和进程的关系了，那么先说一下答案：在 Linux 系统中，进程和线程几乎没有区别。
Linux 中的进程就是一个数据结构，看明白就可以理解文件描述符、重定向、管道命令的底层工作原理，最后我们从操作系统的角度看看为什么说线程和进程基本没有区别。
一、进程是什么 首先，抽象地来说，我们的计算机就是这个东西：
这个大的矩形表示计算机的内存空间，其中的小矩形代表进程，左下角的圆形表示磁盘，右下角的图形表示一些输入输出设备，比如鼠标键盘显示器等等。另外，注意到内存空间被划分为了两块，上半部分表示用户空间，下半部分表示内核空间。
用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。
我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。
你编译好的那个可执行程序只是一个文件，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。
那么，操作系统是如何创建进程的呢？对于操作系统，进程就是一个数据结构，我们直接来看 Linux 的源码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  struct task_struct { // 进程状态 	long	state; // 虚拟内存结构体 	struct mm_struct *mm; // 进程号 	pid_t	pid; // 指向父进程的指针 	struct task_struct __rcu *parent; // 子进程列表 	struct list_head	children; // 存放文件系统信息的指针 	struct fs_struct	*fs; // 一个数组，包含该进程打开的文件指针 	struct files_struct	*files; };   task_struct就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，我这里就截取了一小部分比较常见的。</description>
    </item>
    
    <item>
      <title>session和cookie</title>
      <link>https://blog.riba2534.cn/blog/2020/session%E5%92%8Ccookie/</link>
      <pubDate>Sat, 02 May 2020 01:30:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/session%E5%92%8Ccookie/</guid>
      <description>cookie 大家应该都熟悉，比如说登录某些网站一段时间后，就要求你重新登录；再比如有的同学很喜欢玩爬虫技术，有时候网站就是可以拦截住你的爬虫，这些都和 cookie 有关。如果你明白了服务器后端对于 cookie 和 session 的处理逻辑，就可以解释这些现象，甚至钻一些空子无限白嫖，待我慢慢道来。
一、session 和 cookie 简介 cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。
抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。
注意，我说的是「一个」cookie 可以认为是一个变量，但是服务器可以一次设置多个 cookie，所以有时候说 cookie 是「一组」键值对儿，这也可以说得通。
cookie 可以在服务器端通过 HTTP 的 SetCookie 字段设置 cookie，比如我用 Go 语言写的一个简单服务：
1 2 3 4 5 6 7 8 9 10 11 12 13 14  func cookie(w http.ResponseWriter, r *http.Request) { // 设置了两个 cookie 	http.SetCookie(w, &amp;amp;http.Cookie{ Name: &amp;#34;name1&amp;#34;, Value: &amp;#34;value1&amp;#34;, }) http.</description>
    </item>
    
    <item>
      <title>关于Linux Shell需要知道的</title>
      <link>https://blog.riba2534.cn/blog/2020/%E5%85%B3%E4%BA%8Elinux-shell%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/</link>
      <pubDate>Sat, 02 May 2020 01:27:17 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/%E5%85%B3%E4%BA%8Elinux-shell%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/</guid>
      <description>我个人很喜欢使用 Linux 系统，虽然说 Windows 的图形化界面做的确实比 Linux 好，但是对脚本的支持太差了。一开始有点不习惯命令行操作，但是熟悉了之后反而发现移动鼠标点点点才是浪费时间的罪魁祸首。。。
那么对于 Linux 命令行，本文不是介绍某些命令的用法，而是说明一些简单却特别容易让人迷惑的细节问题。
1、标准输入和命令参数的区别。
2、在后台运行命令在退出终端后也全部退出了。
3、单引号和双引号表示字符串的区别。
4、有的命令和sudo一起用就 command not found。
一、标准输入和参数的区别 这个问题一定是最容易让人迷惑的，具体来说，就是搞不清什么时候用管道符|和文件重定向&amp;gt;，&amp;lt;，什么时候用变量$。
比如说，我现在有个自动连接宽带的 shell 脚本connect.sh，存在我的家目录：
1 2  $ where connect.sh /home/fdl/bin/connect.sh   如果我想删除这个脚本，而且想少敲几次键盘，应该怎么操作呢？我曾经这样尝试过：
1  $ where connect.sh | rm   实际上，这样操作是错误的，正确的做法应该是这样的：
1  $ rm $(where connect.sh)   前者试图将where的结果连接到rm的标准输入，后者试图将结果作为命令行参数传入。
标准输入就是编程语言中诸如scanf或者readline这种命令；而参数是指程序的main函数传入的args字符数组。
前文「Linux文件描述符」说过，管道符和重定向符是将数据作为程序的标准输入，而$(cmd)是读取cmd命令输出的数据作为参数。
用刚才的例子说，rm命令源代码中肯定不接受标准输入，而是接收命令行参数，删除相应的文件。作为对比，cat命令是既接受标准输入，又接受命令行参数：
1 2 3 4 5 6 7 8  $ cat filename ...file text... $ cat &amp;lt; filename .</description>
    </item>
    
    <item>
      <title>LeetCode 1095 山脉数组中查找目标值(二分)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%E4%BA%8C%E5%88%86/</link>
      <pubDate>Wed, 29 Apr 2020 01:42:19 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%E4%BA%8C%E5%88%86/</guid>
      <description>题目链接：山脉数组中查找目标值
（这是一个 交互式问题 ）
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length &amp;gt;= 3
其次，在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：
 A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]  你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
 MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始） MountainArray.length() - 会返回该数组的长度  注意：
对 MountainArray.</description>
    </item>
    
    <item>
      <title>TCP三次握手、四次挥手复习</title>
      <link>https://blog.riba2534.cn/blog/2020/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 27 Apr 2020 16:18:53 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%A4%8D%E4%B9%A0/</guid>
      <description>TCP三次握手、四次挥手 三次握手四次挥手知识点复习
   TCP报文头
  格式：
  source port/destination port 分别代表源端口和目标端口
  sequence/acknowledge number 用来标记发送和接收的字节数(序列号和ACK)
  data offset 占 4 位，代表报文头中的字(32位)数，如果没有 options，则为固定值5
  Flags，共 9 位
 NS、CWR、ECE、URG，不懂 ACK，设置了后表示 acknowledge 字段生效 PSH，要求将缓存的数据推送给接收方 RST，重置连接，比如接收方已经关闭连接，收到迟到的报文，则会重置报文 SYN，三次握手第一次，代表同步 sequence number FIN，四次挥手时的结束报文    Window size，拥塞控制中的窗口大小
  Checksum，校验码，用于传输检测过程中的错误
  Urgent pointer，不懂
  Options，一般在三次握手、四次挥手中用到。不懂
    三次握手
  客户端随机生成一个序列号（sequence number），并发送SYN报文到服务端，请求连接
  服务端发送 SYN+ACK ，在应答请求的同时，也生成一个sequence id，请求同步</description>
    </item>
    
    <item>
      <title>Kafka基础知识</title>
      <link>https://blog.riba2534.cn/blog/2020/kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 27 Apr 2020 16:17:04 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>Kafka 简介  Apache Kafka is a distributed high throughput message system
Apache Kafka is a distributed streaming platform
 Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。
设计理念  低延迟：以时间复杂度 O(1) 的方式提供消息处理能力，即使对 TB 以上的数据也能保证常数时间复杂度的访问性能 高吞吐：即使在非常廉价的商用机器上也能做到单机支持每秒十万条以上的消息传输 水平扩展：支持 Kafka Broker 间的消息分区，及分布式消费，同时支持在线水平扩展 顺序性：保证每个 Partition 内的消息顺序传输 多场景：同时支持离线数据处理和实时数据处理  kafka基础   Kafka引入了 Consumer Group模式来进行工作
  一个Group内可以有多个消费者，Group内的消费者以队列模式进行工作
    Partition与消费模型
  Kafka中的一个topic是被打散分配在多个Partition中存储的，Consumer Group在消费时需要从不同的Partition中获取消息，如何重建Topic中的顺序呢
 没有办法，Kafka只保证消息在Partition中有序，而不管全局情况    Partition中的消息可以被不同的Group多次消费，那Partition中被消费的消息是何时删除的？Partition是如何知道一个Consumer Group的消费位置呢？</description>
    </item>
    
    <item>
      <title>LeetCode 23 合并K个排序链表(堆)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%A0%86/</link>
      <pubDate>Sun, 26 Apr 2020 02:40:05 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%A0%86/</guid>
      <description>题目链接：合并K个排序链表
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
示例:
输入:[1-&amp;gt;4-&amp;gt;5,1-&amp;gt;3-&amp;gt;4,2-&amp;gt;6]输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6思路 题意很清楚，现在的问题就是应该怎么合并。
由于每一个链表都是递增的，所以我们维护这三个链表中的三个头节点，每次取出值最小放在最终的答案链表中，这个过程可以使用优先队列来维护，时间复杂度$O(kn*logk)$,空间复杂度为$O(k)$.
代码 优先队列：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public: struct status { ListNode *ptr; int val; bool operator&amp;lt;(const status &amp;amp;rhs) const { return val &amp;gt; rhs.</description>
    </item>
    
    <item>
      <title>LeetCode 面试题51 数组中的逆序对(线段树&#43;树状数组&#43;离散化)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%A6%BB%E6%95%A3%E5%8C%96/</link>
      <pubDate>Fri, 24 Apr 2020 02:40:25 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%A6%BB%E6%95%A3%E5%8C%96/</guid>
      <description>题目链接：数组中的逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
示例 1:
输入: [7,5,6,4]输出: 5限制：
0 &amp;lt;= 数组长度 &amp;lt;= 50000思路 逆序数的定义，题目已经给出。我们的核心诉求就是，对于每一项nums[i]，求出在这个数之前，比它大的数的个数，累加起来就是答案。我们考虑如何解决这个问题。
由于只给出了数字的数量，没有给出数字的大小范围，所以先用离散化处理一下，保证所有数的区间都在[1,50000]内。
方法1：线段树
首先此题可以用一个线段树来维护，线段树的功能是区间求和。依次遍历数组，先求出当前线段树中，大于当前遍历的nums[i]的数的个数，然后再把当前的数更新到线段树上去（为了保证线段树上的数都是遍历的数之前的），让树上的这个点加一，然后累加起来就是答案。
方法2：树状数组
顺着这个思路，我们可以同样考虑一下用树状数组来实现，离散化不用说。首先，要知道树状数组的功能是啥，功能是：单点更新，可以求出[1,n]的和。那么这个性质如何在逆序数中使用呢？考虑，数字的数量是固定的，对于当前遍历到的nums[i]，可以求出[1,num[i]]的和，代表比nums[i]小的数有多少个，那么i-sum(1,nums[i])就求出了它之前比它大的有多少个。同样也是边遍历边更新。
代码 线段树：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  class Solution { public: int sum[4 * 50001]; void pushup(int rt) { sum[rt] = sum[rt &amp;lt;&amp;lt; 1] + sum[rt &amp;lt;&amp;lt; 1 | 1]; } void build(int l, int r, int rt) { sum[rt] = 0; if (l == r) return; int m = (l + r) &amp;gt;&amp;gt; 1; build(l, m, rt &amp;lt;&amp;lt; 1); build(m + 1, r, rt &amp;lt;&amp;lt; 1 | 1); } void update(int p, int l, int r, int rt) { if (l == r) { sum[rt]++; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, l, m, rt &amp;lt;&amp;lt; 1); else update(p, m + 1, r, rt &amp;lt;&amp;lt; 1 | 1); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R) { return sum[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1; int ret = 0; if (L &amp;lt;= m) ret += query(L, R, l, m, rt &amp;lt;&amp;lt; 1); if (R &amp;gt; m) ret += query(L, R, m + 1, r, rt &amp;lt;&amp;lt; 1 | 1); return ret; } int reversePairs(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.</description>
    </item>
    
    <item>
      <title>LeetCode 面试题 08.11. 硬币(dp)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-08.11.-%E7%A1%AC%E5%B8%81dp/</link>
      <pubDate>Thu, 23 Apr 2020 01:48:52 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-08.11.-%E7%A1%AC%E5%B8%81dp/</guid>
      <description>题目链接：硬币
硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
示例1:
 输入: n = 5输出：2解释: 有两种方式可以凑成总金额:5=55=1+1+1+1+1示例2:
 输入: n = 10输出：4解释: 有四种方式可以凑成总金额:10=1010=5+510=5+1+1+1+1+110=1+1+1+1+1+1+1+1+1+1说明：
注意:
你可以假设：
 0 &amp;lt;= n (总金额) &amp;lt;= 1000000  思路 类似于完全背包，求方案数。
定义dp[n]表示用这些硬币凑成面额为n的方案数。如果需要凑出一个面额，假设当前硬币面额为v[i]，则方案数可以累加为：dp[n]+=dp[n-v[i]]，代表用已知的可以凑成n-v[i]面额的方案数加上当前的硬币面额，可以凑出n。
时间复杂度：$O(n)$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: int mod = 1e9 + 7; int v[4] = {1, 5, 10, 25}; int waysToChange(int n) { vector&amp;lt;int&amp;gt; dp(n + 1, 0); dp[0] = 1; for (int i = 0; i &amp;lt; 4; i++) for (int j = v[i]; j &amp;lt;= n; j++) dp[j] = (dp[j] + dp[j - v[i]]) % mod; return dp[n]; } };   </description>
    </item>
    
    <item>
      <title>LeetCode 199 二叉树的右视图(dfs)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEdfs/</link>
      <pubDate>Wed, 22 Apr 2020 01:49:22 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEdfs/</guid>
      <description>题目链接：二叉树的右视图
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例:
输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:1 &amp;lt;---/ \2 3 &amp;lt;---\ \5 4 &amp;lt;---思路 题目要求二叉树的右视图，直接用dfs遍历，那么我们就需要尽量往右找，因为可能右子树遍历完了，左子树的深度还有更深的。需要用一个哈希来记录一下，当前层是不是已经找到了最右边的点，找到了就标记一下，没找到就加入到答案的列表中。最后输出结果即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; ans; unordered_map&amp;lt;int, int&amp;gt; mp; void dfs(TreeNode *node, int deep) { if (!</description>
    </item>
    
    <item>
      <title>LeetCode 1248 统计「优美子数组」(前缀和，思路)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-1248-%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 21 Apr 2020 11:06:37 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-1248-%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：统计「优美子数组」
给你一个整数数组 nums 和一个整数 k。
如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。
请返回这个数组中「优美子数组」的数目。
示例 1：
输入：nums = [1,1,2,1,1], k = 3输出：2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。示例 2：
输入：nums = [2,4,6], k = 1输出：0解释：数列中不包含任何奇数，所以不存在优美子数组。示例 3：
输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2输出：16提示：
 1 &amp;lt;= nums.length &amp;lt;= 50000 1 &amp;lt;= nums[i] &amp;lt;= 10^5 1 &amp;lt;= k &amp;lt;= nums.length  思路 根据题意，偶数是没有用的，先预处理一下，通过 nums[i]&amp;amp;1 的方式处理成01字符串，题目就变成了有多少个子数组的区间和为k，假设要统计区间$[l,r]$中的区间和为k的数量，我们先对数组求一个前缀和，易得：$sum[r]-sum[l-1]=k$，移项得：$sum[l-1]=sum[r]-k$，其中k是题目中已经给出的，sum[r]是当前求的前缀和的那一项，所以我们只需要累加sum[l-1]的个数即可。用一个哈希存一下前缀和的个数，求前缀和时因为满足l&amp;lt;r，所以不需要开数组，一直累加即可。
和560题一模一样。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int numberOfSubarrays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { unordered_map&amp;lt;long long, int&amp;gt; mp; mp[0] = 1; int sum = 0, ans = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>LeetCode 466 统计重复个数(找循环节)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-466-%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/</link>
      <pubDate>Sun, 19 Apr 2020 14:30:15 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-466-%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/</guid>
      <description>题目链接：统计重复个数
由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[&amp;quot;abc&amp;quot;,3]=“abcabcabc”。
如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，&amp;ldquo;abc&amp;rdquo; 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。
现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。
请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。
示例：
输入：s1 =&amp;quot;acb&amp;quot;,n1 = 4s2 =&amp;quot;ab&amp;quot;,n2 = 2返回：2思路 题意翻译成白话就是给了你两个串s1和s2，然后问s1中最多包含多少个s2。其中，这两个串的给出方式是给一个前缀串和一个数字，最后的串等于前缀串重复几次。
思路就是找循环节，最后用除法计算一下出现了多少次，这一部分可以参考 官方题解 。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  class Solution { public: int getMaxRepetitions(string s1, int n1, string s2, int n2) { if (n1 == 0) return 0; int s1cnt = 0, s2cnt = 0, index = 0; // mp[index]={s1cnt,s2cnt}表示，第index个字符在遍历s1cnt次s1和s2cnt次s2出现的  unordered_map&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; mp; pair&amp;lt;int, int&amp;gt; pre, in; while (1) { s1cnt++; for (char ch : s1) { if (ch == s2[index]) { index++; if (index == s2.</description>
    </item>
    
    <item>
      <title>LeetCode 11 盛最多水的容器(双指针)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 18 Apr 2020 11:44:52 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>题目链接：盛最多水的容器
给你 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
**说明：**你不能倾斜容器，且 n 的值至少为 2。
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例：
输入：[1,8,6,2,5,4,8,3,7]输出：49思路 根据题意，对于题目的问题，我们假设左右端点为l和r，那么面积为：$S=(r-l)*min(height[l],height[r])$，我们需要求出最大的$S$。
做法是我们开始让l和r指向序列的头和尾，此时需要移动双指针，那么如何移动呢，做法是移动左右端点值比较小的那个，如果是左端点就向右移，如果是右端点就向左移，中途每算出一次面积，就求最大值，最后的结果就是答案。
那么如何证明这个策略的正确性呢，我们考虑，根据上面的公式，如果我们移动大的而不是小的，那么移动后$min(height[l],height[r])$的值并没有改变，只可能减小，不可能增大，因为我们进行了移动，则$(r-l)$一定会减小，这样的话，面积$S$一定会减小，所以我们的策略要移动小的，而不是大的。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int maxArea(vector&amp;lt;int&amp;gt; &amp;amp;height) { // s = (r-l)*min(a[l],a[r]) ,求 max(s)  int maxx = 0, l = 0, r = height.</description>
    </item>
    
    <item>
      <title>LeetCode 55 跳跃游戏(贪心)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Fri, 17 Apr 2020 11:46:08 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/</guid>
      <description>题目链接：跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。示例 2:
输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。思路 刚开始看题感觉是个dp，于是没想到状态转移，写了发暴搜验证一下正确性，交了一下超时了。然后考虑了一下，这道题应该$O(n)$过，所以应该是个贪心了。
我们从第一个位置开始，维护一下最远能到达的位置，$O(n)$遍历，当当前位置不能到达的时候，那么肯定是到不了最后一个的，直接返回false，如果能正常遍历完，那么肯定是可以到最后一个位置的，代码特别简单。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int limit_pos = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>LeetCode 56 合并区间(贪心)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Thu, 16 Apr 2020 14:31:58 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</guid>
      <description>题目链接：合并区间
给出一个区间的集合，请合并所有重叠的区间。
示例 1:
输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].示例 2:
输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。思路 一个小贪心，把区间按照左端点排序。初始值设置为第一个区间的左和右。
然后遍历排序好的区间，如果遍历到的区间左端点小于等于r，就扩展r，等到不满足条件时证明这个区间最多就包含这么多，继续下一个区间即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public: static bool cmp(pair&amp;lt;int, int&amp;gt; a, pair&amp;lt;int, int&amp;gt; b) { return a.</description>
    </item>
    
    <item>
      <title>LeetCode 542 01 矩阵(BFS)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-542-01-%E7%9F%A9%E9%98%B5bfs/</link>
      <pubDate>Wed, 15 Apr 2020 11:44:49 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-542-01-%E7%9F%A9%E9%98%B5bfs/</guid>
      <description>题目链接：01 矩阵
给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
示例 1: 输入:
0 0 00 1 00 0 0输出:
0 0 00 1 00 0 0示例 2: 输入:
0 0 00 1 01 1 1输出:
0 0 00 1 01 2 1注意:
 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。  思路 广搜BFS，和 1162 地图分析有点像，题目要求出每个元素与0最近的距离是多少，那么不用问，肯定值为0的点的距离还是0，其余的可以搜出来。
首先把值为0的坐标全部入队，像四个方向搜索，如果是1，当前的步数就+1，如果是0，那步数不变，只需要在搜索的时候，一直给答案的距离与当前步数取最小值即可。</description>
    </item>
    
    <item>
      <title>LeetCode 887 鸡蛋掉落(dp,记忆化搜索，二分)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BDdp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%88%86/</link>
      <pubDate>Sat, 11 Apr 2020 15:59:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BDdp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%88%86/</guid>
      <description>题目链接：鸡蛋掉落
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。
你的目标是确切地知道 F 的值是多少。
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
示例 1：
输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。示例 2：</description>
    </item>
    
    <item>
      <title>LeetCode 22 括号生成(递归)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 09 Apr 2020 11:55:17 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：
输入：n = 3输出：[&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;]思路 方法1：暴力 观察易得，符合括号序列和$n$的关系是，括号序列的个数有$2^{2n}$个，我们先把所有$2^{2n}$的括号全部打表打出来，然后再检验是否合法，最后输出合法的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  class Solution { public: bool valid(string &amp;amp;str) { int balance = 0; for (char c : str) { if (c == &amp;#39;(&amp;#39;) balance++; else { balance--; if (balance &amp;lt; 0) return false; } } return balance == 0; } void generate_all(string &amp;amp;cur, int n, vector&amp;lt;string&amp;gt; &amp;amp;result) { if (n == cur.</description>
    </item>
    
    <item>
      <title>LeetCode 72 编辑距离(dp)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBdp/</link>
      <pubDate>Mon, 06 Apr 2020 11:50:20 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBdp/</guid>
      <description>题目链接：编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
 插入一个字符 删除一个字符 替换一个字符  示例 1：
输入：word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot;输出：3解释：horse -&amp;gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&amp;gt; rose (删除 &#39;r&#39;)rose -&amp;gt; ros (删除 &#39;e&#39;)示例 2：
输入：word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot;输出：5解释：intention -&amp;gt; inention (删除 &#39;t&#39;)inention -&amp;gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&amp;gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&amp;gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&amp;gt; execution (插入 &#39;u&#39;)思路 简单dp，定义dp[i][j]代表把第一个串的前i个字符，变成第2个串的前j个字符，需要花费的代价。</description>
    </item>
    
    <item>
      <title>LeetCode 460 LFU缓存(模拟)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-460-lfu%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Mon, 06 Apr 2020 11:49:42 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-460-lfu%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目描述：LFU缓存
设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。
get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。 put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。
一个项目的使用次数就是该项目被插入后对其调用 get 和 put 函数的次数之和。使用次数会在对应项目被移除后置为 0。
进阶： 你是否可以在 O(1) 时间复杂度内执行两项操作？
示例：
LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 去除 key 2cache.get(2); // 返回 -1 (未找到key 2)cache.get(3); // 返回 3cache.put(4, 4); // 去除 key 1cache.get(1); // 返回 -1 (未找到 key 1)cache.</description>
    </item>
    
    <item>
      <title>LeetCode 289 接雨水(单调栈)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-289-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Mon, 06 Apr 2020 11:48:56 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-289-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>题目链接：接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6思路 用单调栈的思路，维护一个递减的单调栈，当不满足递减条件的时候，每弹出一个元素，就计算出这一块区域能接的水量，最后的和就是答案，复杂度为$O(n)$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { int ans = 0; stack&amp;lt;int&amp;gt; st; for (int i = 0; i &amp;lt; height.size(); i++) { while (!st.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[st.</description>
    </item>
    
    <item>
      <title>LeetCode 289 生命游戏(模拟)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Thu, 02 Apr 2020 14:40:49 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目链接：生命游戏
根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；  根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。
示例：
输入：
[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]输出：
[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]进阶：
你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？
思路 中文题意，刚开始看到题以为是个搜索之类的，用手推了一下样例。发现一个格子的状态改变不会，以后的格子计算状态还是按照格子上原来的数字计算状态的，所以问题就非常简单了，把原数组复制一遍，计算八个方向的活细胞的数量，直接按照题意改一下活细胞或死细胞状态即可，最后用复制出来的数组覆盖原数组。
或者也可以不复制数组，直接在原数组上做一些标记也可以实现。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Solution { public: int go[8][2] = {1, 0, -1, 0, 0, 1, 0, -1, 1, 1, 1, -1, -1, 1, -1, -1}; void gameOfLife(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;board) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; grid = board; int n = board.</description>
    </item>
    
    <item>
      <title>LeetCode 1111 有效括号的嵌套深度(找规律)</title>
      <link>https://blog.riba2534.cn/blog/2020/leetcode-1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Wed, 01 Apr 2020 14:29:14 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2020/leetcode-1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>题目链接：有效括号的嵌套深度
有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。
嵌套深度 depth 定义：即有效括号字符串嵌套的层数。详情参见题末「嵌套深度」部分。
给你一个「有效括号字符串」 seq，请你将其分成两个不相交的子序列 A 和 B，且 A 和 B 都满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。
由于可能存在多种划分方案，请你从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。其中 depth(A) 表示 A 的嵌套深度，depth(B) 表示 B 的嵌套深度。
请你返回一个长度为 seq.length 的答案数组 answer，编码规则如下：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。
示例 1：
输入：seq = &amp;quot;(()())&amp;quot;输出：[0,1,1,1,1,0]示例 2：
输入：seq = &amp;quot;()(())()&amp;quot;输出：[0,0,0,1,1,0,1,1]提示：
1 &amp;lt;= text.size &amp;lt;= 10000有效括号字符串：
仅由 &amp;quot;(&amp;quot; 和 &amp;quot;)&amp;quot; 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。</description>
    </item>
    
    <item>
      <title>主流消息队列介绍</title>
      <link>https://blog.riba2534.cn/blog/2019/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 13 Dec 2019 20:32:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D/</guid>
      <description>主流消息队列介绍  RabbitMQ  特点  Erlang 语言编写 为电信行业可靠性设计 支持 AMQP 协议 轻量级，容易部署及使用 每秒几万到十几万   劣势  消息大量堆积时，性能会下降 性能相比较于其他的比较差 Erlang 太冷门，不好维护     RocketMQ  特点  阿里巴巴 2012 开源，后来捐给 Apache 成了顶级项目 可靠性、稳定性高的国产消息队列，时延低 中文社区活跃 JAVA 开发，贡献者大多是中国人 比 RabbitMQ 的性能高出一个数量级，每秒钟能处理几十万条消息   劣势  作为国产的消息队列，在国际上没有那么流行     Kafka  特点  由 LinkedIn 开发，也是 Apache 顶级项目 早期为了获得高性能，设计方面有牺牲  不保证消息可靠性 可能丢失消息 不支持集群   当前的 Kafka 已经成熟，可靠性稳定性已经可以满足绝大多数场景 周边生态好，在大数据和流式计算领域，所有的相关开源软件都会优先支持 kafka 使用 Scala 和 JAVA 开发，Kafka 的异步收发性能是三者最好的   劣势  同步收发消息响应时延比较高  客户端发一条消息时，kafka 不会立即发送，而是要等一会攒一批再发送，所以不适合在线业务场景       ActiveMQ  特点  最老牌开源消息队列 十年前唯一可供选择的消息队列 存在的意义是兼容还在用的爷爷辈的系统   劣势  社区不活跃 功能和性能差     ZeroMQ  基于消息队列的多线程网络库 如果需求是把消息队列的功能集成进系统进程中，可以考虑使用   Pulsar  新兴消息队列产品 处于成长期 存储和计算分离设计 也许是未来发展方向，建议关注    </description>
    </item>
    
    <item>
      <title>消息队列的消息模型</title>
      <link>https://blog.riba2534.cn/blog/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 13 Dec 2019 20:32:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/</guid>
      <description>消息队列的消息模型   主题和队列
  好的队列不是设计出来的，而是演进出来的
  最初的消息队列模型
 严格意义上的队列，数据结构中的队列 满足先进先出 要求满足严格有序 队列没有读操作，只有「出队」 多个生产者写，可消费到的信息是这些生产者生产的消息合集，每个消费者只能收到队列的一部分信息，任何一条消息只能被一个消费者收到 如果需要每个消费者都受到全量的消息怎么办？  为每个消费者单独创建一个队列，让生产者发送多份  方法比较蠢 浪费资源 生产者必须要知道有多少个消费者，违背了「解耦」的初衷        发布-订阅模型
  模型图
  发送方被称为发布者，接收方被称为订阅者
  服务端存放消息的容器叫做主题
  发布者将消息发布进主题中，订阅者需要先「订阅主题」
  「订阅」是一个动作，同时可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息
    对比
 在消息队列历史上很长时间，这两种模式是并存的，有些消息队列同时支持这两种模型，比如 ActiveMQ。 这两种模型，生产者就是发布者，消费者就是订阅者，队列就是主题 最大区别就是，一份消息数据能不能被消费多次      RabbitMQ 消息模型
  坚持使用队列模型的产品之一
  通过 Exchange 模块，此模块位于生产者和队列之间，生产者并不关心将消息发到哪个队列，而是将消息发送给 Exchange，由 Exchange 配置的策略来决定将消息投递到哪些队列当中</description>
    </item>
    
    <item>
      <title>消息队列的功能和用途</title>
      <link>https://blog.riba2534.cn/blog/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%94%A8%E9%80%94/</link>
      <pubDate>Fri, 13 Dec 2019 20:31:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%94%A8%E9%80%94/</guid>
      <description>消息队列的功能和用途  解耦  上游关注通知，不关注处理 下游只关注处理，约定好消息格式   流量控制  应对突发流量，削峰填谷  大量请求先放入消息队列，然后服务端按照自己最大能力去处理     广播  一条消息，可以被多个下游处理   异步  收到消息之后，不需要马上进行，提高效率  秒杀系统  用户秒杀只需要通过风险控制以及库存锁定这两个操作就可以了 后续生成订单，短信通知，可以用消息队列异步处理       冗余  消息可以被持久化，容易回溯   选择消息队列的基本标准  消息的可靠传递，确保不丢消息 Cluster 支持集群，确保不会因为某个节点而导致集群不可用 性能，性能要满足场景的需要    </description>
    </item>
    
    <item>
      <title>Linux 网络通信瑞士军刀 nc 命令使用</title>
      <link>https://blog.riba2534.cn/blog/2019/linux-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-nc-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 27 Sep 2019 18:36:41 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/linux-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-nc-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</guid>
      <description>Linux 网络通信瑞士军刀 nc 命令使用 简介 netcat也就是nc被称为TCP/IP的瑞士军刀。以体积小，功能灵活著称。在各个发行版有默认安装，可以用来做很多网络相关的工作。它是一款拥有多种功能的 CLI 工具，可以用来在网络上读、写以及重定向数据。 它被设计成可以被脚本或其他程序调用的可靠的后端工具。同时由于它能创建任意所需的连接，因此也是一个很好的网络调试工具。甚至还可以作为简单的 TCP 代理。
我简单的列一下我使用过的常用的命令。
命令选项：
1 2 3 4 5 6 7 8 9 10 11 12 13 14  -g&amp;lt;网关&amp;gt;：设置路由器跃程通信网关，最多设置 8 个； -G&amp;lt;指向器数目&amp;gt;：设置来源路由指向器，其数值为 4 的倍数； -h：在线帮助； -i&amp;lt;延迟秒数&amp;gt;：设置时间间隔，以便传送信息及扫描通信端口； -l：使用监听模式，监控传入的资料； -n：直接使用 ip 地址，而不通过域名服务器； -o&amp;lt;输出文件&amp;gt;：指定文件名称，把往来传输的数据以 16 进制字码倾倒成该文件保存； -p&amp;lt;通信端口&amp;gt;：设置本地主机使用的通信端口； -r：指定源端口和目的端口都进行随机的选择； -s&amp;lt;来源位址&amp;gt;：设置本地主机送出数据包的 IP 地址； -u：使用 UDP 传输协议； -v：显示指令执行过程； -w&amp;lt;超时秒数&amp;gt;：设置等待连线的时间； -z：使用 0 输入/输出模式，只在扫描通信端口时使用。   常用命令 传输测试 1  nc -l 8080   这个命令会监听本机 8080 端口，直到有 http 请求过来，然后显示出相关信息。</description>
    </item>
    
    <item>
      <title>彻底解决go get golang.org/x等包失败与VSCode golang插件安装失败问题</title>
      <link>https://blog.riba2534.cn/blog/2019/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3go-get-golang.org-x%E7%AD%89%E5%8C%85%E5%A4%B1%E8%B4%A5%E4%B8%8Evscode-golang%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 23 Sep 2019 16:16:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3go-get-golang.org-x%E7%AD%89%E5%8C%85%E5%A4%B1%E8%B4%A5%E4%B8%8Evscode-golang%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</guid>
      <description>问题描述 由于某种众所周知的一些原因，https://golang.org/ golang 的官方域名是被墙了的，这也就导致了，在广大 go 开发者使用 golang 的时候，总会出现 go get 失败的问题。解决这个问题的办法，网上一搜一大堆，总结一下，网上大概有两种解决方案。
 因为 go get 不到的库，一般来说在 github 都有人做了镜像，这个时候一般是曲线救国，从 github 上面搞下来，然后把对应的东西放在对应目录，这种方式比较麻烦，而且比较慢。 用代理，需要一台国外服务器，开启一个 http 代理或者 socks5 代理，或者各种梯子，曲线救国，这种方式其实挺好的，我之前一直用这种方式，不过需要国外服务器以及其他一些知识。或者设置 GOPROXY 等。  解决方案 golang 的 1.13 版本已经正式发布了，这个版本中，新的包管理方式 Go module 已经正式被扶正，还有支持 go 模块代理。对于咱们中国的开发者来说，一个优秀的 Go 模块代理可以帮助我们解决很多问题。比如 Go 语言中最知名的 golang.org/x/&amp;hellip; 模块在中国大陆是无法访问到的，以前我们会用很多其他的办法来抓取他们，而若依靠一个可以访问到它们的模块代理，那么将事半功倍。更因为 Go 1.13 将 GOPROXY 默认成了中国大陆无法访问的 https://proxy.golang.org ，所以我们中国的开发者从今以后必须先修改 GOPROXY 才能正常使用 go 来开发应用了。为此，我们联合中国备受信赖的云服务提供商七牛云专门为咱们中国开发者而打造了一个 Go 模块代理：goproxy.cn。github地址：goproxy
那么如何使用这个代理呢？只需要一句命令。
1  go env -w GOPROXY=https://goproxy.cn,direct   完成。然后进行 go get 以及其他获取包的命令，都会经过七牛云进行代理，速度回有一个质的飞跃。前提是需要把 go 版本升级为 &amp;gt;=1.</description>
    </item>
    
    <item>
      <title>Golang的反射reflect深入理解和示例</title>
      <link>https://blog.riba2534.cn/blog/2019/golang%E7%9A%84%E5%8F%8D%E5%B0%84reflect%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%92%8C%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Thu, 29 Aug 2019 22:16:02 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/golang%E7%9A%84%E5%8F%8D%E5%B0%84reflect%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%92%8C%E7%A4%BA%E4%BE%8B/</guid>
      <description>Golang的反射reflect深入理解和示例 编程语言中反射的概念 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。
每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。
多插一句，Golang的gRPC也是通过反射实现的。
interface 和 反射 在讲反射之前，先来看看Golang关于类型设计的一些原则
 变量包括（type, value）两部分  理解这一点就知道为什么nil != nil了   type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型 类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.  接下来要讲的反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。
在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:
1  (value, type)   value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。
例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：
1 2 3 4  tty, err := os.OpenFile(&amp;#34;/dev/tty&amp;#34;, os.O_RDWR, 0) var r io.Reader r = tty   接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:
1 2  var w io.</description>
    </item>
    
    <item>
      <title>正则表达式30分钟入门</title>
      <link>https://blog.riba2534.cn/blog/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 17 Jul 2019 10:38:01 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/</guid>
      <description>转载自：https://deerchao.net/tutorials/regex/regex.htm
如何使用本教程 别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。
除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？
本文将会对特别的字符做一些 斜体，加粗 处理，希望读者在阅读的时候可以多体会和留心这些细节，从而有更深刻的了解。# 正则表达式到底是什么东西？
在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。
很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是 &amp;lsquo;*&amp;rsquo; 和 &amp;lsquo;?&#39;。
如果你想查找某个目录下的所有的Word文档的话，你会搜索 *.doc。在这里，&amp;quot; * &amp;ldquo;会被解释成任意的字符串。
和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以 0 开头，后面跟着 2-3 个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。
入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。
假设你在一篇英文小说里查找hi，你可以使用正则表达式 &amp;quot; hi &amp;ldquo;。
这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是 h, 后一个是 i。
通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配 hi, HI, Hi, hI 这四种情况中的任意一种。
不幸的是，很多单词里包含 hi 这两个连续的字符，比如 him, history, high 等等。用 hi 来查找的话，这里边的 hi 也会被找出来。如果要精确地查找 hi 这个单词的话，我们应该使用 \bhi\b。
\b 是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是 \b 并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。
如果需要更精确的说法，\b 匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在) \w。
假如你要找的是 hi 后面不远处跟着一个 Lucy，你应该用 \bhi\b.*\bLucy\b。
这里，. 是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.* 连在一起就意味着任意数量的不包含换行的字符。现在 \bhi\b.*\bLucy\b 的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。
换行符就是 &#39;\n&#39;, ASCII编码为10(十六进制0x0A)的字符。</description>
    </item>
    
    <item>
      <title>Gin官方文档</title>
      <link>https://blog.riba2534.cn/blog/2019/gin%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 17 Jul 2019 10:32:01 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/gin%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</guid>
      <description>安装与配置 安装：
1  $ go get gopkg.in/gin-gonic/gin.v1   注意：确保 GOPATH GOROOT 已经配置
导入：
1  import &amp;#34;gopkg.in/gin-gonic/gin.v1&amp;#34;   框架架构  HTTP 服务器  1.默认服务器
1  router.Run()   2.HTTP 服务器
除了默认服务器中 router.Run() 的方式外，还可以用 http.ListenAndServe()，比如
1 2 3 4  func main() { router := gin.Default() http.ListenAndServe(&amp;#34;:8080&amp;#34;, router) }   或者自定义 HTTP 服务器的配置：
1 2 3 4 5 6 7 8 9 10 11 12  func main() { router := gin.</description>
    </item>
    
    <item>
      <title>Bash常用快捷键</title>
      <link>https://blog.riba2534.cn/blog/2019/bash%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 16 Jul 2019 11:55:25 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/bash%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>移动光标  ctrl+b: 前移一个字符(backward) ctrl+f: 后移一个字符(forward) alt+b: 前移一个单词 alt+f: 后移一个单词 ctrl+a: 移到行首（a是首字母） ctrl+e: 移到行尾（end） ctrl+xx: 行首到当前光标替换  编辑命令  alt+.: 粘帖最后一次命令最后的参数（通常用于mkdir long-long-dir后, cd配合着alt+.） alt+d: 删除当前光标到临近右边单词开始(delete) ctrl+w: 删除当前光标到临近左边单词结束(word) ctrl+h: 删除光标前一个字符（相当于backspace） ctrl+d: 删除光标后一个字符（相当于delete） ctrl+u: 删除光标左边所有 ctrl+k: 删除光标右边所有 ctrl+l: 清屏 ctrl+shift+c: 复制（相当于鼠标左键拖拽） ctrl+shift+v: 粘贴（相当于鼠标中键）  其它  ctrl+n: 下一条命令 ctrl+p: 上一条命令 alt+n: 下一条命令（例如输入ls, 然后按&amp;rsquo;alt+n&#39;, 就会找到历史记录下的ls命令） alt+p: 上一条命令（跟alt+n相似） shift+PageUp: 向上翻页 shift+PageDown: 向下翻页 ctrl+r: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项  zsh  d: 列出以前的打开的命令 j: jump到以前某个目录，模糊匹配  Vim 移动光标  b: 向前移动一个单词 w: 向后移动一个单词  删除  dw: 从当前光标开始删除到下一个单词头 de: 从当前光标开始删除到单词尾  </description>
    </item>
    
    <item>
      <title>乐观锁和悲观锁</title>
      <link>https://blog.riba2534.cn/blog/2019/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</link>
      <pubDate>Tue, 16 Jul 2019 01:13:06 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</guid>
      <description>乐观锁与悲观锁 何谓悲观锁与乐观锁  乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。
 悲观锁 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
乐观锁 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
两种锁的使用场景 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
乐观锁常见的两种实现方式  乐观锁一般会使用版本号机制或CAS算法实现。
 1. 版本号机制 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 100 。
 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（ 100-50 ）。 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20 （ 100-20 ）。 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。  这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</description>
    </item>
    
    <item>
      <title>Golang 中的 Map 原理</title>
      <link>https://blog.riba2534.cn/blog/2019/golang%E4%B8%ADmap%E7%9A%84%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 14 Jul 2019 17:12:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/golang%E4%B8%ADmap%E7%9A%84%E5%8E%9F%E7%90%86/</guid>
      <description>什么是映射函数 要明白 map 是如何工作的的，我们需要先讨论一下 map 函数。一个 map 函数用以将一个值映射到另一个值。给定一个值，我们叫 key，它就会返回另外一个值，称为 value。
map(key) → value现在，map 还没什么用，除非我们放入一些数据。我们需要一个函数来将数据添加到 map 中
insert(map, key, value)和一个函数从 map 中移除数据
delete(map, key)在实现上还有一些有趣的点比如查询某个 key 当前在 map 中是否存在，但这已经超出了我们今天要讨论的范围。相反我们今天只专注于这几个点；插入，删除和如何将 key 映射到 value。
Go 中的 map 是一个 hashmap Hashmap 是我要讨论的的 map 的一种特定实现，因为这也是 Go runtime 中所采用的实现方式。Hashmap 是一种经典的数据结构，提供了平均 O(1) 的查询时间复杂度，即使在最糟的情况下也有 O(n) 的复杂度。也就是说，正常情况下，执行 map 函数的时间是个常量。
这个常量的大小部分取决于 hashmap 的设计方式，而 map 存取时间从 O(1) 到 O(n) 的变化则取决于它的 hash 函数。
hash 函数 什么是 hash 函数 ？一个 hash 函数用以接收一个未知长度的 key 然后返回一个固定长度的 value。</description>
    </item>
    
    <item>
      <title>GoLang相关的问题以及搜到的解决办法</title>
      <link>https://blog.riba2534.cn/blog/2019/golang%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%90%9C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Tue, 07 May 2019 22:11:55 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/golang%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%90%9C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>GoLang相关的问题以及搜到的解决办法 在使用 golang 的时候，会碰到很多问题，但是自己每一个问题都发个博客这样有点浪费，所以记载一下问题以及解决方法的链接。
golang 中反引号（tag）的作用  Tags in Golang Golang的Tag语法   </description>
    </item>
    
    <item>
      <title>使用 VSCode 编辑远程服务器文件</title>
      <link>https://blog.riba2534.cn/blog/2019/%E4%BD%BF%E7%94%A8-vscode-%E7%BC%96%E8%BE%91%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 29 Apr 2019 17:02:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E4%BD%BF%E7%94%A8-vscode-%E7%BC%96%E8%BE%91%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/</guid>
      <description>使用 VSCode 编辑远程服务器文件 在远程服务器上使用 vim 编辑文件一直觉得不太顺手，个人比较喜欢用 VSCode ，终于解决了使用 VSCode 编辑远程文件。
介绍两种方法：
 Remote VSCode 插件 SFTP 插件  Remote VSCode 安装 Remote VSCode 发现一款插件 Remote VSCode，可以实现这个功能
如图，好评数还是很多的。
  首先我们打开 Remote VSCode 这个插件的官方页面，点击安装即可，或者直接在 VSCode 中搜索这个插件。这个动作需要在本地进行。
  我们需要在远程服务器上安装 rmate 这个软件：
1 2  sudo wget -O /usr/local/bin/rmate https://raw.github.com/aurora/rmate/master/rmate sudo chmod a+x /usr/local/bin/rmate     使用   在本机的 VSCode 中按 F1 ,然后输入 Remote: Start server ,回车后启动服务
  按一下 Ctrl+~打开自带终端， 在 VSCode 的命令行中输入 ssh -R 52698:127.</description>
    </item>
    
    <item>
      <title>到目前为止的春招总结</title>
      <link>https://blog.riba2534.cn/blog/2019/%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E7%9A%84%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 22 Mar 2019 22:23:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E7%9A%84%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/</guid>
      <description>到目前为止的春招总结 大概是去年 11 月的时候，ACM 退役后开始决定找工作，方向是 c++，在牛客上搜了很多面经。发现找工作要学的东西太多了，所以就比较着急一度以为自己要凉了。然后就开始复习操作系统、计算机网络。网络编程相关东西。寒假刷了一本《剑指offer》和 LeetCode 感觉对找工作比较有用。
本来没想到这么快的，大概是过年后牛客开始有了20届名企直推专场，听到了金三银四的说法，然后就把能投的公司都投了，这时候在牛客讨论区找到了一个头条内推，然后第二天 hr 就要打电话要面试，我慌了，然后商量了一下把面试时间调到了一个月后。刚开始收到了吉比特的电话，然后把面试时间定到了开学后。然后即开始面试了，没想到吉比特只有一面技术面，然后就 hr 面，然后就收到了offer。然后依图给我打电话要一面，全程在写题，面试官也比较友好。然后过了一周二面三面，当天就发了 offer 。还有就是头条了，头条也是算法题居多。还有一些基础知识，感觉自己比较幸运，头条一面我回答的特别惨，然后面试官竟然让我二面，二面三面答得还比较行，手撕代码也出来了。
最后收获了三个offer，字节跳动，依图，吉比特。
顺便推广一波我的博客：https://blog.csdn.net/riba2534
部分面经在底下：
 吉比特游戏开发实习生一面面经 腾讯后台开发实习一面面经 头条实习后台开发一面二面面经 依图一面二面三面面经  最后，感谢牛客，如果没有牛客这个平台，可能真的不知道如何找工作。。
 顺便问下，哪里有头条的已经拿道暑期offer的群，可以拉我一下～</description>
    </item>
    
    <item>
      <title>依图一面二面三面面经</title>
      <link>https://blog.riba2534.cn/blog/2019/%E4%BE%9D%E5%9B%BE%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2%E4%B8%89%E9%9D%A2%E9%9D%A2%E7%BB%8F/</link>
      <pubDate>Tue, 19 Mar 2019 22:47:19 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E4%BE%9D%E5%9B%BE%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2%E4%B8%89%E9%9D%A2%E9%9D%A2%E7%BB%8F/</guid>
      <description>2019年03月19日 晚上突然收到 hr 电话要发offer，本来以为都凉了
感觉依图大部分都是算法题，一二面都写出来了，三面来了一个看起来很厉害的大佬，有自己的办公室，用后面的白板给我出了道物理题还是数学题让我做。
隔了两周了，问题忘得差不多了，把能记住的写下来。
一面  自我介绍 打一段自己熟悉的算法代码，并讲解 堆和栈的区别 手撕代码，两个有序数组中找第k大 手撕代码，一个矩阵填数的模拟题 剩下的好像问了一些网络和操作系统相关的，忘了，毕竟一周前了  二面  说一下什么是 I/O 复用 说一下select 和 epoll 写题，一个dfs,大意是有一个 n*m 的图，上下左右的值相差 1 可以连成一个块，让你输出一个新图，把每个块用0 1 2 3&amp;hellip;标记。 一个 1-n 的数组丢了 1 个数，找出来 一个 1-n 的数组丢了 2 个数，找出来 一个 1-n 的数组丢了 3 个数，找出来 还手撕了两个编程题，忘了是啥了 然后就谈人生，谈一下打比赛的经历  三面 看起来是个大佬，有自己独立办公室
 分析一下最小生成树复杂度。不是两个算法的复杂度，是最小生成树这个问题本身的复杂度 分析一下排序这个问题本身的复杂度（不是算法复杂度）  这俩题我都蒙了，不让我扯算法，让我说这个问题本身，我最后扯了扯决策树，然后大概就完了
还出了一道数学题
 光滑的长为 L 的轨道上，有 n 个无摩擦的小球，每个小球的速度的值一样，但是方向不一样（方向只有左右两个方向），给出每个小球的位置，以及每个小球的方向，问你最后一个小球离开轨道的时间是多少？  然后大概扯了扯其他的方面，聊一聊人生。</description>
    </item>
    
    <item>
      <title>LeetCode 76 最小覆盖子串(尺取法)</title>
      <link>https://blog.riba2534.cn/blog/2019/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%E5%B0%BA%E5%8F%96%E6%B3%95/</link>
      <pubDate>Sat, 16 Mar 2019 10:43:40 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%E5%B0%BA%E5%8F%96%E6%B3%95/</guid>
      <description>题目链接：最小覆盖子串
给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。
示例：
输入: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot;输出: &amp;quot;BANC&amp;quot;说明：
 如果 S 中不存这样的子串，则返回空字符串 &amp;quot;&amp;quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。  思路 (滑动窗口) $O(n)$ 首先用哈希表统计出 $T$ 中所有字符出现的次数。 然后我们用两个指针 $i, j(i \ge j)$来扫描整个字符串，同时用一个哈希表统计 $i, j$ 之间每种字符出现的次数，每次遍历需要的操作如下：
 加入 $s[i]$，同时更新哈希表； 检查 $s[j]$ 是否多余，如果是，则移除 $s[j]$； 检查当前窗口是否已经满足 $T​$ 中所有字符，如果是，则更新答案；  时间复杂度分析：两个指针都严格递增，最多移动 $n$ 次，所以总时间复杂度是 $O(n)$。
思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public: //s中最短的一段，包含t中的所有字符  string minWindow(string s, string t) { string res; unordered_map&amp;lt;char, int&amp;gt; S, T; int total = t.</description>
    </item>
    
    <item>
      <title>LeetCode 726 原子的数量(递归,map)</title>
      <link>https://blog.riba2534.cn/blog/2019/leetcode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F%E9%80%92%E5%BD%92map/</link>
      <pubDate>Sat, 16 Mar 2019 10:43:15 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/leetcode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F%E9%80%92%E5%BD%92map/</guid>
      <description>题目链接：原子的数量
给定一个化学式formula（作为字符串），返回每种原子的数量。
原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。
如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。
两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。
一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。
给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。
示例 1:
输入: formula = &amp;quot;H2O&amp;quot;输出: &amp;quot;H2O&amp;quot;解释: 原子的数量是 {&#39;H&#39;: 2, &#39;O&#39;: 1}。示例 2:
输入: formula = &amp;quot;Mg(OH)2&amp;quot;输出: &amp;quot;H2MgO2&amp;quot;解释: 原子的数量是 {&#39;H&#39;: 2, &#39;Mg&#39;: 1, &#39;O&#39;: 2}。示例 3:
输入: formula = &amp;quot;K4(ON(SO3)2)2&amp;quot;输出: &amp;quot;K4N2O14S4&amp;quot;解释: 原子的数量是 {&#39;K&#39;: 4, &#39;N&#39;: 2, &#39;O&#39;: 14, &#39;S&#39;: 4}。注意:</description>
    </item>
    
    <item>
      <title>头条实习后台开发一面二面面经</title>
      <link>https://blog.riba2534.cn/blog/2019/%E5%A4%B4%E6%9D%A1%E5%AE%9E%E4%B9%A0%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</link>
      <pubDate>Fri, 15 Mar 2019 09:28:06 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E5%A4%B4%E6%9D%A1%E5%AE%9E%E4%B9%A0%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</guid>
      <description>头条实习后台开发一面二面面经 2019年03月14日14:00 进行了头条后台开发的一二面，本来要三面的，面试官由于临时有事，联系 HR 改到了下周了。
下面的题目不分一面二面。基本流程就是先自我介绍，问你会啥，然后先问一些问题，然后写算法题。
网络和OS   TCP 的三次握手，为什么是三次，而不是两次
  超时重传，由谁来重传
  如果一直没有收到，服务端会怎么样
  select 和 epoll 的区别及分析
  进程 IPC 的方式有哪些，说一下你最熟悉的一个
  说一下锁机制
  当你在 Linux 的 bash 中按下 Ctrl+C 时，操作系统会做出什么反应，给操作系统发出的那个信号怎么拼写
  是硬中断和软中断（接上一题）
  进程和线程的区别
  数据结构和算法  全排列 给你一个化学式，比如：Mg2(H2O)2 其中各个元素的原子有几个，一个元素定义为一个大写字母或者一个大写字母跟着一个小写字母，比如给出的例子里面 Mg 有 2 个，H 有 4 个，O 有 2 个 给你一个数字 n 和 m，让你求出从 1 到 m 这些数字中字典序排列第 n 小的数字，然后我问 m 多大，他说 int64 范围内，然后我的脑子里就排除了排序和字典树的作法，然后去找规律。。。过了一会面试官问我啥思路，我说先排除排序和字典树的作法，应该找规律。然后他说为什么排除，我说了一下数据范围太大。然后面试官让我用字典树和排序的作法做 你都学过哪些高级数据结构  其他  你对 Python 了解多少 你了解 Http 吗 会 MySQL 吗 你平时怎么学习的 除了打比赛，还学了其他的吗 你想在实习中学到什么  </description>
    </item>
    
    <item>
      <title>腾讯后台开发实习一面面经</title>
      <link>https://blog.riba2534.cn/blog/2019/%E8%85%BE%E8%AE%AF%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</link>
      <pubDate>Wed, 13 Mar 2019 11:17:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E8%85%BE%E8%AE%AF%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</guid>
      <description>2019年03月12日下午四点收到腾讯面试官电话。
首先做了自我介绍，然后面试官往我邮箱发了一个题，让我在线编程。
然后过了大概十几分钟，我给出了一个 O(n) 的作法。
算法聊完后，面试官问了问关于网络和 C++ 的一些东西，然后我回答的很惨，下面是问题。
C++  创建一个 vector&amp;lt;int&amp;gt; ，里面存了5个元素 1 2 3 4 5，把迭代器指向 5，然后在 vector 的最前面插入一个 0 ，问刚才那个迭代器指向几  网络编程和OS  在 socket 编程中，服务端调用了 bind listen 但是没有调用 accept ，而是调用了 sleep(1000) ，然后客户端 调用 connect 向已经 sleep 的服务端发起请求，问这个 connect 会不会返回。我回答会醒过来，面试官继续问，如果醒过来后，服务端没有写 accept ，那么 connect 会不会返回。 connect 在 TCP 握手的哪个阶段会返回，是三次握手完成后还是在中间某个阶段返回 select 和 epoll 的异同点，epoll 为啥快。 面试官提出一个场景，创建一个 socket 并且加入到 epoll 中，现在把这个 socket 给 close 掉，那么这个被 close 的 socket 还在不在 epoll 中（没有主动调用 epoll_ctl 去删除），如果这时用 epoll_ctl 去删除它，还能不能删除掉。 有没有看过 epoll 的 man 手册 什么时候接触 Linux 的。 你如何了解一个新知识，如何学习  算法和数据结构  做题，略过 说一下贪心和动态规划的区别。 说一下红黑树，为什么在 STL 的实现中，用的是红黑树，而不是其他树。 B 树，跳表学过吗  其他  如果让你设计中国第三代身份证系统，说一下设计思路。 除了学习算法打比赛，你还学了些啥  </description>
    </item>
    
    <item>
      <title>POJ3249 Test for Job(拓扑排序，dp)</title>
      <link>https://blog.riba2534.cn/blog/2019/poj3249-test-for-job%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp/</link>
      <pubDate>Sun, 03 Mar 2019 20:57:03 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/poj3249-test-for-job%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp/</guid>
      <description>Description  Mr.Dog was fired by his company. In order to support his family, he must find a new job as soon as possible. Nowadays, It&amp;rsquo;s hard to have a job, since there are swelling numbers of the unemployed. So some companies often use hard tests for their recruitment.
The test is like this: starting from a source-city, you may pass through some directed roads to reach another city. Each time you reach a city, you can earn some profit or pay some fee, Let this process continue until you reach a target-city.</description>
    </item>
    
    <item>
      <title>POJ2796 Feel Good(单调栈)</title>
      <link>https://blog.riba2534.cn/blog/2019/poj2796-feel-good%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Sun, 03 Mar 2019 20:55:30 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/poj2796-feel-good%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>Description  Bill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent people&amp;rsquo;s memories about some period of life.
A new idea Bill has recently developed assigns a non-negative integer value to each day of human life.
Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it.</description>
    </item>
    
    <item>
      <title>2019年2月27日吉比特一面面经</title>
      <link>https://blog.riba2534.cn/blog/2019/2019%E5%B9%B42%E6%9C%8827%E6%97%A5%E5%90%89%E6%AF%94%E7%89%B9%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</link>
      <pubDate>Sat, 02 Mar 2019 16:49:25 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/2019%E5%B9%B42%E6%9C%8827%E6%97%A5%E5%90%89%E6%AF%94%E7%89%B9%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</guid>
      <description>吉比特面经 投的 游戏开发实习生
C++   static 和 const
  内存泄漏以及如何解决
  智能指针,unique_ptr 怎么实现的
  多态怎么体现（说了虚函数，提示还有函数重载）
  模板的特化和偏特化
  深拷贝和浅拷贝，从内存的角度
  C++11
  lamda 表达式
  操作系统  进程通信方法 死锁如何引起 网路编程理解到什么程度了 select 和 epoll 区别 水平触发和边缘触发   数据结构和算法  常用的排序及其复杂度 说一下归并排序 说一下堆建立过程及其复杂度 哈希函数冲突处理 红黑树比二叉查找树的优点 判断图的联通 最小生成树 介绍一下动态规划 文件去除重复行  闲话   看过什么书
  了解计算机哪些知识
  打比赛之外还干什么
  用过 lua 吗</description>
    </item>
    
    <item>
      <title>LeetCode 4. Median of Two Sorted Arrays(思路，递归)</title>
      <link>https://blog.riba2534.cn/blog/2019/leetcode-4.-median-of-two-sorted-arrays%E6%80%9D%E8%B7%AF%E9%80%92%E5%BD%92/</link>
      <pubDate>Sat, 02 Mar 2019 16:43:22 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/leetcode-4.-median-of-two-sorted-arrays%E6%80%9D%E8%B7%AF%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：寻找两个有序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:
nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:
nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5思路 (递归) $O(log(n + m))$ 原问题难以直接递归求解，所以我们先考虑这样一个问题：
 在两个有序数组中，找出第k大数。
 如果该问题可以解决，那么第 $(n + m) / 2$ 大数就是我们要求的中位数.
先从简单情况入手，假设 $m, n \geq k/2$，我们先从 $nums1$ 和 $nums2$ 中各取前 $k/2$ 个元素：</description>
    </item>
    
    <item>
      <title>LeetCode 440. K-th Smallest in Lexicographical Order(思路)</title>
      <link>https://blog.riba2534.cn/blog/2019/leetcode-440.-k-th-smallest-in-lexicographical-order%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 01 Mar 2019 09:03:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/leetcode-440.-k-th-smallest-in-lexicographical-order%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：440. K-th Smallest in Lexicographical Order
Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.
Note: 1 ≤ k ≤ n ≤ 109.
Example:
Input:n: 13 k: 2Output:10Explanation:The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.思路 题目的意思就是求从 1 到 n 中字典序为 k 的那个数.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 24 章 制作 HTTP 服务器端 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-24-%E7%AB%A0-%E5%88%B6%E4%BD%9C-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Feb 2019 20:16:48 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-24-%E7%AB%A0-%E5%88%B6%E4%BD%9C-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 24 章 制作 HTTP 服务器端 本章代码，在TCP-IP-NetworkNote中可以找到。
24.1 HTTP 概要 本章将编写 HTTP（HyperText Transfer Protocol，超文本传输协议）服务器端，即 Web 服务器端。
24.1.1 理解 Web 服务器端 web服务器端就是要基于 HTTP 协议，将网页对应文件传输给客户端的服务器端。
24.1.2 HTTP 无状态的 Stateless 协议
从上图可以看出，服务器端相应客户端请求后立即断开连接。换言之，服务器端不会维持客户端状态。即使同一客户端再次发送请求，服务器端也无法辨认出是原先那个，而会以相同方式处理新请求。因此，HTTP 又称「无状态的 Stateless 协议」
24.1.3 请求消息（Request Message）的结构 下面是客户端向服务端发起请求消息的结构：
从图中可以看出，请求消息可以分为请求头、消息头、消息体 3 个部分。其中，请求行含有请求方式（请求目的）信息。典型的请求方式有 GET 和 POST ，GET 主要用于请求数据，POST 主要用于传输数据。为了降低复杂度，我们实现只能响应 GET 请求的 Web 服务器端，下面解释图中的请求行信息。其中「GET/index.html HTTP/1.1」 具有如下含义：
 请求（GET）index.html 文件，通常以 1.1 版本的 HTTP 协议进行通信。
 请求行只能通过 1 行（line）发送，因此，服务器端很容易从 HTTP 请求中提取第一行，并分别分析请求行中的信息。
请求行下面的消息头中包含发送请求的浏览器信息、用户认证信息等关于 HTTP 消息的附加信息。最后的消息体中装有客户端向服务端传输的数据，为了装入数据，需要以 POST 方式发送请求。但是我们的目标是实现 GET 方式的服务器端，所以可以忽略这部分内容。另外，消息体和消息头与之间以空行隔开，因此不会发生边界问题</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 18 章 多线程服务器端的实现 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-18-%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 03 Feb 2019 16:05:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-18-%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 18 章 多线程服务器端的实现 本章代码，在TCP-IP-NetworkNote中可以找到。
18.1 理解线程的概念 18.1.1 引入线程背景 第 10 章介绍了多进程服务端的实现方法。多进程模型与 select 和 epoll 相比的确有自身的优点，但同时也有问题。如前所述，创建（复制）进程的工作本身会给操作系统带来相当沉重的负担。而且，每个进程都具有独立的内存空间，所以进程间通信的实现难度也会随之提高。换言之，多进程的缺点可概括为：
 创建进程的过程会带来一定的开销 为了完成进程间数据交换，需要特殊的 IPC 技术。  但是更大的缺点是下面的：
 每秒少则 10 次，多则千次的「上下文切换」是创建进程的最大开销  只有一个 CPU 的系统是将时间分成多个微小的块后分配给了多个进程。为了分时使用 CPU ，需要「上下文切换」的过程。「上下文切换」是指运行程序前需要将相应进程信息读入内存，如果运行进程 A 后紧接着需要运行进程 B ，就应该将进程 A 相关信息移出内存，并读入进程 B 相关信息。这就是上下文切换。但是此时进程 A 的数据将被移动到硬盘，所以上下文切换要很长时间，即使通过优化加快速度，也会存在一定的局限。
为了保持多进程的优点，同时在一定程度上克服其缺点，人们引入的线程（Thread）的概念。这是为了将进程的各种劣势降至最低程度（不是直接消除）而设立的一种「轻量级进程」。线程比进程具有如下优点：
 线程的创建和上下文切换比进程的创建和上下文切换更快 线程间交换数据无需特殊技术  18.1.2 线程和进程的差异 线程是为了解决：为了得到多条代码执行流而复制整个内存区域的负担太重。
每个进程的内存空间都由保存全局变量的「数据区」、向 malloc 等函数动态分配提供空间的堆（Heap）、函数运行时间使用的栈（Stack）构成。每个进程都有独立的这种空间，多个进程的内存结构如图所示：
但如果以获得多个代码执行流为目的，则不应该像上图那样完全分离内存结构，而只需分离栈区域。通过这种方式可以获得如下优势：
 上下文切换时不需要切换数据区和堆 可以利用数据区和堆交换数据  实际上这就是线程。线程为了保持多条代码执行流而隔开了栈区域，因此具有如下图所示的内存结构：
如图所示，多个线程共享数据区和堆。为了保持这种结构，线程将在进程内创建并运行。也就是说，进程和线程可以定义为如下形式：
 进程：在操作系统构成单独执行流的单位 线程：在进程构成单独执行流的单位  如果说进程在操作系统内部生成多个执行流，那么线程就在同一进程内部创建多条执行流。因此，操作系统、进程、线程之间的关系可以表示为下图：
18.2 线程创建及运行 可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 17 章 优于 select 的 epoll 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-17-%E7%AB%A0-%E4%BC%98%E4%BA%8E-select-%E7%9A%84-epoll-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 01 Feb 2019 19:06:05 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-17-%E7%AB%A0-%E4%BC%98%E4%BA%8E-select-%E7%9A%84-epoll-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 17 章 优于 select 的 epoll 本章代码，在TCP-IP-NetworkNote中可以找到。
17.1 epoll 理解及应用 select 复用方法由来已久，因此，利用该技术后，无论如何优化程序性能也无法同时介入上百个客户端。这种 select 方式并不适合以 web 服务器端开发为主流的现代开发环境，所以需要学习 Linux 环境下的 epoll
17.1.1 基于 select 的 I/O 复用技术速度慢的原因 第 12 章实现了基于 select 的 I/O 复用技术服务端，其中有不合理的设计如下：
 调用 select 函数后常见的针对所有文件描述符的循环语句 每次调用 select 函数时都需要向该函数传递监视对象信息  上述两点可以从 echo_selectserv.c 得到确认，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54,56行），因此无法避免针对所有监视对象的循环语句。而且，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息。
select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。select 函数的这一缺点可以通过如下方式弥补：
 仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项
 这样就无需每次调用 select 函数时都想操作系统传递监视对象信息，但是前提操作系统支持这种处理方式。Linux 的支持方式是 epoll ，Windows 的支持方式是 IOCP。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 16 章 关于 I/O 流分离的其他内容 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-16-%E7%AB%A0-%E5%85%B3%E4%BA%8E-i-o-%E6%B5%81%E5%88%86%E7%A6%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 30 Jan 2019 14:38:38 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-16-%E7%AB%A0-%E5%85%B3%E4%BA%8E-i-o-%E6%B5%81%E5%88%86%E7%A6%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 16 章 关于 I/O 流分离的其他内容 本章代码，在TCP-IP-NetworkNote中可以找到。
16.1 分离 I/O 流 「分离 I/O 流」是一种常用表达。有 I/O 工具可区分二者，无论采用哪种方法，都可以认为是分离了 I/O 流。
16.1.1 2次 I/O 流分离 之前有两种分离方法：
 第一种是第 10 章的「TCP I/O 过程」分离。通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符。虽然文件描述符本身不会根据输入和输出进行区分，但我们分开了 2 个文件描述符的用途，因此，这也属于「流」的分离。 第二种分离是在第 15 章。通过 2 次 fdopen 函数的调用，创建读模式 FILE 指针（FILE 结构体指针）和写模式 FILE 指针。换言之，我们分离了输入工具和输出工具，因此也可视为「流」的分离。下面是分离的理由。  16.1.2 分离「流」的好处 首先是第 10 章「流」的分离目的：
 通过分开输入过程（代码）和输出过程降低实现难度 与输入无关的输出操作可以提高速度  下面是第 15 章「流」分离的目的：
 为了将 FILE 指针按读模式和写模式加以区分 可以通过区分读写模式降低实现难度 通过区分 I/O 缓冲提高缓冲性能  16.1.3 「流」分离带来的 EOF 问题 第 7 章介绍过 EOF 的传递方法和半关闭的必要性。有一个语句：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 15 章 套接字和标准I/O 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-15-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%A0%87%E5%87%86i-o-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 29 Jan 2019 17:53:25 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-15-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%A0%87%E5%87%86i-o-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 15 章 套接字和标准I/O 本章代码，在TCP-IP-NetworkNote中可以找到。
15.1 标准 I/O 的优点 15.1.1 标准 I/O 函数的两个优点 下面是标准 I/O 函数的两个优点：
 标准 I/O 函数具有良好的移植性 标准 I/O 函数可以利用缓冲提高性能  创建套接字时，操作系统会准备 I/O 缓冲。此缓冲在执行 TCP 协议时发挥着非常重要的作用。此时若使用标准 I/O 函数，将得到额外的缓冲支持。如下图：
假设使用 fputs 函数进行传输字符串 「Hello」时，首先将数据传递到标准 I/O 缓冲，然后将数据移动到套接字输出缓冲，最后将字符串发送到对方主机。
设置缓冲的主要目的是为了提高性能。从以下两点可以说明性能的提高：
 传输的数据量 数据向输出缓冲移动的次数。  比较 1 个字节的数据发送 10 次的情况和 10 个数据包发送 1 次的情况。发送数据时，数据包中含有头信息。头信与数据大小无关，是按照一定的格式填入的。假设头信息占 40 个字节，需要传输的数据量也存在较大区别：
 1 个字节 10 次：40*10=400 字节 10个字节 1 次：40*1=40 字节。  15.1.2 标准 I/O 函数和系统函数之间的性能对比 下面是利用系统函数的示例：
 syscpy.</description>
    </item>
    
    <item>
      <title>HihoCoder - 1044 状态压缩一 (状压dp)</title>
      <link>https://blog.riba2534.cn/blog/2019/hihocoder-1044-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%B8%80-%E7%8A%B6%E5%8E%8Bdp/</link>
      <pubDate>Tue, 29 Jan 2019 16:07:37 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/hihocoder-1044-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%B8%80-%E7%8A%B6%E5%8E%8Bdp/</guid>
      <description>描述  小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即将举行美食节！
但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。
不仅如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。
小Hi和小Ho本着礼让他们的心情——当然还因为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。
将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多的清扫垃圾。
小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可能多的垃圾。
提示一：无论是什么动态规划，都需要一个状态转移方程！
提示二：好像什么不对劲？状态压缩哪里去了？
 输入  每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。
每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。
对于100%的数据，满足N&amp;lt;=1000, 2&amp;lt;=M&amp;lt;=10,1&amp;lt;=Q&amp;lt;=M, Wi&amp;lt;=100
 输出  对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。
 样例输入 5 2 136 9 80 69 85 样例输出 201思路 题意是给出有 $n$ 个数的数组，每一个位置有一个权值 $w[i]$ ，现在你需要选择一些位置，使得取得的权值和最大。
选择位置的条件是：对于任意长度为 $m$ 的区间，选择的位置的数量必须小于等于 $q$ 个。
思路是状态压缩。因为 $m$ 的范围是 $10$ ,那么用二进制的思想，二进制为 $1$ 表示当前位置被选择，为 $0$ 表示没有被选择，那么一共需要 $m$ 个二进制位来表示状态，那么压缩成十进制，就需要 $2^m-1$ 个状态来表示。
定义：
 $dp[i][j]$ 表示前 $i$ 个位置，选择的状态为 $j$ 时所能达到的最大价值。 $j$ 表示的状态是，以第 $i$ 个位置为结尾的连续 $m$ 个位置的选取状态。  举个例子，假设当 $m=3$ 时，所有的状态为：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 14 章 多播与广播 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-14-%E7%AB%A0-%E5%A4%9A%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 28 Jan 2019 13:54:59 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-14-%E7%AB%A0-%E5%A4%9A%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 14 章 多播与广播 本章代码，在TCP-IP-NetworkNote中可以找到。
14.1 多播 多播（Multicast）方式的数据传输是基于 UDP 完成的。因此 ，与 UDP 服务器端/客户端的实现方式非常接近。区别在于，UDP 数据传输以单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，可以同时向多个主机传递数据。
14.1.1 多播的数据传输方式以及流量方面的优点 多播的数据传输特点可整理如下：
 多播服务器端针对特定多播组，只发送 1 次数据。 即使只发送 1 次数据，但该组内的所有客户端都会接收数据 多播组数可以在 IP 地址范围内任意增加  多播组是 D 类IP地址（224.0.0.0~239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明：
 在 D 类IP地址中，我希望接收发往目标 239.234.218.234 的多播数据
 多播是基于 UDP 完成的，也就是说，多播数据包的格式与 UDP 数据包相同。只是与一般的 UDP 数据包不同。向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如图所示：
若通过 TCP 或 UDP 向 1000 个主机发送文件，则共需要传递 1000 次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由 1000 台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。
另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。
14.1.2 路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法 为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 13 章 多种 I/O 函数 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-13-%E7%AB%A0-%E5%A4%9A%E7%A7%8D-i-o-%E5%87%BD%E6%95%B0-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 26 Jan 2019 23:08:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-13-%E7%AB%A0-%E5%A4%9A%E7%A7%8D-i-o-%E5%87%BD%E6%95%B0-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 13 章 多种 I/O 函数 本章代码，在TCP-IP-NetworkNote中可以找到。
13.1 send &amp;amp; recv 函数 13.1.1 Linux 中的 send &amp;amp; recv 首先看 sned 函数定义：
1 2 3 4 5 6 7 8 9  #include &amp;lt;sys/socket.h&amp;gt;ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags); /* 成功时返回发送的字节数，失败时返回 -1 sockfd: 表示与数据传输对象的连接的套接字和文件描述符 buf: 保存带传输数据的缓冲地址值 nbytes: 待传输字节数 flags: 传输数据时指定的可选项信息 */   下面是 recv 函数的定义：
1 2 3 4 5 6 7 8 9  #include &amp;lt;sys/socket.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 12 章 I/O 复用 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-12-%E7%AB%A0-i-o-%E5%A4%8D%E7%94%A8-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 23 Jan 2019 17:38:29 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-12-%E7%AB%A0-i-o-%E5%A4%8D%E7%94%A8-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 12 章 I/O 复用 本章代码，在TCP-IP-NetworkNote中可以找到。
12.1 基于 I/O 复用的服务器端 12.1.1 多进程服务端的缺点和解决方法 为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程要付出很大的代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法）
I/O 复用技术可以解决这个问题。
12.1.2 理解复用 「复用」在电子及通信工程领域很常见，向这些领域的专家询问其概念，可能会得到如下答复：
 在 1 个通信频道中传递多个数据（信号）的技术
 「复用」的含义：
 为了提高物理设备的效率，只用最少的物理要素传递最多数据时使用的技术
 上述两种方法的内容完全一致。可以用纸电话模型做一个类比：
上图是一个纸杯电话系统，为了使得三人同时通话，说话时要同事对着两个纸杯，接听时也需要耳朵同时对准两个纸杯。为了完成 3 人通话，可以进行如下图的改进：
如图做出改进，就是引入了复用技术。
复用技术的优点：
 减少连线长度 减少纸杯个数  即使减少了连线和纸杯的量仍然可以进行三人同时说话，但是如果碰到以下情况：
 「好像不能同时说话？」
 实际上，因为是在进行对话，所以很少发生同时说话的情况。也就是说，上述系统采用的是**「时分复用」**技术。因为说话人声频率不同，即使在同时说话也能进行一定程度上的区分（杂音也随之增多）。因此，也可以说是「频分复用技术」。
12.1.3 复用技术在服务器端的应用 纸杯电话系统引入复用技术之后可以减少纸杯数量和连线长度。服务器端引入复用技术可以减少所需进程数。下图是多进程服务端的模型：
下图是引入复用技术之后的模型：
从图上可以看出，引入复用技术之后，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有一个。
12.2 理解 select 函数并实现服务端 select 函数是最具代表性的实现复用服务器的方法。在 Windows 平台下也有同名函数，所以具有很好的移植性。
12.2.1 select 函数的功能和调用顺序 使用 select 函数时可以将多个文件描述符集中到一起统一监视，项目如下：
 是否存在套接字接收数据？ 无需阻塞传输数据的套接字有哪些？ 哪些套接字发生了异常？   术语：「事件」。当发生监视项对应情况时，称「发生了事件」。
 select 函数的使用方法与一般函数的区别并不大，更准确的说，他很难使用。但是为了实现 I/O 复用服务器端，我们应该掌握 select 函数，并运用于套接字编程当中。认为「select 函数是 I/O 复用的全部内容」也并不为过。select 函数的调用过程如下图所示：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 11 章 进程间通信 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-11-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 22 Jan 2019 11:40:18 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-11-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 11 章 进程间通信 本章代码，在TCP-IP-NetworkNote中可以找到。
进程间通信，意味着两个不同的进程中可以交换数据
11.1 进程间通信的基本概念 11.1.1 通过管道实现进程间通信 下图是基于管道（PIPE）的进程间通信的模型：
可以看出，为了完成进程间通信，需要创建进程。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是 fork 函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。下面是创建管道的函数。
1 2 3 4 5 6 7  #include &amp;lt;unistd.h&amp;gt;int pipe(int filedes[2]); /* 成功时返回 0 ，失败时返回 -1 filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口 filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口 */   父进程创建函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。下面的例子是关于该函数的使用方法：
 pipe1.c  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 10 章 多进程服务器端 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-10-%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 21 Jan 2019 15:59:25 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-10-%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 10 章 多进程服务器端 本章代码，在TCP-IP-NetworkNote中可以找到。
10.1 进程概念及应用 10.1.1 并发服务端的实现方法 通过改进服务端，使其同时向所有发起请求的客户端提供服务，以提高平均满意度。而且，网络程序中数据通信时间比 CPU 运算时间占比更大，因此，向多个客户端提供服务是一种有效的利用 CPU 的方式。接下来讨论同时向多个客户端提供服务的并发服务器端。下面列出的是具有代表性的并发服务端的实现模型和方法：
 多进程服务器：通过创建多个进程提供服务 多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务 多线程服务器：通过生成与客户端等量的线程提供服务  先是第一种方法：多进程服务器
10.1.2 理解进程 进程的定义如下：
 占用内存空间的正在运行的程序
 假如你下载了一个游戏到电脑上，此时的游戏不是进程，而是程序。只有当游戏被加载到主内存并进入运行状态，这是才可称为进程。
10.1.3 进程 ID 在说进程创建方法之前，先要简要说明进程 ID。无论进程是如何创建的，所有的进程都会被操作系统分配一个 ID。此 ID 被称为「进程ID」，其值为大于 2 的证书。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。
1  ps au   通过上面的命令可查看当前运行的所有进程。需要注意的是，该命令同时列出了 PID（进程ID）。参数 a 和 u列出了所有进程的详细信息。
10.1.4 通过调用 fork 函数创建进程 创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。
1 2 3  #include &amp;lt;unistd.h&amp;gt;pid_t fork(void); // 成功时返回进程ID,失败时返回 -1   fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都执行 fork 函数调用后的语句（准确的说是在 fork 函数返回后）。但因为是通过同一个进程、复制相同的内存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特点区分程序执行流程。</description>
    </item>
    
    <item>
      <title>牛客网-拼多多2018笔试 迷宫寻路(状态压缩&#43;bfs)</title>
      <link>https://blog.riba2534.cn/blog/2019/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%8B%BC%E5%A4%9A%E5%A4%9A2018%E7%AC%94%E8%AF%95-%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9bfs/</link>
      <pubDate>Sat, 19 Jan 2019 20:17:59 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%8B%BC%E5%A4%9A%E5%A4%9A2018%E7%AC%94%E8%AF%95-%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9bfs/</guid>
      <description>题目来源：迷宫寻路
题目描述  假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是路。迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。请设计一个算法，帮助探险家找到脱困的最短路径。如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下 0-墙，1-路，2-探险家的起始位置，3-迷宫的出口，大写字母-门，小写字母-对应大写字母所代表的门的钥匙
 输入描述:  迷宫的地图，用二维矩阵表示。第一行是表示矩阵的行数和列数M和N 后面的M行是矩阵的数据，每一行对应与矩阵的一行（中间没有空格）。M和N都不超过100, 门不超过10扇。
 输出描述:  路径的长度，是一个整数
 输入 5 50211101a0A010030100101111输出 7思路 简单状压，利用10个二进制位，遇到一个门，检查一下能不能开门，不能开门就不能走。遇到钥匙的时候用位运算「或」把这个状态添加进去，bfs 搜出来的就是结果。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 9 章 套接字的多种可选项 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-9-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Jan 2019 17:37:05 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-9-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 9 章 套接字的多种可选项 本章代码，在TCP-IP-NetworkNote中可以找到。
9.1 套接字可选项和 I/O 缓冲大小 我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也很重要
9.1.1 套接字多种可选项 我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。
   协议层 选项名 读取 设置     SOL_SOCKET SO_SNDBUF O O   SOL_SOCKET SO_RCVBUF O O   SOL_SOCKET SO_REUSEADDR O O   SOL_SOCKET SO_KEEPALIVE O O   SOL_SOCKET SO_BROADCAST O O   SOL_SOCKET SO_DONTROUTE O O   SOL_SOCKET SO_OOBINLINE O O   SOL_SOCKET SO_ERROR O X   SOL_SOCKET SO_TYPE O X   IPPROTO_IP IP_TOS O O   IPPROTO_IP IP_TTL O O   IPPROTO_IP IP_MULTICAST_TTL O O   IPPROTO_IP IP_MULTICAST_LOOP O O   IPPROTO_IP IP_MULTICAST_IF O O   IPPROTO_TCP TCP_KEEPALIVE O O   IPPROTO_TCP TCP_NODELAY O O   IPPROTO_TCP TCP_MAXSEG O O    从表中可以看出，套接字可选项是分层的。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 8 章 域名及网络地址 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-8-%E7%AB%A0-%E5%9F%9F%E5%90%8D%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 18 Jan 2019 18:09:27 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-8-%E7%AB%A0-%E5%9F%9F%E5%90%8D%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 8 章 域名及网络地址 本章代码，在TCP-IP-NetworkNote中可以找到。
8.1 域名系统 DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器
8.1.1 什么是域名 域名就是我们常常在地址栏里面输入的地址，将比较难记忆的IP地址变成人类容易理解的信息。
8.1.2 DNS 服务器 相当于一个字典，可以查询出某一个域名对应的IP地址
如图所示，显示了 DNS 服务器的查询路径。
8.2 IP地址和域名之间的转换 8.2.1 程序中有必要使用域名吗？ 一句话，需要，因为IP地址可能经常改变，而且也不容易记忆，通过域名可以随时更改解析，达到更换IP的目的
8.2.2 利用域名获取IP地址 使用以下函数可以通过传递字符串格式的域名获取IP地址
1 2 3 4 5  #include &amp;lt;netdb.h&amp;gt;struct hostent *gethostbyname(const char *hostname); /* 成功时返回 hostent 结构体地址，失败时返回 NULL 指针 */   这个函数使用方便，只要传递字符串，就可以返回域名对应的IP地址。只是返回时，地址信息装入 hostent 结构体。此结构体的定义如下：
1 2 3 4 5 6 7 8  struct hostent { char *h_name; /* Official name of host.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 7 章 优雅的断开套接字的连接 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-7-%E7%AB%A0-%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%AD%E5%BC%80%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 18 Jan 2019 11:25:41 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-7-%E7%AB%A0-%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%AD%E5%BC%80%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 7 章 优雅的断开套接字的连接 本章代码，在TCP-IP-NetworkNote中可以找到。
本章讨论如何优雅的断开套接字的连接，之前用的方法不够优雅是因为，我们是调用 close 函数或 closesocket 函数单方面断开连接的。
7.1 基于 TCP 的半关闭 TCP 的断开连接过程比建立连接更重要，因为连接过程中一般不会出现大问题，但是断开过程可能发生预想不到的情况。因此应该准确掌控。所以要掌握半关闭（Half-close），才能明确断开过程。
7.1.1 单方面断开连接带来的问题 Linux 和 Windows 的 closesocket 函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。因此在某些情况下，通信一方单方面的断开套接字连接，显得不太优雅。如图所示：
图中描述的是 2 台主机正在进行双向通信，主机 A 发送完最后的数据后，调用 close 函数断开了最后的连接，之后主机 A 无法再接受主机 B 传输的数据。实际上，是完全无法调用与接受数据相关的函数。最终，由主机 B 传输的、主机 A 必须要接受的数据也销毁了。
为了解决这类问题，「只关闭一部分数据交换中使用的流」的方法应运而生。断开一部分连接是指，可以传输数据但是无法接收，或可以接受数据但无法传输。顾名思义就是只关闭流的一半。
7.1.2 套接字和流（Stream） 两台主机通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看作一种流。
此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也止呕能向一个方向流动。因此，为了进行双向通信，需要如图所示的两个流：
一旦两台主机之间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一个主机的输出流相连，而输出流则与另一个主机的输入流相连。另外，本章讨论的「优雅的断开连接方式」只断开其中 1 个流，而非同时断开两个流。Linux 和 Windows 的 closesocket 函数将同时断开这两个流，因此与「优雅」二字还有一段距离。
7.1.3 针对优雅断开的 shutdown 函数 shutdown 用来关闭其中一个流：
1 2 3 4 5 6 7  #include &amp;lt;sys/socket.h&amp;gt;int shutdown(int sock, int howto); /* 成功时返回 0 ，失败时返回 -1 sock: 需要断开套接字文件描述符 howto: 传递断开方式信息 */   调用上述函数时，第二个参数决定断开连接的方式，其值如下所示：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 6 章 基于 UDP 的服务端/客户端 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-6-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 17 Jan 2019 16:10:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-6-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 6 章 基于 UDP 的服务端/客户端 本章代码，在TCP-IP-NetworkNote中可以找到。
TCP 是内容较多的一个协议，而本章中的 UDP 内容较少，但是也很重要。
6.1 理解 UDP 6.1.1 UDP 套接字的特点 通过寄信来说明 UDP 的工作原理，这是讲解 UDP 时使用的传统示例，它与 UDP 的特点完全相同。寄信前应现在信封上填好寄信人和收信人的地址，之后贴上邮票放进邮筒即可。当然，信件的特点使我们无法确认信件是否被收到。邮寄过程中也可能发生信件丢失的情况。也就是说，信件是一种不可靠的传输方式，UDP 也是一种不可靠的数据传输方式。
因为 UDP 没有 TCP 那么复杂，所以编程难度比较小，性能也比 TCP 高。在更重视性能的情况下可以选择 UDP 的传输方式。
TCP 与 UDP 的区别很大一部分来源于流控制。也就是说 TCP 的生命在于流控制。
6.1.2 UDP 的工作原理 如图所示：
从图中可以看出，IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。
6.1.3 UDP 的高效使用 UDP 也具有一定的可靠性。对于通过网络实时传递的视频或者音频时情况有所不同。对于多媒体数据而言，丢失一部分数据也没有太大问题，这只是会暂时引起画面抖动，或者出现细微的杂音。但是要提供实时服务，速度就成为了一个很重要的因素。因此流控制就显得有一点多余，这时就要考虑使用 UDP 。TCP 比 UDP 慢的原因主要有以下两点：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 5 章 基于 TCP 的服务端/客户端（2） 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-5-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF2-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 16 Jan 2019 15:57:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-5-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF2-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 5 章 基于 TCP 的服务端/客户端（2） 本章代码，在TCP-IP-NetworkNote中可以找到。
上一章仅仅是从编程角度学习实现方法，并未详细讨论 TCP 的工作原理。因此，本章将想次讲解 TCP 中必要的理论知识，还将给出第 4 章客户端问题的解决方案。
5.1 回声客户端的完美实现 5.1.1 回声服务器没有问题，只有回声客户端有问题？ 问题不在服务器端，而在客户端，只看代码可能不好理解，因为 I/O 中使用了相同的函数。先回顾一下服务器端的 I/O 相关代码：
1 2  while ((str_len = read(clnt_sock, message, BUF_SIZE)) != 0) write(clnt_sock, message, str_len);   接着是客户端代码:
1 2  write(sock, message, strlen(message)); str_len = read(sock, message, BUF_SIZE - 1);   二者都在村换调用 read 和 write 函数。实际上之前的回声客户端将 100% 接受字节传输的数据，只不过接受数据时的单位有些问题。扩展客户端代码回顾范围，下面是，客户端的代码:
1 2 3 4 5 6 7 8 9 10 11 12 13  while (1) { fputs(&amp;#34;Input message(Q to quit): &amp;#34;, stdout); fgets(message, BUF_SIZE, stdin); if (!</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 4 章 基于 TCP 的服务端/客户端（1） 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-4-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF1-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 15 Jan 2019 13:10:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-4-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF1-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 4 章 基于 TCP 的服务端/客户端（1） 本章代码，在TCP-IP-NetworkNote中可以找到。
4.1 理解 TCP 和 UDP 根据数据传输方式的不同，基于网络协议的套接字一般分为 TCP 套接字和 UDP 套接字。因为 TCP 套接字是面向连接的，因此又被称为基于流（stream）的套接字。
TCP 是 Transmission Control Protocol （传输控制协议）的简写，意为「对数据传输过程的控制」。因此，学习控制方法及范围有助于正确理解 TCP 套接字。
4.1.1 TCP/IP 协议栈 TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题
4.1.2 链路层 链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准。
4.1.3 IP 层 转备好物理连接候就要传输数据。为了再复杂网络中传输数据，首先要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP。
IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。
4.1.4 TCP/UDP 层 IP 层解决数据传输中的路径选择问题，秩序照此路径传输数据即可。TCP 和 UDP 层以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称为传输层。UDP 比 TCP 简单，现在我们只解释 TCP 。 TCP 可以保证数据的可靠传输，但是它发送数据时以 IP 层为基础（这也是协议栈层次化的原因）
IP 层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中可能只收到A和C，甚至收到的C可能已经损毁 。反之，若添加 TCP 协议则按照如下对话方式进行数据交换。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 3 章 网络地址的初始化与分配 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-3-%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%88%86%E9%85%8D-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 14 Jan 2019 13:13:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-3-%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%88%86%E9%85%8D-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 3 章 地址族与数据序列 本章代码，在TCP-IP-NetworkNote中可以找到。
把套接字比喻成电话，那么目前只安装了电话机，本章讲解给电话机分配号码的方法，即给套接字分配 IP 地址和端口号。
3.1 分配给套接字的 IP 地址与端口号 IP 是 Internet Protocol（网络协议）的简写，是为手法网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为了区分程序中创建的套接字而分配给套接字的端口号。
3.1.1 网络地址（Internet Address） 为使计算机连接到网络并收发数据，必须为其分配 IP 地址。IP 地址分为两类。
 IPV4（Internet Protocol version 4）4 字节地址族 IPV6（Internet Protocol version 6）6 字节地址族  两者之间的主要差别是 IP 地址所用的字节数，目前通用的是 IPV4 , IPV6 的普及还需要时间。
IPV4 标准的 4 字节 IP 地址分为网络地址和主机（指计算机）地址，且分为 A、B、C、D、E 等类型。
数据传输过程：
某主机向 203.211.172.103 和 203.211.217.202 传递数据，其中 203.211.172 和 203.211.217 为该网络的网络地址，所以「向相应网络传输数据」实际上是向构成网络的路由器或者交换机传输数据，然后又路由器或者交换机根据数据中的主机地址向目标主机传递数据。
3.1.2 网络地址分类与主机地址边界 只需通过IP地址的第一个字节即可判断网络地址占用的总字节数，因为我们根据IP地址的边界区分网络地址，如下所示：
 A 类地址的首字节范围为：0~127 B 类地址的首字节范围为：128~191 C 类地址的首字节范围为：192~223  还有如下这种表示方式：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 2 章 套接字类型与协议设置 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-2-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 13 Jan 2019 11:15:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-2-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE-%E7%AC%94%E8%AE%B0/</guid>
      <description>第二章 套接字类型与协议设置 本章代码，在TCP-IP-NetworkNote中可以找到，直接点连接可能进不去。
本章仅需了解创建套接字时调用的 socket 函数。
2.1 套接字协议及数据传输特性 2.1.1 创建套接字 1 2 3 4 5 6 7 8  #include &amp;lt;sys/socket.h&amp;gt;int socket(int domain, int type, int protocol); /* 成功时返回文件描述符，失败时返回-1 domain: 套接字中使用的协议族（Protocol Family） type: 套接字数据传输的类型信息 protocol: 计算机间通信中使用的协议信息 */   2.1.2 协议族（Protocol Family） 通过 socket 函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，可分成如下几类：
 头文件 sys/socket.h 中声明的协议族
    名称 协议族     PF_INET IPV4 互联网协议族   PF_INET6 IPV6 互联网协议族   PF_LOCAL 本地通信 Unix 协议族   PF_PACKET 底层套接字的协议族   PF_IPX IPX Novel 协议族    本书着重讲 PF_INET 对应的 IPV4 互联网协议族。其他协议并不常用，或并未普及。另外，套接字中采用的最终的协议信息是通过 socket 函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 1 章 理解网络编程和套接字 笔记</title>
      <link>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-1-%E7%AB%A0-%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 12 Jan 2019 13:12:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-1-%E7%AB%A0-%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97-%E7%AC%94%E8%AE%B0/</guid>
      <description>第一章：理解网络编程和套接字 本章代码，在TCP-IP-NetworkNote中可以找到。
1.1 理解网络编程和套接字 1.1.1构建打电话套接字 以电话机打电话的方式来理解套接字。
调用 socket 函数（安装电话机）时进行的对话：
 问：接电话需要准备什么？
答：当然是电话机。
 有了电话机才能安装电话，于是就要准备一个电话机，下面函数相当于电话机的套接字。
1 2 3  #include &amp;lt;sys/socket.h&amp;gt;int socket(int domain, int type, int protocol); //成功时返回文件描述符，失败时返回-1   调用 bind 函数（分配电话号码）时进行的对话：
 问：请问我的电话号码是多少
答：我的电话号码是123-1234
 套接字同样如此。就想给电话机分配电话号码一样，利用以下函数给创建好的套接字分配地址信息（IP地址和端口号）：
1 2 3  #include &amp;lt;sys/socket.h&amp;gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen); //成功时返回0，失败时返回-1   调用 bind 函数给套接字分配地址之后，就基本完成了所有的准备工作。接下来是需要连接电话线并等待来电。
调用 listen 函数（连接电话线）时进行的对话：
 问：已架设完电话机后是否只需链接电话线？
答：对，只需要连接就能接听电话。
 一连接电话线，电话机就可以转换为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接受连接状态。
1 2 3  #include &amp;lt;sys/socket.h&amp;gt;int listen(int sockfd, int backlog); //成功时返回0，失败时返回-1   连接好电话线以后，如果有人拨打电话就响铃，拿起话筒才能接听电话。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11：左值引用与右值引用</title>
      <link>https://blog.riba2534.cn/blog/2019/cpp11%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</link>
      <pubDate>Tue, 01 Jan 2019 20:07:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2019/cpp11%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</guid>
      <description>C++11：左值引用与右值引用 在 C++11 的新标准中，出现了「右值引用」的说法，既然有了右值引用，那么传统的引用也就叫做左值引用。
右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。它的主要目的有两个方面：
 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。  左值与右值的定义 C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。通俗的左值的定义就是非临时对象，那些可以在多条语句中使用的对象。所有的变量都满足这个定义，在多条代码中都可以使用，都是左值。右值是指临时的对象，它们只在当前的语句中有效。请看下列示例 :
  简单的赋值语句
如：int i = 0;
在这条语句中，i 是左值，0 是临时值，就是右值。在下面的代码中，i 可以被引用，0 就不可以了。立即数都是右值。
  右值也可以出现在赋值表达式的左边，但是不能作为赋值的对象，因为右值只在当前语句有效，赋值没有意义。
如：((i&amp;gt;0) ? i : j) = 1;
在这个例子中，0 作为右值出现在了”=”的左边。但是赋值对象是 i 或者 j，都是左值。
在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用绑定一个右值，如 :
const int &amp;amp;a = 1;</description>
    </item>
    
    <item>
      <title>Good Bye 2018 C. New Year and the Sphere Transmission(数学)</title>
      <link>https://blog.riba2534.cn/blog/2018/good-bye-2018-c.-new-year-and-the-sphere-transmission%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Mon, 31 Dec 2018 16:41:02 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/good-bye-2018-c.-new-year-and-the-sphere-transmission%E6%95%B0%E5%AD%A6/</guid>
      <description>题目链接：C. New Year and the Sphere Transmission
 There are $n$ people sitting in a circle, numbered from $1$ to $n$ in the order in which they are seated. That is, for all $i$ from $1$ to $n-1$, the people with id $i$ and $i+1$ are adjacent. People with id $n$ and $1$ are adjacent as well.
The person with id $1$ initially has a ball. He picks a positive integer $k$ at most $n$, and passes the ball to his $k$-th neighbour in the direction of increasing ids, that person passes the ball to his $k$-th neighbour in the same direction, and so on until the person with the id $1$ gets the ball back.</description>
    </item>
    
    <item>
      <title> 牛客网-网易2017笔试 合唱团(dp)</title>
      <link>https://blog.riba2534.cn/blog/2018/-%E7%89%9B%E5%AE%A2%E7%BD%91-%E7%BD%91%E6%98%932017%E7%AC%94%E8%AF%95-%E5%90%88%E5%94%B1%E5%9B%A2dp/</link>
      <pubDate>Sun, 30 Dec 2018 16:16:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/-%E7%89%9B%E5%AE%A2%E7%BD%91-%E7%BD%91%E6%98%932017%E7%AC%94%E8%AF%95-%E5%90%88%E5%94%B1%E5%9B%A2dp/</guid>
      <description>题目来源:合唱团
题目描述  有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？
 输入描述:  每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &amp;lt;= n &amp;lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &amp;lt;= ai &amp;lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &amp;lt;= k &amp;lt;= 10, 1 &amp;lt;= d &amp;lt;= 50)。
 输出描述:  输出一行表示最大的乘积。
 输入 37 4 72 50输出 49思路 给出 n 个数字，要求按顺序选择 k 个，使得选出的数的乘积最大。且要求选择的相邻两个人的距离必须小于等于 d.
定义 dp[n][k] 为以位置为 n 的人为结尾（位置为 n 的人就是选择的第k个人），选择 k 个人(包括自己)所能获得的最大乘积</description>
    </item>
    
    <item>
      <title>Ubuntu&#43;Apache2配置腾讯云ssl证书实现https</title>
      <link>https://blog.riba2534.cn/blog/2018/ubuntuapache2%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91ssl%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https/</link>
      <pubDate>Fri, 28 Dec 2018 19:22:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/ubuntuapache2%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91ssl%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https/</guid>
      <description>Ubuntu+Apache2配置腾讯云ssl证书实现https 前言 本文所用的服务器环境是 Ubuntu18.04 + Apache2 .通过部署 ssl 来达到默认使用https方式访问网站的目的。
 超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。
历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。
&amp;mdash; 来自《维基百科》
 其实可以解决很大部分的运营商劫持问题，比如别人打开你的网站，网页上面会出现一些广告之类的，所以需要配置 https 来防止这个问题。
正文 Ubuntu 下 LAMP 环境的搭建，就不细说了，主要讲一下如何配置证书。
申请证书 打开腾讯云https://buy.cloud.tencent.com/ssl来获得腾讯云提供的免费证书：
点击域名型免费版，然后进去填一下网址和邮箱即可申请到。
过了几分钟，就会受到一个邮件，是一个压缩包，里面有各种服务器的 ssl 证书文件，我们进入 Apache2 这个目录，然后发现里面有三个文件：
1 2 3  1_root_bundle.crt # 证书文件 2_xxx.xxx.xxx.crt # 证书文件 3_xxx.xxx.xxx.key # 私钥文件    1_root_bundle.crt包含一段代码-----BEGIN CERTIFICATE-----和-----END CERTIFICATE----- 2_xxx.xxx.xxx.crt文件包括一段证书代码-----BEGIN CERTIFICATE-----和-----END CERTIFICATE----- 3_xxx.xxx.xxx.key文件包括一段私钥代码-----BEGIN RSA PRIVATE KEY-----和-----END RSA PRIVATE KEY-----  这是这几个文件的作用。</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 面试知识总结</title>
      <link>https://blog.riba2534.cn/blog/2018/c-cpp-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 25 Dec 2018 12:09:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/c-cpp-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>本文转载自:C/C++ 面试知识总结
C/C++ 面试知识总结 C/C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。
勘误新增请 Issue、PR，建议、讨论请 #issues/12，排版使用 中文文案排版指北
使用建议：
 Ctrl + F：快速查找定位知识点 TOC 导航：jawil/GayHub 插件快速目录跳转  目录  C/C++ STL 数据结构 算法 Problems 操作系统 计算机网络 网络编程 数据库 设计模式 链接装载库 海量数据处理 音视频 其他 书籍 复习刷题网站 招聘时间岗位 面试题目经验  C/C++ const 作用  修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常量； 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  使用 const 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值  public: // 构造函数  A() { }; A(int x) : a(x) { }; // 初始化列表  // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象  A b; // 普通对象，可以调用全部成员函数  const A a; // 常对象，只能调用常成员函数、更新常成员变量  const A *p = &amp;amp;a; // 常指针  const A &amp;amp;q = a; // 常引用  // 指针  char greeting[] = &amp;#34;Hello&amp;#34;; char* p1 = greeting; // 指针变量，指向字符数组变量  const char* p2 = greeting; // 指针变量，指向字符数组常量  char* const p3 = greeting; // 常指针，指向字符数组变量  const char* const p4 = greeting; // 常指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常指针 void function4(const int&amp;amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7();   static 作用  修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。  this 指针  this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;amp;this）。 在以下场景中，经常需要显式引用 this 指针：  为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。    inline 内联函数 特征  相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 不能包含循环、递归、switch 等复杂操作； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。  使用 inline 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 声明1（加 inline，建议使用） inline int functionName(int first, int secend,.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11:decltype类型推导及追踪返回值类型</title>
      <link>https://blog.riba2534.cn/blog/2018/cpp11_decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E5%8F%8A%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 24 Dec 2018 17:37:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/cpp11_decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E5%8F%8A%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</guid>
      <description>C++11:decltype类型推导及追踪返回值类型 使用decltype进行自动类型推导 先看一段cppreference上面的解释：decltype 指定符
可以看下面的一段代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct { char *name; } anon_u; struct { int d; decltype(anon_u) id; //没有告诉id的类型，用decltype自动推导 } anon_s[100]; //匿名的struct数组 int main() { decltype(anon_s) as;//注意 as 的类型。  return 0; }   再这段代码里面，首先定义了一个匿名的结构体anon_u，然后又定义了一个新的匿名结构体，其中有一个成员id,这时候并没有给它指明类型，而是让编译器自己去推导，指定id的类型为anon_u代表的这个类型。起到了重用匿名结构体的作用。
比如以下代码可以更容易的看出decltype关键字的作用。
1 2 3 4  int a = 6; decltype(a) c;//把c定义成a这个变量的类型 c = 21; cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;   泛型编程中结合auto，用于追踪函数的返回值类型</description>
    </item>
    
    <item>
      <title>常量指针和指针常量和常量指针常量</title>
      <link>https://blog.riba2534.cn/blog/2018/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Sun, 23 Dec 2018 21:20:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</guid>
      <description>常量指针和指针常量和常量指针常量 常量指针：指向常量的指针。
示例一：
1 2  int n = 10; const int *p = &amp;amp;n;   此时不能通过指针修改数据对象的值，但可以改变指针的指向。比如此时指针p不能改变n的值，但是可以指向另一个变量，把上面的代码做修改:
1 2 3 4  int n = 10, m = 30; const int *p = &amp;amp;n;//常量指针p初始化指向n *p = 20;// 这一步错误，这是一个常量指针，不能更改目标数据对象的值 p = &amp;amp;m;//这一步正确，可以修改指向   示例二:
1  void PrintObj(const int *p);   比如我们要定义一个函数，功能是打印某个对象的值，我们此时只希望函数有打印功能，不希望传进来的指针可以被修改，我们就把它变成常量指针，这样就只能打印，不能修改.
指针常量：指针指向的位置不可变化。
要注意一下，指针常量和其他常量一样，必须在定义时初始化。
此时不可以把指针指向其他地方，但是可以改变指针所指的目标数据对象的值。
示例一：
1 2 3 4  int n = 10, m = 30; int *const p = &amp;amp;n;//定义一个指针常量指向n *p = 40;//合法，可以改变指针所指的目标数据对象的值 p = &amp;amp;m;//不合法，不能修改指针指向。   常量指针常量：指向常量的指针常量（指针的双重只读属性）</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中main函数的参数</title>
      <link>https://blog.riba2534.cn/blog/2018/cpp%E4%B8%ADmain%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sun, 23 Dec 2018 16:52:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/cpp%E4%B8%ADmain%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</guid>
      <description>C++中main函数的参数 问题 对于一个C/CPP文件来说，一般都有main函数，一个程序的执行一定会是先从main函数这个入口开始，一个最基本的程序框架大概长这样:
1 2 3 4 5  #include &amp;lt;stdio.h&amp;gt;int main() { return 0; }   但是，我们有时候看到的main函数这个括号里面还有别的东西，比如:
1 2 3 4 5  #include &amp;lt;stdio.h&amp;gt;int main(int argc, char *argv[]) { return 0; }   或者
1 2 3 4 5  #include &amp;lt;stdio.h&amp;gt;int main(int argc, char **argv) { return 0; }   那么问题来了，这个argc和argv有什么用呢，为什么会有这个东西，有没有这个东西貌似对程序的执行并没有什么影响.
问题的探究 首先很容易看出char **argv和char *argv[]是等价的，无非是同一种东西两种写法。
argc是int型的，我们可以做一个测试，我们尝试打印一下这个值，看看它是什么?
我们可以测试一下以下程序:
1 2 3 4 5 6  #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>Makefile的简单教程</title>
      <link>https://blog.riba2534.cn/blog/2018/makefile%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sat, 22 Dec 2018 17:02:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/makefile%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</guid>
      <description>Makefile的简单教程 概述  什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的集成开发环境 （integrated development environment，IDE）都为你做了这个工作，但我觉得要作一个好的和专 业的程序员，makefile还是要懂。这就好像现在有这么多的HTML编辑器，但如果你想成为一个专业人士， 你还是要了解HTML的标签的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会 写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。
 说起makefile，很多人可能不知道是干什么的，当一个工程可能包含很多个文件的时候，编译起来可能会很复杂，这个时候我们可以写一个makefile编译脚本来定义一下编译的规则，然后只需要执行make命令，就会自动的执行编译脚本里面定义好的编译规则来编译项目，来得到希望得到的可执行文件。
在这里我简述一下几种简单的makefile文件的写法，已经可以解决很大一部分问题了。
提起makefile就必须得说一下make，make是一个工具，它可以解释makefile这个脚本，然后根据规则来编译一个项目。makefile定义规则，make来编译它。
关于makefile的更多知识，可以参考一下跟我一起写Makefile
语法规范 大概就长这个样子：
1 2 3 4  target ... : prerequisites ... command ... ...    target：你要生成的可执行文件 prerequisites：你要生成的可执行文件的依赖 command：通过什么命令来生成它  示例 概念说得再多，不如几个例子来的亲切。
以下包含几个例子以及如何写makefile文件来进行编译。
例子一： 现在我们随便写一个代码，用来找出一个数组中的最大值。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // main.cpp #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int find_max(int arr[], int n) { int maxx = 0; for (int i = 0; i &amp;lt; n; i++) maxx = max(maxx, arr[i]); return maxx; } int main() { int arr[5] = {1, 8, 6, 3, 4}; printf(&amp;#34;max is %d.</description>
    </item>
    
    <item>
      <title>软件工程学习笔记</title>
      <link>https://blog.riba2534.cn/blog/2018/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 20 Dec 2018 21:24:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>软件工程 记载一下软件工程中重要的定义.
一、软件工程引论 软件工程的定义 软件工程是一门学科，目的是生产出没有错误的软件，按时并且在预算交付，满足用户的需求。更进一步，当用户的需求改变时，软件必须易于修改。
软件危机 软件危机指软件产品的质量低得通常不能接受，并且不能满足交付日期和预算限制。是指在计算机软件开发和维护过程中遇到的一系列的问题。
软件工程的目标以及多目标之间的矛盾 软件工程的目标：
 软件开发的成本较低 软件功能能满足用户的需求 软件性能较好 软件可靠性高 软件易于使用，维护和移植 能按时完成开发任务，及时交付使用  矛盾：
 如果只考虑降低开发成本，很可能同时也降低了软件的可靠性。 如果一味追求软件的性能，可能开发出的软件对硬件的依赖性较强，从而影响软件的可移植性。  二、软件生命周期及其阶段和模型 软件生命周期指的是，软件产品从功能确定、设计、开发成功、投入使用，并在使用中不断修改、完善，直至被新的软件替代，从而停止软件使用的全过程。
软件生命周期分为几个阶段：可行性研究、项目计划、需求分析、总体设计、详细设计、编码实现、系统运行维护。
软件生命周期模型：  进化树模型：与现实世界软件开发最接近的模型，与「迭代-递增模型」等价 瀑布模型：纪律强制性的方法，文档驱动。 快速原型开发模型 同步-稳定模型 开源模型 敏捷过程原型 螺旋模型：风险驱动 迭代-递增模型  各种模型的特点： 瀑布模型的特点:
 线性化结构 各阶段具有里程碑特征 基于文档的驱动 严格的阶段评审机制  原型模型的两种实现方案各有什么特点  **抛弃式原型：**这种原型在目的达到后被抛弃，原型不做为最终产品 **进化式原型：**这类原型的形成和发展是逐步完成的，他是高度动态迭代和高度动态循环，是对付变化最有效的方式 **增量式模型：**系统是一段一段地增量构造，增量式开发实在软件总体设计基础上进行的。  大型项目用螺旋模型的原因 螺旋模型的优越性在于它吸收了「进化」的概念，使得开发人员和用户对每一个演化层出现的风险均有所了解，并对此做出反应。使用该模型需要丰富的风险评估经验和专门的知识。所以适合大项目。
三、结构化需求分析 需求分析及其任务 **需求分析：**开发人员准确的理解用户的要求，进行细致的调查分析，将用户非形式的需求陈述转化为完整的需求定义，再由需求定义转换到相应的需求规格说明的过程。
基本任务：
 问题识别：双方确定问题的综合需求 分析与综合：导出软件逻辑模型 编写文档：包括编写「需求规格说明书」，「初步用户使用手册」，「确认测试计划」，「修改完善软件开发计划」  重要概念：
  需求工程的主要目的是：解决系统是「做什么」的问题。
  需求分析最后产生的结果是产生「需求规格说明书」
  需求分析的主要方法是「结构化分析方法」</description>
    </item>
    
    <item>
      <title>大数据学习笔记</title>
      <link>https://blog.riba2534.cn/blog/2018/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 18 Dec 2018 11:50:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>大数据学习笔记 学习书籍为林子雨主编的《大数据技术原理与应用》
配套的 MOOC 视频为:大数据技术原理与应用
一、大数据基础 大数据的基础知识.
大数据的概念 4V说法:
 数据量大(数据大爆炸) 数据类型繁多(种类多) 处理速度快(大量的数据需要在秒级得到响应) 价值密度低  大数据计算模式    大数据计算模式 解决问题 代表产品     批处理计算 针对大规模数据的批量处理 MapReduce、Spark等   流计算 针对流数据的实时计算 Storm、S4等   图计算 针对大规模图结构数据的处理 Pregel、GraphX、Giraph等   查询分析计算 大规模数据的存储管理与查询分析 Hive、Dremel等    不同的模式解决不同的问题
云计算 三大名词:
 SaaS : 面向用户,基础设施服务,应用层（软件即服务） PaaS : 面向应用开发者，平台层（平台即服务） IaaS : 面向网络架构师，基础设施层（基础设施即服务）  大数据与云计算、物联网的关系  云计算为大数据提供了技术基础，大数据为云计算机提供用武之地 物联网是大数据的重要来源，大数据为物联网数据分析提供支持 云计算为物联网提供海量数据存储能力，物联网为云计算技术提供了广阔的应用空间.  二、大数据处理架构 Hadoop Hadoop是一个开源的，可运行于大规模集群的一个分布式计算平台。</description>
    </item>
    
    <item>
      <title>Django2.0中使用MrakDown编辑器并在前端显示</title>
      <link>https://blog.riba2534.cn/blog/2018/django2.0%E4%B8%AD%E4%BD%BF%E7%94%A8mrakdown%E7%BC%96%E8%BE%91%E5%99%A8%E5%B9%B6%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%98%BE%E7%A4%BA/</link>
      <pubDate>Sun, 16 Dec 2018 16:31:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/django2.0%E4%B8%AD%E4%BD%BF%E7%94%A8mrakdown%E7%BC%96%E8%BE%91%E5%99%A8%E5%B9%B6%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%98%BE%E7%A4%BA/</guid>
      <description>Django2.0中使用MrakDown编辑器并在前端显示 前言 在使用Django的过程中，有一个使用文本编辑器的需求，原本使用的是富文本编辑器django-ckeditor但是它不是MarkDown编辑器，经过一翻寻找我找到了Editor.Md这个项目，这是一款优秀的MrakDown编辑器，并且有人贴心得把它移植到了Django上，下面我记载一下使用方法
 本文所用的操作系统为Deepin 15.8
Python版本:Python 3.6.5
Django版本:2.0
 添加编辑器到后台 首先我们需要安装编辑器，这个编辑器在GitHub的地址是:django-mdeditor
  安装django-mdeditor:
1  sudo pip3 install django-mdeditor     然后在项目目录的settings.py加入:
1 2 3 4  INSTALLED_APPS = [ ... &amp;#39;mdeditor&amp;#39;, ]     添加媒体路径到设置中:
1 2  MEDIA_ROOT = os.path.join(BASE_DIR, &amp;#39;uploads&amp;#39;) MEDIA_URL = &amp;#39;/media/&amp;#39;     在项目的urls.py中加入:
1 2 3 4 5 6 7 8 9 10 11 12  from django.</description>
    </item>
    
    <item>
      <title>Linux使用中杂七杂八的问题总结</title>
      <link>https://blog.riba2534.cn/blog/2018/linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Dec 2018 13:07:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 在Linux的使用中会碰到很多配置上的问题，在这里总结一下自己在使用过程中碰到的问题的一些行之有效的解决方法。
ubuntu18.04应用程序自启 环境:操作系统是:Ubuntu18.04 LTS
 按Alt+F2,然后输入命令:gnome-session-properties,按回车,会进入一个启动应用程序首选项的界面 添加要启动的命令即可 如果是桌面应用程序，可以去/usr/share/applications目录下找到对应的.desktop文件，然后就可以查看当前应用程序的启动参数。  当我亲自试验以后，发现添加到启动菜单候每次只启动一次，第二次开机就没有了。。于是我找到了一个曲线救国的方法。
 去坚果云官网下载坚果云 开启坚果云的自动启动 去前面说的目录里面改坚果云的启动参数，改成要启动的软件，这样就可每次开机都有了  参考: ubuntu18.04设置开机自启动
ubuntu18.04开启速度优化  systemd-analyze blame可以显示开机启动项的启动时间 可以发现NetworkManager-wait-online.service这一项特别慢，搜索了一下发现这一项貌似是加载一些网络上的代码，无关紧要可以禁用掉 sudo systemctl disable NetworkManager-wait-online.service禁用掉  参考链接: Ubuntu | Linux加快开机启动 What does NetworkManager-wait-online.service do? Ubuntu 18.04 踩坑记录(In Update)
zsh和oh-my-zsh安装  安装git和zshsudo apt install git zsh -y 获取安装脚本:wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 切换成zsh:chsh -s /bin/zsh  如果出现PAM验证之类的问题，可以参考这个方案:
 删除已经写入本地的文件rm -rf ~/.oh-my-zsh/ 获取脚本:curl -L http://install.ohmyz.sh &amp;gt; install.sh sh install.</description>
    </item>
    
    <item>
      <title>ACM退役感言</title>
      <link>https://blog.riba2534.cn/blog/2018/acm%E9%80%80%E5%BD%B9%E6%84%9F%E8%A8%80/</link>
      <pubDate>Thu, 13 Dec 2018 22:49:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/acm%E9%80%80%E5%BD%B9%E6%84%9F%E8%A8%80/</guid>
      <description>ACM退役感言 很早之前就想写这篇博客了，由于很多原因，一直拖到了现在。由于弱校的原因，我们在大三上学期打完ACM亚洲区域赛和CCPC就退役了，因为这时候面临着找工作和考研的问题，我们没有时间再搞一年ACM,回顾一下我这两年来的历程.
大一 2016年9月，是大一开学的日子</description>
    </item>
    
    <item>
      <title>frp中文文档</title>
      <link>https://blog.riba2534.cn/blog/2018/frp%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</link>
      <pubDate>Thu, 13 Dec 2018 21:28:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/frp%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</guid>
      <description>frp 
frp 的作用  利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。  开发状态 frp 仍然处于前期开发阶段，未经充分测试与验证，不推荐用于生产环境。
master 分支用于发布稳定版本，dev 分支用于开发，您可以尝试下载最新的 release 版本进行测试。
目前的交互协议可能随时改变，不保证向后兼容，升级新版本时需要注意公告说明同时升级服务端和客户端。
架构 使用示例 根据对应的操作系统及架构，从 Release 页面下载最新版本的程序。
将 frps 及 frps.ini 放到具有公网 IP 的机器上。
将 frpc 及 frpc.ini 放到处于内网环境的机器上。
通过 ssh 访问公司内网机器  修改 frps.ini 文件，这里使用了最简化的配置：  1 2 3  # frps.ini [common] bind_port = 7000   启动 frps：  .</description>
    </item>
    
    <item>
      <title>新博客迁移通知</title>
      <link>https://blog.riba2534.cn/blog/2018/%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%80%9A%E7%9F%A5/</link>
      <pubDate>Thu, 13 Dec 2018 13:55:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2018/%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%80%9A%E7%9F%A5/</guid>
      <description>新博客迁移通知 由于CSDN变得越来越流氓，虽然可以用广告屏蔽插件屏蔽广告，但是并不是所有的浏览者都可以屏蔽广告，再加上原本的www.riba2534.cn是基于wordpress显得太臃肿，不适合轻量级的博客，遂迁移到typecho.
会使用这个地址来更新博客,地址: http://blog.riba2534.cn/&amp;lt;/</description>
    </item>
    
    <item>
      <title>迷宫游戏</title>
      <link>https://blog.riba2534.cn/blog/2017/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 12 Dec 2017 22:49:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2017/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/</guid>
      <description>迷宫游戏  大二数据结构课设
 想不出来写啥，还是用 EasyX 图形库写了一个走迷宫，就是简单的 BFS ,记录了一下路径，因为时间比较紧，就随便写了写，把代码放在这吧
编译环境：
  Visual Studio 2017（在编译选项里选择多字符集支持，默认是Unicode的字符集）
  EasyX图形库
  游戏截图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436  #include &amp;lt;graphics.</description>
    </item>
    
    <item>
      <title>爬取nyist-6000张证件照进行微软小冰颜值分析</title>
      <link>https://blog.riba2534.cn/blog/2017/%E7%88%AC%E5%8F%96nyist-6000%E5%BC%A0%E8%AF%81%E4%BB%B6%E7%85%A7%E8%BF%9B%E8%A1%8C%E5%BE%AE%E8%BD%AF%E5%B0%8F%E5%86%B0%E9%A2%9C%E5%80%BC%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 08 Sep 2017 22:49:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2017/%E7%88%AC%E5%8F%96nyist-6000%E5%BC%A0%E8%AF%81%E4%BB%B6%E7%85%A7%E8%BF%9B%E8%A1%8C%E5%BE%AE%E8%BD%AF%E5%B0%8F%E5%86%B0%E9%A2%9C%E5%80%BC%E5%88%86%E6%9E%90/</guid>
      <description>Python爬取nyist-6000张证件照进行颜值分析 前言 本文章同步至CSDN博客：http://blog.csdn.net/riba2534/article/details/77894500
前几天学校要求更新档案资料库的照片，所以要求每个人去照证件照，大多数人是在学校里面的一个照相的地方照的，为了容易使同学们拿到照片，他们会每天把每个人的证件照上传到一个网站，于是我就用爬虫爬取了6000+照片，结合微软小冰的人脸识别中的颜值分析功能对每张照片进行打分，然后进行一次简单的颜值分析，下面简单说一说我的过程,结论在最后
工具准备  python-3.6.2（必备） requests库（请求网络） re库（正则表达式） base64库（对base64编码进行处理） time库（构造post请求时要用到） os库（处理一些文件要用到） matplotlib库（用于绘制图表）  采集照片的网址：http://ngsying.com/list.asp?classid=22 微软小冰的颜值分析网址：https://kan.msxiaobing.com/ImageGame/Portal?task=yanzhi&amp;amp;feid=541a6dd6cd178819892a917dd772e702 微软的图片服务器网址：http://kan.msxiaobing.com/Api/Image/UploadBase64    一、爬取并保存图片 首先，我们打开要采集照片的地址：http://ngsying.com/list.asp?classid=22,会看到这样： 然后引入相关的库：
1 2 3 4 5  import re import requests from bs4 import BeautifulSoup import lxml import os   我们打开这些链接发现：
 http://ngsying.com/show.asp?id=99 http://ngsying.com/show.asp?id=100  因为日期的不同，所以网页地址变得只是后面的数字，所以我们只需要找到我们要爬取的第一个页面的标号和最后一个页面的标号，然后对每一个页面分别爬取就好了。 随便打开一个页面，会发现图片是这样的：
我们解析一下网页源代码会发现是这样的：
这些图片都无一例外的藏在img标签里面的，所以我们只需要把这些里面的内容提取出来就可以得到每一张图片的地址了。 提取的方法有很多种，比如用BeautifulSoup,但是这里由于这个标签并不需要解析成文档树，可以直接写一个正则表达式提取出来，所以我们可以这么写：
/upfile/201709/\d+\.JPG只需要简单的匹配一下多位数字就可以了，这样我们可以写出具体代码:
这样因为正则匹配的缘故，会返回一个包含所有图片地址的列表，那么现在我们要做的就是利用这个列表，进行保存： 这个也很简单，我们遍历一下这个列表，然后构造每一个图片链接，这里也需要用正则表达式来匹配一下文件名，用requests请求一下把二进制的东西保存成.jpg文件就好了
现在我们的代码已经实现了对每个页面的图片进行保存，剩下的就是调用这两个函数了，我们只需要遍历一下要爬的网页的id，然后等着爬取完成就好了,爬虫爬完后会得到一个文件夹，里面就是你爬好的照片，就像这样： 到了现在，第一步就做完了，已经拥有这几千张证件照了
二、调用微软小冰人脸识别中的测颜值功能 首先，我们打开微软小冰的识别页面：
https://kan.msxiaobing.com/ImageGame/Portal?task=yanzhi&amp;amp;feid=541a6dd6cd178819892a917dd772e702
显示这样：
这时我们点”上传图片”，然后进行抓包 我们发现有两个post请求，分别是把当前图片传到微软服务器，还有一个是进行颜值测试，进行颜值测试的时候其中的一个参数要传入当前这个图片在微软服务器的地址，所以我们要分两步来做：
 把图片上传至微软服务器，并且得到返回的图片地址 运用得到的图片地址，进行颜值颜值测试  通过抓包可以发现两个post地址，一个是提交图片的地址，另一个是获得颜值分数的地址:</description>
    </item>
    
    <item>
      <title>12306火车票余票查询器</title>
      <link>https://blog.riba2534.cn/blog/2017/12306%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%BD%99%E7%A5%A8%E6%9F%A5%E8%AF%A2%E5%99%A8/</link>
      <pubDate>Sat, 02 Sep 2017 22:49:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2017/12306%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%BD%99%E7%A5%A8%E6%9F%A5%E8%AF%A2%E5%99%A8/</guid>
      <description>12306火车票余票查询器 今天写了一个12306火车票余票查询器的爬虫，在这里记录一下过程.
本博客同步更新:http://blog.csdn.net/riba2534
首先先看一下最终效果：
比如想查9月2日从西安—北京动车和特快的余票
tickets.py -dg 西安 北京 2017-09-02效果预览：
首先我们梳理一下用到的工具：
 Python3.x(必备) requests库，用来进行http请求的访问 docopt库，用来实现命令行参数处理(使用方法) prettytable,使信息以好看的表格形式呈现出来 colorama,用来设置命令行中显示的颜色  前期准备 我们的主程序就叫做tickets.py,因为我们是用的带参数的形式实现程序，所以我们要先进行参数的声明: 我们先：from docopt import docopt
&amp;quot;&amp;quot;&amp;quot;命令行火车余票查询器Usage:tickets [-gdtkz] &amp;lt;from&amp;gt; &amp;lt;to&amp;gt; &amp;lt;date&amp;gt;Options:-h,--help 显示帮助菜单-g 高铁-d 动车-t 特快-k 快速-z 直达&amp;quot;&amp;quot;&amp;quot;这些信息会存储在__doc__中，docopt会对这个信息进行解析然后返回我们需要的信息，解析的代码如下： 解析URL 既然要写爬虫，那么首先肯定是要对URL进行解析了，我们要爬取的是12306的网站，那么我们首先找到查询余票的网站：
https://kyfw.12306.cn/otn/leftTicket/init我们会看到这个： 然后进行抓包，我们会发现一个GET请求： 也就是这个链接：
https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=2017-09-01&amp;amp;leftTicketDTO.from_station=XAY&amp;amp;leftTicketDTO.to_station=BJP&amp;amp;purpose_codes=ADULT我们通过观察就会发现这个请求里面有4个参数：
 leftTicketDTO.train_date=2017-09-01 leftTicketDTO.from_station=XAY leftTicketDTO.to_station=BJP purpose_codes=ADULT  我们通过观察就可以知道，这四个属性分别对应着：查询的时间，出发的站点，结束的站点，票的种类
现在发现了一个问题，出发站点和结束站点的值为什么都是英文，这些字母肯定表示的是城市的名称，那么我们现在就要去寻找这些城市的代码，我们查看网页源代码 发现了一个JS文件，打开以后会发现 这个页面竟然包含着全部的站点名称和对应的代码，所以我们只需要把这些东西解析一下，就可以得到车站和对应的代码了.
所以我们就有了思路了，我们应该先用requests来获取这个页面，然后再用正则表达式来把对应的信息解析一下，然后进行一些处理就好了，关于正则表达式的使用，不会的童鞋还是去百度百度吧~ 根据网页上面的信息，我们可以写出如下正则表达式：
([\u4e00-\u9fa5]+)\|([A-Z]+)先匹配汉字，然后后面匹配字母，中间有一个分隔符,完整的代码.
我们建一个文件parser_stations.py解析：</description>
    </item>
    
    <item>
      <title>HDU自动AC机，八小时爬上杭电首页</title>
      <link>https://blog.riba2534.cn/blog/2017/hdu%E8%87%AA%E5%8A%A8ac%E6%9C%BA%E5%85%AB%E5%B0%8F%E6%97%B6%E7%88%AC%E4%B8%8A%E6%9D%AD%E7%94%B5%E9%A6%96%E9%A1%B5/</link>
      <pubDate>Mon, 24 Jul 2017 22:49:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2017/hdu%E8%87%AA%E5%8A%A8ac%E6%9C%BA%E5%85%AB%E5%B0%8F%E6%97%B6%E7%88%AC%E4%B8%8A%E6%9D%AD%E7%94%B5%E9%A6%96%E9%A1%B5/</guid>
      <description>HDU自动AC机，八小时爬上杭电首页 前言 身为一个ACMer，整天面对电脑屏幕，一个题冥思苦想一整天，调bug调到绝望，看着自己可怜的AC数，想想都很绝望~
那么在学习之余我们也应该做一些有趣的事情，比如说 自动AC？ 体验体验AC的快感，最然是假的(捂脸)
说到自动AC，我们首先想到的是什么，当然是爬虫，说到爬虫，那么就要说一说python了，没有什么语言比它更适合了.
废话不多说，先放一张战果：
第十四名，AC率达到了百分之92，怕不怕~
工欲善其事，必先利其器，用到的工具有：
 python-3.6.2 BeautifulSoup4 库 requests库  那么现在，我们来说一说思路：
思路 获取 本来想好的思路是，在百度等搜索引擎，搜索hdu+题号，然后筛选出csdn和博客园的链接，然后保存提交的，但是学长给了一个网站，我发现了新大陆:
http://www.acmsearch.com/
就是这个网站，上面给出了，大部分题的题解，简直是开盖即食，按捺不住这种激动的心情，那么首先，就是获取链接了：
我们点击hdoj，输入题目的ID，发现底下一排排已经AC的代码，这时，看一看网页的地址栏：
http://www.acmsearch.com/article?ArticleListSearch%5BFoj%5D=hdoj&amp;amp;ArticleListSearch%5BFproblem_id%5D=2111&amp;amp;ArticleListSearch%5BFproblem_name%5D=&amp;amp;ArticleListSearch%5BFarticle_name%5D=&amp;amp;ArticleListSearch%5BFsource%5D=&amp;amp;ArticleListSearch%5BFread_num%5D=&amp;amp;ArticleListSearch%5BFstar_avg%5D=
什么鬼！竟然是一堆乱码，但是我们仔细观察就知道了，这是被URL加密过的链接，我们对这个链接进行解密，结果如下：
http://www.acmsearch.com/article?ArticleListSearch[Foj]=hdoj&amp;amp;ArticleListSearch[Fproblem_id]=2111&amp;amp;ArticleListSearch[Fproblem_name]=&amp;amp;ArticleListSearch[Farticle_name]=&amp;amp;ArticleListSearch[Fsource]=&amp;amp;ArticleListSearch[Fread_num]=&amp;amp;ArticleListSearch[Fstar_avg]=
这一次链接是不是很清晰了，里面的ID后面加数字，就是我们要搜的题目编号，我们查询的时候是需要给这个链接发GET请求就好了。
这时我们利用F12大法查看一下网页代码：
发现题解的链接都是在一个 tbody-&amp;gt;tr-&amp;gt;data-key 的标签里面，然后我们再构造链接：
http://www.acmsearch.com/article/show/+编号
这样就获得到了代码的页面,以HDU2111这个题来说明，我们获取了链接以后，一个GET请求发过去，会进入一个这样的页面：
没错，我们看到了AC代码，这时候我们要做的是把代码从网页中提取出来,那么我们继续查看网页源代码：
发现了啥，没错，代码就在一个标签名叫做 textarea 的标签下,我们只需要提取这个标签 里面的内容.
放一部分关键代码：
这时候，我们的代码就获取完毕了，这时候，重要的一步来了，我们要登录杭电并且提交代码
登陆HDU 我们先打开杭电首页:
我们把账号密码输进去，按F12监听数据抓包：
我们发现一个POST地址，这就是我们待会要登录的地址，然后看看其他发送过去的内容
我们要发送的请求要包含：
username,userpass,login分别代表账户名，密码，操作
我们还需要带上一个User-Agent,来告诉页面我们是一个正常的浏览器访问：
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36然后我们构造请求头，和发送的数据，本来我打算用urllib库里面的cooklib对象，但是requests里面直接把cookie的事情给解决了，附上官方文档的链接：
http://docs.python-requests.org/zh_CN/latest/user/quickstart.html
这一步关键代码如下：
当登录成功以后，我们要做的就是提交代码了
提交 我们找一道题目，比如2111，来进行提交，首先，先抓包：
然后进行抓包：
我们得到了post地址，
提交的时候要带上cookie，以及构造的DATA数据。
比如：
data = {&#39;check&#39;: &#39;0&#39;,&#39;problemid&#39;: str(id),&#39;language&#39;: &#39;2&#39;,&#39;usercode&#39;: str(code)}headers = {&#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.</description>
    </item>
    
    <item>
      <title>水墨五子棋</title>
      <link>https://blog.riba2534.cn/blog/2017/%E6%B0%B4%E5%A2%A8%E4%BA%94%E5%AD%90%E6%A3%8B/</link>
      <pubDate>Tue, 23 May 2017 22:49:00 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2017/%E6%B0%B4%E5%A2%A8%E4%BA%94%E5%AD%90%E6%A3%8B/</guid>
      <description>水墨五子棋  大一 C++课程设计
 简介 老师布置了C++的课程设计，说是随便写点啥，同学们都写了各种基于黑框框(控制台)的什么学生成绩管理系统，感觉没什么创意，我想写一个图形界面的，本程序采用了 EasyX 图形库和一些 Winodows API ，然后用它来完成我的五子棋，具体实现过程就不说了，底下会放出源码。
编译环境：
 Visual Studio 2017（在编译选项里选择多字符集支持，默认是Unicode的字符集） EasyX图形库  原来准备写三个功能：
  双人对战（已完成）
  单人AI（有BUG）
  联机对战（没写）
  背景音乐：
 主界面： 万代.传承 游戏界面： 绿野仙踪  游戏截图 主界面：
鼠标移到对应选项会变色：
双人模式界面：
双人模式胜利界面：
AI模式胜利界面：
代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088  #include &amp;lt;graphics.</description>
    </item>
    
  </channel>
</rss>
