<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on 🌀Jarson Cai&#39;s Blog</title>
    <link>https://caixiongjiang.github.io/blog/</link>
    <description>Recent content in Blogs on 🌀Jarson Cai&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 24 Jun 2022 18:18:05 +0800</lastBuildDate><atom:link href="https://caixiongjiang.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker快速入门</title>
      <link>https://caixiongjiang.github.io/blog/2022/docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 24 Jun 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>Docker一小时快速入门 Docker简介和安装 Docker 开发部署流程 自己在 Windows/Mac 上开发、测试 &amp;ndash;&amp;gt; 打包为 Docker 镜像（可以理解为软件安装包） &amp;ndash;&amp;gt; 各种服务器上只需要一个命令部署好。
优点:确保了不同机器上跑起来都是一致的运行环境，不会出现不同机器之间切换出现bug的问题。
Docker通常来做什么 应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用 快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK 多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0 Windows/mac上体验/学习各种 Linux 系统 重要概念：镜像、容器 镜像：可以理解为软件安装包，可以方便进行传播和安装
容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的、称之为容器
安装 桌面版：https://www.docker.com/products/docker-desktop
mac版安装无障碍，Windows版安装还挺麻烦的，可以看一下这个在线文档
服务器版：https://docs.docker.com/engine/install/#server
镜像加速源 镜像加速源 镜像加速器地址 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://&amp;lt;your_code&amp;gt;.mirror.aliyuncs.com 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com 我配置的是阿里云的镜像源，不过阿里云的镜像源需要自己配置一个账号，也可以配置其他的镜像源。
配置方法如下，在Docker Desktop中点击设置，找到Docker Engine中，在registry-mirrors字段中加上镜像源restart即可。
Docker快速安装软件 Docker安装的优点 一个命令就可以安装好，快速方便 有大量的镜像，可直接使用 没有系统兼容问题，Linux 专享软件也照样跑 支持软件多版本共存 用完就丢，不拖慢电脑速度 不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有 演示Docker安装Redis 首先，Docker官方镜像仓库查找Redis：https://hub.</description>
    </item>
    
    <item>
      <title>Git：版本管理工具</title>
      <link>https://caixiongjiang.github.io/blog/2022/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 18 Jun 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>Git版本管理工具 Git安装 mac下有两种安装方法：
官网安装：https://git-scm.com/downloads
命令行通过Homebrew 源安装：
Homebrew官网下载：https://brew.sh
如果官网提供的脚本下载太慢了，可以试试下面这个脚本：
1 $ /bin/zsh -c &amp;#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;#34; Homebrew下载完之后，使用brew安装Git：
1 $ brew install git Git简介 Git管理的文件 文本文件（.txt） 脚本文件（.py） 各种基于文本信息的文件 Git不能管理的文件 图片文件（.jpg） MS word（.doc） 创建第一个版本库 创建版本库（init） 首先在桌面创建一个文件夹gitQAQ，在Terminal中打开，并进入该目录:
1 $ cd ~/Desktop/gitQAQ 为了记录每一个对版本记录施加修改的人user.name，我们在git中添加用户名和用户emailuser.email：
1 2 $ git config --global user.name &amp;#34;Jarson Cai&amp;#34; $ git config --global user.email &amp;#34;nau_cxj@163.com&amp;#34; 然后，我们就可以建立git的管理文件：
1 2 $ git init Initialized empty Git repository in /Users/caixiongjiang/Desktop/gitQAQ/.git/ 这样，我们就建立了一个空的Git版本管理库。
添加文件管理（add） 通常执行ls就能看见文件夹中所有的文件，不过git创建的管理库文件.git会被隐藏起来，执行下面语句才能看到：
1 2 $ ls -a .</description>
    </item>
    
    <item>
      <title>LaTeX入门教程</title>
      <link>https://caixiongjiang.github.io/blog/2022/latex%E8%AE%BA%E6%96%87/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 13 Jun 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/latex%E8%AE%BA%E6%96%87/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</guid>
      <description>LaTeX入门教程 环境安装和配置的几种方案 mac环境
MacTex发行版：https://www.tug.org/mactex/ texpad(付费，当然某些网站有破解版) texpad不需要任何复杂的配置
MacTex发行版：https://www.tug.org/mactex/ vscode+LaTeX Workshop插件 vscode方案装好插件之后还需要配置.json
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 //注释掉的部分属于代码提示的功能，还需要装插件 { &amp;#34;latex-workshop.</description>
    </item>
    
    <item>
      <title>MySQL进阶篇 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/mysql%E8%BF%9B%E9%98%B6%E7%AF%87/</link>
      <pubDate>Wed, 08 Jun 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/mysql%E8%BF%9B%E9%98%B6%E7%AF%87/</guid>
      <description>MySQL学习目标 面试题demo： 什么是事物，以及事务的四大特性？ 事务的隔离级别有哪些？MySQL默认是哪几个？ 内连接与左外连接的区别是什么？ 常用的存储引擎？InnoDB和MyISAM的区别？ MySQL默认InnoDB引擎的索引是什么数据结构 如何查看MySQL的执行计划？ 索引失效的情况有哪些？ 什么是回表查询？ 什么是MVCC？ MySQL主从复制的原理是什么？ 主从复制之后的读写分离如何实现？ 数据库的分库分表如何实现？ 学习目标： 入门阶段：下载和安装mysql，学习并使用SQL语言 进阶阶段：学习事务，存储引擎，索引，SQL优化，锁 高级阶段：学习日志管理，主从复制，读写分离，分库分表（主要用于集群） 注：本笔记基于b站最新的2022的mysql免费视频：https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.999.0.0 MySQL进阶篇 存储引擎 MySQL体系结构 MySQl服务器分为4层：连接层；服务层；引擎层；存储层。
存储引擎简介 存储引擎就是存储数据，建立索引，更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。
1.在创建表是，可以指定存储引擎
1 2 3 4 5 create table 表名( 字段1 字段1类型 [comment 字段1注释], ...... 字段n 字段n类型 [comment 字段n注释] )engine = innodb [comment 表注释]; 查看当前数据库支持的存储引擎
1 show engines; 存储引擎特点 InnoDB
介绍：InnoDB是一种兼顾搞可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。
特点：
DML操作遵循ACID模型，支持事务；
行级锁，提高并发访问性能；
支持外键FOREIGN KEY约束，保证数据的完整性和正确性；
文件
xxx.ibd:xxx代表的是表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi）、数据和索引。
参数：innodb_file_per_table
存储结构：
MyISAM
介绍：MyISAM是MySQL早期的默认存储引擎。
特点：
不支持事务，不支持外键；
支持表锁，不支持行锁；
访问速度快。</description>
    </item>
    
    <item>
      <title>CentOS7安装MySQL</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/centos-7%E5%AE%89%E8%A3%85mysql/</link>
      <pubDate>Fri, 20 May 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/centos-7%E5%AE%89%E8%A3%85mysql/</guid>
      <description>Linux下MySQL安装&amp;amp;远程访问配置 下载安装包 社区免费版下载地址：https://downloads.mysql.com/archives/community/
选择正确的版本：
需要安装Linux版本的MySQL，所以可以选择两个版本：一个是Red Hat Enterprice Linux,另一个是Linux-Generic。我选择的是前者，因为CentOS和它是同一个公司出的！ 选择OS version：如果你是CentOS 7，则选择Linux 7；如果为CentOS 8，则选择Linux 8。至于x86，ARM如何选取，取决于你的cpu： 如果你是mac OS系统，intel芯片，就选择x86 64bit位（现在的电脑基本都是64bit位）；如果是M1系列的芯片，请选择ARM 如果你是Windows系统，就选x86 64bit位 Linux-虚拟机三件套 此次我是在mac OS下操作虚拟机，使用三个软件来部署环境，至于如何配置环境，我在之前的博客里已经讲过了！点击查看
虚拟机软件：VMware Fusion 连接工具：nuoshell 文件传输工具：Transmit 安装MySQL 将下载好的包文件使用Transmit传输到虚拟机的系统。
正式开始安装：
解压包到mysql文件夹：
1 2 3 4 5 6 7 8 # 新建文件夹 mkdir mysql # 把包解压到mysql文件夹下 tar -xvf mysql-8.0.28-1.el7.x86_64.rpm-bundle.tar -C mysql # 进入文件 cd mysql # 查看解压后的文件 ll 会得到如下的结果：
1 2 3 4 5 6 7 8 9 10 11 total 823244 -rw-r--r--.</description>
    </item>
    
    <item>
      <title>MySQL基础篇 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/mysql%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Tue, 17 May 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/mysql%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>MySQL学习目标 面试题demo：
什么是事物，以及事务的四大特性？ 事务的隔离级别有哪些？MySQL默认是哪几个？ 内连接与左外连接的区别是什么？ 常用的存储引擎？InnoDB和MyISAM的区别？ MySQL默认InnoDB引擎的索引是什么数据结构 如何查看MySQL的执行计划？ 索引失效的情况有哪些？ 什么是回表查询？ 什么是MVCC？ MySQL主从复制的原理是什么？ 主从复制之后的读写分离如何实现？ 数据库的分库分表如何实现？ 学习目标：
入门阶段：下载和安装mysql，学习并使用SQL语言 进阶阶段：学习事务，存储引擎，索引，SQL优化，锁 高级阶段：学习日志管理，主从复制，读写分离，分库分表（主要用于集群） 注：本笔记基于b站最新的2022的mysql免费视频：https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.999.0.0
MySQL基础篇 MySQL概述 数据库相关概念 数据库，也就是存储数据的仓库，简称DataBase（DB） 数据库管理系统，也就是操纵和管理数据库的软件，DataBase ManageMent System（DBMS） SQL是操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准，Structure Query Language（SQL） 主流的关系型数据库管理系统：Oracle，MySQL，SQL Server,SQLite3(嵌入式微型数据库) 下载&amp;amp;安装MySQL（mac版本） 版本：MySQL Community Server 8.0.29（社区免费版）
下载：https://www.mysql.com/
mac版本下安装完之后，可以打开系统偏好设置，就可以找到mysql
需要设置root密码
启动和停止：
连接mysql（命令行工具）：
打开Terminal，修改配置文件（Windows下为环境变量配置）：
输入：
1 sudo vim .bash_profile 加入路径：
PATH=$PATH:/usr/local/mysql/bin 保存退出（:wq），并启用该文件(每次新建一个Terminal都需要重新启用)
1 source .bash_profile 连接数据库并输入root密码：
1 mysql [-h 127.0.0.1] [-p 3306] -u root -p 其中带[]的部分可以省略，默认连接自身电脑。然后输入密码，出现MySQL版本就成功了！
关系型数据库 关系型数据库是建立在关系模型的基础上，由多张相互连接的二维表组成的数据库：
特性：
1.使用表存储，格式统一，便于维护 2.使用SQL语言操作，标准统一 MySQL数据库数据模型 SQL SQL通用语法 SQL语句可以单行或者多行书写，以分号结尾 SQL语句可以使用空格/缩进来增强语句的可读性 MySQL数据库的SQL语句不区分大小写，关键字建议使用大写 注释： 单行注释：--注释内容 或 # 注释内容（MySQL特有） 多行注释：/* 注释内容 */ SQL分类 DDL语句 DDL-数据库操作</description>
    </item>
    
    <item>
      <title>第十二讲：hashtable深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC12%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 12 May 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC12%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第十二讲：hashtable深度探索 为什么要使用hashtable？ 如上图所示，如果空间足够，我们当然可以按照次序进行存储，但往往存储是比较有限的，我们就可以使用 hashtable的结构来存储！
如何处理hashtable的碰撞现象？ 如果我们使用hashtable的结构，一定会存在取余之后相等的情况：例如15%7和22%7就会发生碰撞！
我们解决的办法是：如果发生碰撞，就将它们以一个链表的形式串在一起，如下图所示。
特点：
发生碰撞时使用形成链表的形式来解决碰撞。
链表的搜寻时间是线性增长的（ 平均时间复杂度为O(n) ），但如果list够小，搜寻的速度荏苒很快。
如果所有链表的总节点数超过了bucket（这里指模的值，图中为53，也是GNU中使用的初始值）的数量， 采用再哈希的方法:
方式为将bucket的数量扩充到原来的值的2倍，然后选取离它最近的素数作为新的bucket值。 每次扩充都需要对每个元素重新计算新的位置。 在源码中已经将所有bucket的值全部算好了，需要扩充时，直接取就ok！ hashtable部分源码（GNU2.9）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template &amp;lt;class Value, class Key, class HashFcn, class ExtractKey, class EqualKey, class Alloc&amp;gt; class hashtable { public: //将传进来的参数重新换了一个名称 typedef HashFcn hasher; typedef EqualKey key_equal; typedef size_t size_type; private: // 以下三者都是function objects。&amp;lt;stl_hash_fun.</description>
    </item>
    
    <item>
      <title>第十一讲：set/multiset &amp; map/multimap深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC11%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 10 May 2022 08:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC11%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第十一讲：set/multiset &amp;amp; map/multimap深度探索 set和multiset特性 set/multiset以红黑树为底层结构，因此有自动排序的特性，排序的依据是key，而set和multiset的value和key 是合二为一的：value就是key（key和data合成value） set和multiset提供遍历的操作以及iterator，按照正常的规则遍历就能获得排序状态。 无法使用iterator来改变元素值（底层为将iterator设为const），因为key有其严谨的排序规则。 set的key必须独一无二，因此其insert()用的是rb_tree的insert_unique() multiset元素的key可以重复，因此其insert()用的是rb_tree的insert_equal() set容器 模版定义：（GNU2.9）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //set默认采用key值降序排列 template &amp;lt;class Key, class Compare = less&amp;lt;Key&amp;gt;, class Alloc = alloc&amp;gt; class set { public: // typedefs: typedef Key key_type; typedef Key value_type; // 注意，以下 key_compare 和 value_compare 使用相同的比較函式 typedef Compare key_compare; typedef Compare value_compare; private: typedef rb_tree&amp;lt;key_type, value_type, identity&amp;lt;value_type&amp;gt;, key_compare, Alloc&amp;gt; rep_type; rep_type t; // 采用紅黑树（RB-tree）來表現 set public: typedef typename rep_type::const_iterator iterator;//这里的迭代器不能改变 //set的所有操作都转而呼叫底层（红黑树）的操作 .</description>
    </item>
    
    <item>
      <title>《数字图像处理》课程设计——表格图片文字识别</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%A1%A8%E6%A0%BC%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</link>
      <pubDate>Thu, 05 May 2022 19:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%A1%A8%E6%A0%BC%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</guid>
      <description>《数字图像处理》课程设计——表格图片文字识别 目标任务 1、将图片中的信息提取为表格：提取“姓名”、“准考证号”、“已录取”，保存为新表格 2、在已有表格中查找指定数据并进行标注；将“已录取”数据增加到原有表格中 思路步骤 1.使用灰度方法读取图片，并利用局部阈值分割方法分割为像素只有0和255的图片 2.使用基于形态学腐蚀操作和膨胀操作，分别识别横线和竖线 3.找出横线和竖线的交点，并把交点像素的位置保存起来 4.通过图片相减得到纯文字的图片，根据像素位置来分割图片 5.对分割好的图片使用cnocr文字识别识别中文，使用tesseract识别数字，并将其保存到数组中 6.将书组中的内容分别放入新的excel表格并保存，并根据名字信息对原有表格进行修改 思路具体实现 灰度读取图片&amp;amp;自适应阈值分割 灰度读取图片的目的是为了消除色彩对后续处理的影响 自适应阈值分割的目的是为了将图片的背景变为纯黑色（像素值为0），文字以及其他信息变为纯白色（像素值为255） 为什么使用阈值分割的方法？
图像分割思想：控制背景环境，降低分割难度；聚焦于感兴趣的部分。在这里其实就是将图片中的文字信息都集中起来，将图片的背景设置为黑色 基本策略：根据图像的像素灰度值的相似性来选择分割的阈值 为什么使用自适应阈值分割？
整副图像的对比度较低，存在多个目标（多个单峰灰度分布），需要使用多阈值分割方法。 自适应阈值分割的阈值选取的方法：根据图像不同区域亮度分布，计算其局部阈值，所以对于图像不同区域，能够自适应计算不同的阈值。 自适应的阈值确定方法有两种：计算某个邻域(局部)的均值、高斯加权平均(高斯滤波)来确定阈值，这里采用高斯加权平均。 二值化方法：这里采用THRESH_BINARY方法;超过阈值则设为最大像素值，不超过则设为0 形态学腐蚀 形态学腐蚀原理
使用卷积模版在图像上移动，如果发现有像素等于目标图像，就将其模板中原点的位置变成1 使用基于形态学的腐蚀和膨胀，可以将不同于该形态的区域剔除，保留相似的部分 实现
构建一个类似于横线和竖线的形态学模版，对目标图像进行腐蚀和膨胀操作，单独提取出横线和竖线 寻找横线竖线的交点 横线竖线交点寻找很简单，但因为交点的大小不一，可能一个交点包含很多个像素，但我们只需要一个。所以在选取像素的横纵坐标时需要进行特别的处理
根据交点进行图片分割 首先通过原图减去横线图和竖线图得到纯文字图片，再进行图片分割 这里的图片分割不同于上面，其代表的是字面意思，也就是根据保存好的横纵坐标选取不同的区域的图片 注意根据提取的信息，还需要对子图片再次进行分割，还有就是一些冗余信息的去除。 包含多个信息： 包含冗余信息： 中英文文字识别 为什么不自己写文字识别？因为本课程主要是为了学习opencv而不是机器学习，所以这里只调用第三方库。 中文使用cnocr库识别。 英文或数字使用tesseract程序+pytesseract库进行识别。 其中tesseract需要下载文件，下载地址：https://digi.bib.uni-mannheim.de/tesseract/ 向表格添加数据 使用openpyxl库进行excel表格的操作。 注意添加数据的函数，因为需要识别多张图片进行多次添加数据，每次添加时索引需要重新定位没有数据的第一行位置。 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 import math import cv2 as cv import openpyxl #图像二值化 &amp;#39;&amp;#39;&amp;#39; 使用自适应阈值分割： 它的思想不是计算全局图像的阈值，而是根据图像不同区域亮度分布，计算其局部阈值，所以对于图像不同区域，能够自适应计算不同的阈值，因此被称为自适应阈值法。 如何确定局部阈值呢？可以计算某个邻域(局部)的均值、中值、高斯加权平均(高斯滤波)来确定阈值。 cv2.</description>
    </item>
    
    <item>
      <title>爬虫：使用selenium模拟12306购票</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E6%8B%9F12306%E8%B4%AD%E7%A5%A8/</link>
      <pubDate>Thu, 28 Apr 2022 10:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E6%8B%9F12306%E8%B4%AD%E7%A5%A8/</guid>
      <description>使用selenium模拟12306购票 selenium介绍 selenium是一种自动化测试工具，可以通过浏览器引擎来自动化帮人类做某些事。 selenium也可以作为一种轻量化爬虫工具。优点是它能绕过网站自身加密后的源码，通过浏览器解析后来获取网页中的元素，也就是文本信息；缺点也很明显，就是它本身是通过浏览器去运行的，非常容易受浏览器访问时网络波动的影响，因此通常要设置睡眠短暂时间来等待浏览器的加载，整体效率就不高。 总体来说，selenium适合轻量化数据的爬虫。 本小程序原理介绍 通过python使用selenium自动操控浏览器引擎模拟人的购票动作。 通过第三方图像识别破解复杂验证码。（以前的12306登录有这个环节，现在取消了） 本小程序没有涉及UI界面的设计，只为学习爬虫工具，粗浅了解网页结构。 资源准备 1.谷歌浏览器（你也可以使用火狐浏览器）
2.下载谷歌浏览器驱动：
查看浏览器的版本：点击浏览器右上角的三个点按钮，找到帮助中的关于Google Chrome，点击就可以看到自己的版本号了 打开网址：https://registry.npmmirror.com/binary.html?path=chromedriver/,选择浏览器版本对应的镜像，根据操作系统来选择下载哪一个镜像 下载解压后，将文件改为chromedriver，放入python解释器所在的文件夹，也就是你python环境配置的地方，这里我使用的PyCharm,所以把它放在了我的项目目录下的bin文件中。 3.下载selenium库（哪种ok就哪种）:
1 2 pip install selenium pip install selenium -i 清华源 破解12306检测自动化控制 12306的滑窗验证会自动检测自动化测试，导致机器滑窗验证失败。
反识别自动化控制工具使用：
如果你的chrome版本小于88，在启动浏览器的时候（此时没有加载任何内容），向页面潜入js代码，去掉webdriver：
1 2 3 4 5 6 7 8 9 10 11 from selenium.webdriver import Chrome web = Chrome() web.execute_cdp_cmd(&amp;#34;Page.addScriptToEvaluateOnDocument&amp;#34;, { &amp;#34;source&amp;#34; : &amp;#34;&amp;#34;&amp;#34; navigator.webdriver = undefined Object.defineProperty(navigator, &amp;#39;webdriver&amp;#39;, { get: () =&amp;gt; undefined }) &amp;#34;&amp;#34;&amp;#34; }) 如果你的chrome版本大于88，引入option:
1 2 3 4 5 6 7 from selenium.</description>
    </item>
    
    <item>
      <title>第十讲：rb_tree深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC10%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 20 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC10%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第十讲：rb_tree深度探索 rb_tree vs AVL树 AVL是一个高度平衡的二叉树，而红黑树不是 红黑树每次插入一个元素，最多只需要两次旋转；而AVL可能需要更多次平衡操作 搜索速度：AVL树更加快，因为其严格遵守高度平衡，搜索查找的平均时间复杂度为log2(n) 插入速度：红黑树更加快，因为最多只需要两次旋转再加一些重新着色。 AVL树是rb_tree的子集 红黑树的结构 红黑树是平衡二分搜索树中常常使用的一种，平衡二分搜索树的特性：排列规则有利search和insert，并保持适度平衡。
红黑树提供遍历的功能及iterators。按正常规则（++ite）遍历，便能获得排序状态。
红黑树的结构样例：
排序的状态为红黑树的中序遍历，begin()在左下，end()是在右下
红黑树的规则(首先需要是一颗二分查找树{BST})：
1.每个节点不是红色就是黑色 2.根节点为黑色 3.如果节点为红，其子节点必须是黑（如果节点为黑，其子节点既可以是红也可以是黑） 4.任一节点至NULL(树尾端)的任何路径，所含黑色节点数必须相同 根据规则4，新增节点必须为红；根据规则3，新增节点之父节点必须为黑，当新节点根据二叉搜索树的规则到达其插入点， 但未能符合上述要求，就必须调整颜色并旋转树形
我们不应该用红黑树的iterators改变元素值（因为元素有其严谨的排序规则）。但是编程层面并未阻止此事，rb_tree将会为set和map服务，而map允许元素的data被改变， 只有元素的key才是不能被改变的。
rb_tree提供两种insertion操作（红黑树本身对重复与否没有限制，而取决于insert的方式）：insert_unique()和insert_equal()。前者表示节点的key一定在整个树中独一无二， 否则安插失败；后者表示节点的key可以重复。
部分源码（在这里将key和data合起来的节点合成value）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //这里的Value是key和data的组合，如果value只传一个值说明没有value（set） template &amp;lt;class Key, class Value, class KeyOfValue, class Compare, class Alloc = alloc&amp;gt; class rb_tree { protected: typedef __rb_tree_node&amp;lt;Value&amp;gt; rb_tree_node;//红黑树的结构 ··· public: // 注意，没有定义iterator（喔，不，定义在后面） typedef rb_tree_node* link_type;//指向红黑树节点的指针 ··· protected: //rb_tree只以三个资料表现它自己 size_type node_count;//rb_tree的大小（节点数量） link_type header; Compare key_compare;//key的大小比较准则；应会是个function object ··· } 测试rb_tree（GNU2.</description>
    </item>
    
    <item>
      <title>第九讲：deque，queue，stack深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC9%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 20 Apr 2022 18:14:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC9%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第九讲：deque，queue，stack深度探索 容器deque deque的结构和设计 deque的底层结构：
如上图所示：
deque的迭代器是一个class，内部有四个元素cur，first，last，node node指向某一个buffer，first和last分别指向这一个buffer的头部和尾部，cur指向当前元素 cur一旦走到了一个buffer的边界，则直接走到下一个buffer的开头（维持左闭右开） deque向前扩充和向后扩充都是使用buffer来进行的（之前已经讲过了） start和finish是为了维护改容器的begin()和end() 源码如下(GNU2.9)：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template&amp;lt;class T, class Alloc=alloc, size_t BufSiz=0&amp;gt; class deque { public: typedef T value_type; typedef __deque_iterator&amp;lt;T, T&amp;amp;, T*, BufSiz&amp;gt; iterator; protected: typedef pointer* map_pointer;//T** 指向指针的指针 protected: iterator start;//对应begin()的iterator类 iterator finish;//对应end()的iterator类 map_pointer map;//单个buffer size_type map_size;//控制中心的大小（也就是有多少个buffer） public: iterator begin() { return start; } iterator edn() { return finish; } size_type size() const { return finish - start; } }; 谈一谈参数的设置：如果BufSiz传入5，则为5；如果没有指定，则默认为0；如果元素大小sz大于512Bytes ，它就让一个缓冲区只放一个元素；如果小于512Bytes,则传回512/sz。（不过新版本不允许指定大小）</description>
    </item>
    
    <item>
      <title>第八讲：array和forward_list深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC8%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 19 Apr 2022 18:14:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC8%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第八讲：array和forward_list深度探索 容器array array在c中本身就存在，为什么array要成为一个容器？
array成为容器的好处：array可以使用迭代器，可以使用标准算法，更加地快捷。
使用标准array的方法：
1 2 3 4 5 array&amp;lt;int, 10&amp;gt; myArray; auto it = myArray.begin(); //array&amp;lt;int, 10&amp;gt;::iterator it = myArray.begin(); it += 3; cout &amp;lt;&amp;lt; *it; 源码如下图，较简单(TR1版本)：
forward_list 单向链表的结构与list双向链表的结构类似，可以类推。（c++11以前为slist）</description>
    </item>
    
    <item>
      <title>第七讲：vector容器深入探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC7%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 17 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC7%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第七讲：vector容器深入探索 vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。
vector扩容机制(GNU 2.9版) 从途中可以看出，有三个非常关键的指针start，finish，end_of_storage:
start指向第一个元素的内存空间，也就是begin()方法指向的内存空间。 finish指向当前使用中的最后一个元素的后一个位置的内存空间，也就是end()方法指向的内存空间！ end_of_storage指向当前最大可用空间的尾。 源码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 template &amp;lt;class T, class Alloc = alloc&amp;gt; // 預設使用 alloc 為配置器 class vector { public: // 以下標示 (1),(2),(3),(4),(5)，代表 iterator_traits&amp;lt;I&amp;gt; 所服務的5個型別。 typedef T value_type;	// (1) typedef value_type* pointer; // (2) typedef const value_type* const_pointer; typedef const value_type* const_iterator; typedef value_type&amp;amp; reference; // (3) typedef const value_type&amp;amp; const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; // (4) // 以下，由於vector 所維護的是一個連續線性空間，所以不論其元素型別為何， // 原生指標都可以做為其迭代器而滿足所有需求。 typedef value_type* iterator; /* 根據上述寫法，如果客端寫出這樣的碼： vector&amp;lt;Shape&amp;gt;::iterator is; is 的型別其實就是Shape* 而STL 內部運用 iterator_traits&amp;lt;is&amp;gt;::reference 時，獲得 Shape&amp;amp; 運用iterator_traits&amp;lt;is&amp;gt;::iterator_category 時，獲得 random_access_iterator_tag	(5) （此乃iterator_traits 針對原生指標的特化結果） */ // vector採用簡單的線性連續空間。以兩個迭代器start和end分別指向頭尾， // 并以迭代器end_of_storage指向容量尾端。容量可能比(尾-头)还大 protected: iterator start; iterator finish; iterator end_of_storage; public: iterator begin() { return start; } const_iterator begin() const { return start; } iterator end() { return finish; } /*通过函数相减有利于后期修改指针时，不需要修改size()方法*/ size_type size() const { return size_type(end() - begin()); } /*capacity代表最大容量*/ size_type capacity() const { return size_type(end_of_storage - begin()); } bool empty() const { return begin() == end(); } /*连续空间的容器都会有[]的运算符重载*/ reference operator[](size_type n) { return *(begin() + n); } // 取出第一個元素內容 reference front() { return *begin(); } // 取出最後一個元素內容 reference back() { return *(end() - 1); } } 通过push_back()方法来看扩容机制：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 24 章 制作 HTTP 服务器端 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-24-%E7%AB%A0-%E5%88%B6%E4%BD%9C-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 13 Apr 2022 20:16:48 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-24-%E7%AB%A0-%E5%88%B6%E4%BD%9C-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 24 章 制作 HTTP 服务器端 24.1 HTTP 概要 本章将编写 HTTP（HyperText Transfer Protocol，超文本传输协议）服务器端，即 Web 服务器端。
24.1.1 理解 Web 服务器端 web服务器端就是要基于 HTTP 协议，将网页对应文件传输给客户端的服务器端。
24.1.2 HTTP 无状态的 Stateless 协议
从上图可以看出，服务器端相应客户端请求后立即断开连接。换言之，服务器端不会维持客户端状态。即使同一客户端再次发送请求，服务器端也无法辨认出是原先那个，而会以相同方式处理新请求。因此，HTTP 又称「无状态的 Stateless 协议」
24.1.3 请求消息（Request Message）的结构 下面是客户端向服务端发起请求消息的结构：
从图中可以看出，请求消息可以分为请求头、消息头、消息体 3 个部分。其中，请求行含有请求方式（请求目的）信息。典型的请求方式有 GET 和 POST ，GET 主要用于请求数据，POST 主要用于传输数据。为了降低复杂度，我们实现只能响应 GET 请求的 Web 服务器端，下面解释图中的请求行信息。其中「GET/index.html HTTP/1.1」 具有如下含义：
请求（GET）index.html 文件，通常以 1.1 版本的 HTTP 协议进行通信。
请求行只能通过 1 行（line）发送，因此，服务器端很容易从 HTTP 请求中提取第一行，并分别分析请求行中的信息。
请求行下面的消息头中包含发送请求的浏览器信息、用户认证信息等关于 HTTP 消息的附加信息。最后的消息体中装有客户端向服务端传输的数据，为了装入数据，需要以 POST 方式发送请求。但是我们的目标是实现 GET 方式的服务器端，所以可以忽略这部分内容。另外，消息体和消息头与之间以空行隔开，因此不会发生边界问题
24.1.4 响应消息（Response Message）的结构 下面是 Web 服务器端向客户端传递的响应信息的结构。从图中可以看出，该响应消息由状态行、头信息、消息体等 3 个部分组成。状态行中有关于请求的状态信息，这是与请求消息相比最为显著地区别。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 18 章 多线程服务器端的实现 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-18-%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 10 Apr 2022 16:05:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-18-%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 18 章 多线程服务器端的实现 18.1 理解线程的概念 18.1.1 引入线程背景 第 10 章介绍了多进程服务端的实现方法。多进程模型与 select 和 epoll 相比的确有自身的优点，但同时也有问题。如前所述，创建（复制）进程的工作本身会给操作系统带来相当沉重的负担。而且，每个进程都具有独立的内存空间，所以进程间通信的实现难度也会随之提高。换言之，多进程的缺点可概括为：
创建进程的过程会带来一定的开销 为了完成进程间数据交换，需要特殊的 IPC 技术。 但是更大的缺点是下面的：
每秒少则 10 次，多则千次的「上下文切换」是创建进程的最大开销 只有一个 CPU 的系统是将时间分成多个微小的块后分配给了多个进程。为了分时使用 CPU ，需要「上下文切换」的过程。「上下文切换」是指运行程序前需要将相应进程信息读入内存，如果运行进程 A 后紧接着需要运行进程 B ，就应该将进程 A 相关信息移出内存，并读入进程 B 相关信息。这就是上下文切换。但是此时进程 A 的数据将被移动到硬盘，所以上下文切换要很长时间，即使通过优化加快速度，也会存在一定的局限。
为了保持多进程的优点，同时在一定程度上克服其缺点，人们引入的线程（Thread）的概念。这是为了将进程的各种劣势降至最低程度（不是直接消除）而设立的一种「轻量级进程」。线程比进程具有如下优点：
线程的创建和上下文切换比进程的创建和上下文切换更快 线程间交换数据无需特殊技术 18.1.2 线程和进程的差异 线程是为了解决：为了得到多条代码执行流而复制整个内存区域的负担太重。
每个进程的内存空间都由保存全局变量的「数据区」、向 malloc 等函数动态分配提供空间的堆（Heap）、函数运行时间使用的栈（Stack）构成。每个进程都有独立的这种空间，多个进程的内存结构如图所示：
但如果以获得多个代码执行流为目的，则不应该像上图那样完全分离内存结构，而只需分离栈区域。通过这种方式可以获得如下优势：
上下文切换时不需要切换数据区和堆 可以利用数据区和堆交换数据 实际上这就是线程。线程为了保持多条代码执行流而隔开了栈区域，因此具有如下图所示的内存结构：
如图所示，多个线程共享数据区和堆。为了保持这种结构，线程将在进程内创建并运行。也就是说，进程和线程可以定义为如下形式：
进程：在操作系统构成单独执行流的单位 线程：在进程构成单独执行流的单位 如果说进程在操作系统内部生成多个执行流，那么线程就在同一进程内部创建多条执行流。因此，操作系统、进程、线程之间的关系可以表示为下图：
18.2 线程创建及运行 可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。
Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。
微软的Windows NT声称部分实现了POSIX标准。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 17 章 优于 select 的 epoll 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-17-%E7%AB%A0-%E4%BC%98%E4%BA%8E-select-%E7%9A%84-epoll-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 09 Apr 2022 19:06:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-17-%E7%AB%A0-%E4%BC%98%E4%BA%8E-select-%E7%9A%84-epoll-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 17 章 优于 select 的 epoll 17.1 epoll 理解及应用 select 复用方法由来已久，因此，利用该技术后，无论如何优化程序性能也无法同时介入上百个客户端。这种 select 方式并不适合以 web 服务器端开发为主流的现代开发环境，所以需要学习 Linux 环境下的 epoll
17.1.1 基于 select 的 I/O 复用技术速度慢的原因 第 12 章实现了基于 select 的 I/O 复用技术服务端，其中有不合理的设计如下：
调用 select 函数后常见的针对所有文件描述符的循环语句 每次调用 select 函数时都需要向该函数传递监视对象信息 上述两点可以从 echo_selectserv.c 得到确认，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54,56行），因此无法避免针对所有监视对象的循环语句。而且，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息。
select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。select 函数的这一缺点可以通过如下方式弥补：
仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项
这样就无需每次调用 select 函数时都想操作系统传递监视对象信息，但是前提操作系统支持这种处理方式。Linux 的支持方式是 epoll ，Windows 的支持方式是 IOCP。
17.1.2 select 也有有点 select 的兼容性比较高，这样就可以支持很多的操作系统，不受平台的限制，使用 select 函数满足以下两个条件：</description>
    </item>
    
    <item>
      <title>第六讲：迭代器设计的原则&amp;iterator traits的作用与设计</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC6%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC6%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第六讲：迭代器设计的原则&amp;amp;iterator traits的作用与设计 iterator traits iterator traits是为了提取出迭代器的特点，迭代器必须有能力回答algorithm提出的问题。
c++标准库设计了5种回答方式,集成在class中（迭代器相关的类型，迭代器模版中本身必须定义出来）：
iterator_category：迭代器的类型，具体表现在能否++或者&amp;ndash;或者一下加减很多步 difference_type：代表两个iterator的距离应该用什么type来表现（随机访问：unsign interger，实现链表的都用ptrdiff_t类型） value_type：iterator所指元素的类型 reference：引用（暂未使用） pointer：指针（暂未使用） 但如果iterator本身不是class，例如native pointer（退化的iterator），如何回答算法的5个问题？
iterator traits用于分离class iiterators和non-class iterators</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 16 章 关于 I/O 流分离的其他内容 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-16-%E7%AB%A0-%E5%85%B3%E4%BA%8E-i-o-%E6%B5%81%E5%88%86%E7%A6%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 14:38:38 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-16-%E7%AB%A0-%E5%85%B3%E4%BA%8E-i-o-%E6%B5%81%E5%88%86%E7%A6%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 16 章 关于 I/O 流分离的其他内容 16.1 分离 I/O 流 「分离 I/O 流」是一种常用表达。有 I/O 工具可区分二者，无论采用哪种方法，都可以认为是分离了 I/O 流。
16.1.1 2次 I/O 流分离 之前有两种分离方法：
第一种是第 10 章的「TCP I/O 过程」分离。通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符。虽然文件描述符本身不会根据输入和输出进行区分，但我们分开了 2 个文件描述符的用途，因此，这也属于「流」的分离。 第二种分离是在第 15 章。通过 2 次 fdopen 函数的调用，创建读模式 FILE 指针（FILE 结构体指针）和写模式 FILE 指针。换言之，我们分离了输入工具和输出工具，因此也可视为「流」的分离。下面是分离的理由。 16.1.2 分离「流」的好处 首先是第 10 章「流」的分离目的：
通过分开输入过程（代码）和输出过程降低实现难度 与输入无关的输出操作可以提高速度 下面是第 15 章「流」分离的目的：
为了将 FILE 指针按读模式和写模式加以区分 可以通过区分读写模式降低实现难度 通过区分 I/O 缓冲提高缓冲性能 16.1.3 「流」分离带来的 EOF 问题 第 7 章介绍过 EOF 的传递方法和半关闭的必要性。有一个语句：
1 shutdown(sock,SHUT_WR); 当时说过调用 shutdown 函数的基于半关闭的 EOF 传递方法。第十章的 echo_mpclient.</description>
    </item>
    
    <item>
      <title>第五讲：深入理解容器</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC5%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 13:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC5%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第五讲：深入理解容器 容器的结构再分类 heap 和 priority_queue中有vector的结构 stack 和 queue中有deque的结构 set 和 map系列有rb_tree的结构 unordered系列容器中有hashtable的结构 在c++11中：slist &amp;ndash;&amp;gt; forward_list； hash_~ &amp;ndash;&amp;gt; unordered_~。 深度探索list list（环状双向链表）其本身是一个指针，指向一个node节点，其结构为两个指针（一个向前一个向后）+数据值
1 sizeof(list&amp;lt;int&amp;gt;()) //其值为4Bytes（GNU2.9） 8Bytes(GNU4.9) list的结构 node的设计（GNU2.9）： 1 2 3 4 5 6 7 tempalate&amp;lt;class T&amp;gt; struct __list_node { typedef void* void_pointer;//一个空的指针置于尾端的一个空白节点，符合&amp;#34;前闭后开&amp;#34;的要求 void_pointer prev;//向前的指针 void_pointer next;//向后的指针 T data;//数据 }; iterator的设计（GNU2.9）： 1 2 3 4 5 6 7 8 tempalte&amp;lt;class T, class Ref, class Ptr&amp;gt; struct __list_iterator { typedef T value_type; typedef Ptr pointer; typedef Ref reference; ··· //具体看《STL源码剖析》p131 }; G4.</description>
    </item>
    
    <item>
      <title>第四讲：深入理解分配器</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC4%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 10:54:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC4%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第四讲：深入理解分配器 operator new() &amp;amp; malloc() operator() new会调用malloc(), malloc()作用是分配内存。
看图：
size部分为我们所需要的内存，可以看出malloc()分配的内存比所需要的内存多。多分配的内存空间如果称为开销的话，也就是说我们的单个内存越大，开销所占比例就越小！
分配器最重要的两个函数：allocate &amp;amp; deallocate VC++下和BC++下：
申请内存：allocator--&amp;gt;operator new()--&amp;gt;malloc() 释放内存：deallocator--&amp;gt;operator delete()--&amp;gt;free() 分配512个int整数：
1 2 int *p = allocator&amp;lt;int&amp;gt;().allocate(512, (int*)0); allocator&amp;lt;int&amp;gt;().deallocate(p, 512); 注：一个type +（）形成了一个临时对象，才能调用其中的成员函数。举例：queue&amp;lt;int&amp;gt;()
alloc的优点 GNU2.9下：
申请内存：allocator--&amp;gt;allocate()--&amp;gt;operator new()--&amp;gt;malloc() 释放内存：deallocator--&amp;gt;deallocate()-&amp;gt;operator delete()--&amp;gt;free() 注：虽然GNU标准allocator被设计出来，但它的容器基本都不用标准的allocator，而是使用alloc
使用malloc()和free()会带来很大的额外开销，如果区块小，开销比例会很大。 额外开销中的cookie记录内存的大小，但因为容器元素的大小是一样的，所以alloc使用一个长链表（i = 0～15），第i个对应cookie大小为8(i + 1)Bytes的内存大小，容器的内存大小会被调整为8的倍数，这样就只需要用少量cookie来记录内存大小！ 所以使用alloc存放1000000个元素，可以省掉cookie开销大约8000000个Bytes GNU4.9下：
容器使用的分配器又变为了allocator，继承于new_allocator，使用operator new() 和 operator delete() 4.9下的alloc被更名为__pool_alloc，属于__gnu_cxx::__pool_alloc </description>
    </item>
    
    <item>
      <title>第三讲:泛型编程和模版技术</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC3%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 15:21:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC3%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第三讲:泛型编程和模版技术 源代码之分布 VC的标准库文件夹: GNU c++标准库文件夹: OOP(面向对象编程) vs GP(泛型编程) OOP将datas和methods关联在一起（成员变量和成员函数都放在类里面） demo:list内部本身存在有sort()算法，使用语法如下：
1 c.sort() GP是将datas和methods分开来
demo：vector和deque内部都没有sort()函数，sort()函数是放在算法里面的，使用语法如下：
1 ::sort(c.begin(), c.end()); 注：list本身是链式容器，无法支持随机访问，所以需要本身自己重新定义sort()。
采用GP的好处：
容器和算法团队可以各自写自己的东西，其间用迭代器来进行关联。 算法通过迭代器确定操作范围，并通过迭代器取用容器的元素。 两个石头如何比较大小不需要类来决定，而是用仿函数来决定。 max()算法的demo：
第二个版本的参数3接收的是函数对象或者是仿函数，用于自定义的比较规则制定！
操作符重载复习 操作符操作单个数或者多个数，以及能否成为类内部的成员函数
模版Template复习 类模版: 函数模版: 成员模版 模版中泛化 vs 特化 泛化的特点是可以接收大多数type的数据结构 特化的特点是为了某些特殊的数据（数据有不同的特点）进行的模版中特殊化的写法 demo:
特化中的偏特化（局部特化） 个数的偏特化: 范围的偏特化： </description>
    </item>
    
    <item>
      <title>第二讲:容器之分类及各种测试</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC2%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 10:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC2%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第二讲:容器之分类及各种测试 容器结构及分类 序列式容器 数组（Array）：定长数组，无法扩充 vector：可扩充的数组（分配器做内存扩充） Deque：双端队列 List：双向链表 Forward-List：单向链表 关联式容器（key-&amp;gt;value） Set/Multiset（Multiset中的值可以重复）：内部为红黑数 Map/Multimap（Multimap中的value值可以重复）：内部为红黑树 无序容器（unordered,大类上属于关联式容器） 介绍一个常用的结构hashtable：根据公式进行分类， 但会产生碰撞， 产生碰撞的元素全部放在一个链表中。但如果链表太长如何做呢？后面会继续介绍。
先写用于测试的几个辅助函数:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 using std::cin; using std::cout; using std::string; long get_a_target_long() { long target = 0; cout &amp;lt;&amp;lt; &amp;#34;target (0~&amp;#34; &amp;lt;&amp;lt; RAND_MAX &amp;lt;&amp;lt; &amp;#34;):&amp;#34;; return target; } string get_a_target_string() { long target = 0; char buf[10]; cout &amp;lt;&amp;lt; &amp;#34;target (0~&amp;#34; &amp;lt;&amp;lt; RAND_MAX &amp;lt;&amp;lt; &amp;#34;):&amp;#34;; cin &amp;gt;&amp;gt; target; //snprintf功能为格式化成字符串 // 1-- 目标字符串 2 -- 拷贝字节数 3 -- 格式化成字符串。4 -- 可变参数。 snprintf(buf, 10, &amp;#34;%d&amp;#34;, target); return string(buf); } //比较两个long数据是否相等 int compareLongs(const void* a, const void* b) { return (*(long*)a - *(long*)b); } //比较两个string数据是否相等 int compareStrings(const void* a, const void* b) { if(*(string*)a &amp;gt; *(string*)b) return 1; else if(*(string*)a &amp;lt; *(string*)b) return -1; else return 0; } 顺序容器使用及测试 使用容器array：array.</description>
    </item>
    
    <item>
      <title>第一讲:STL体系结构介绍</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC1%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 08:15:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC1%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第一讲:STL体系结构介绍 c++标准库 vs c++ Standard Library 总体来说 c++标准库 &amp;gt; c++ Standard Library
标准库以头文件（.h）的形式呈现:
c++标准库的header files不带副档名（.h）, 例如#include 新式c header files 不带副档名（.h），例如 #include 旧式c header files 带有副档名（.h）仍然可用，例如 #include &amp;lt;stdio.h&amp;gt; 新式headers内的组件封装为 namespace &amp;ldquo;std&amp;rdquo; using namespace std;（相当于把std文件全部打开） using std::cout; 旧式headers内的组件不封装在namespace &amp;ldquo;std&amp;rdquo; demo：
1 2 3 4 5 6 #include &amp;lt;string&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;functional&amp;gt; using namespace std; 重要的网站（c++标准库） cplusplus.com cppreference.com gcc.gnu.org STL六大部件 容器（containers） 分配器（allocators） 算法（algorithms） 迭代器（iterators） 适配器（addpters） 仿函数（functors） 六大部件的关系：
容器可以使我们不用管c++的内存，分配器支持容器进行内存管理。 容器的数据操作使用算法，访问数据使用迭代器，迭代器（类似于指针）是算法操作容器内部数据的桥梁。 仿函数类似于函数，暂时可以用函数来理解。 适配器是用来转换的，可以对容器，仿函数，迭代器进行转换。 模版编程和面向对象编程的区别</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 15 章 套接字和标准I/O 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-15-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%A0%87%E5%87%86i-o-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 06 Apr 2022 17:53:25 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-15-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%A0%87%E5%87%86i-o-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 15 章 套接字和标准I/O 15.1 标准 I/O 的优点 15.1.1 标准 I/O 函数的两个优点 下面是标准 I/O 函数的两个优点：
标准 I/O 函数具有良好的移植性 标准 I/O 函数可以利用缓冲提高性能 创建套接字时，操作系统会准备 I/O 缓冲。此缓冲在执行 TCP 协议时发挥着非常重要的作用。此时若使用标准 I/O 函数，将得到额外的缓冲支持。如下图：
假设使用 fputs 函数进行传输字符串 「Hello」时，首先将数据传递到标准 I/O 缓冲，然后将数据移动到套接字输出缓冲，最后将字符串发送到对方主机。
设置缓冲的主要目的是为了提高性能。从以下两点可以说明性能的提高：
传输的数据量 数据向输出缓冲移动的次数。 比较 1 个字节的数据发送 10 次的情况和 10 个数据包发送 1 次的情况。发送数据时，数据包中含有头信息。头信与数据大小无关，是按照一定的格式填入的。假设头信息占 40 个字节，需要传输的数据量也存在较大区别：
1 个字节 10 次：40*10=400 字节 10个字节 1 次：40*1=40 字节。 15.1.2 标准 I/O 函数和系统函数之间的性能对比 下面是利用系统函数的示例：
syscpy.c 下面是使用标准 I/O 函数复制文件
stdcpy.c 对于以上两个代码进行测试，明显基于标准 I/O 函数的代码跑的更快</description>
    </item>
    
    <item>
      <title>《模式识别&amp;机器学习》课后作业（2）</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A2/</link>
      <pubDate>Tue, 05 Apr 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A2/</guid>
      <description>《模式识别&amp;amp;机器学习》课后作业 作业二 根据最小均方误差算法（hk算法）对0~9的中任意两个数进行分类。
代码实现 h_k.m:(主函数) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 %h_k.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 14 章 多播与广播 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-14-%E7%AB%A0-%E5%A4%9A%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 05 Apr 2022 13:54:59 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-14-%E7%AB%A0-%E5%A4%9A%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 14 章 多播与广播 14.1 多播 多播（Multicast）方式的数据传输是基于 UDP 完成的。因此 ，与 UDP 服务器端/客户端的实现方式非常接近。区别在于，UDP 数据传输以单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，可以同时向多个主机传递数据。
14.1.1 多播的数据传输方式以及流量方面的优点 多播的数据传输特点可整理如下：
多播服务器端针对特定多播组，只发送 1 次数据。 即使只发送 1 次数据，但该组内的所有客户端都会接收数据 多播组数可以在 IP 地址范围内任意增加 多播组是 D 类IP地址（224.0.0.0~239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明：
在 D 类IP地址中，我希望接收发往目标 239.234.218.234 的多播数据
多播是基于 UDP 完成的，也就是说，多播数据包的格式与 UDP 数据包相同。只是与一般的 UDP 数据包不同。向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如图所示：
若通过 TCP 或 UDP 向 1000 个主机发送文件，则共需要传递 1000 次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由 1000 台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。
另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。
14.1.2 路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法 为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 13 章 多种 I/O 函数 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-13-%E7%AB%A0-%E5%A4%9A%E7%A7%8D-i-o-%E5%87%BD%E6%95%B0-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 04 Apr 2022 23:08:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-13-%E7%AB%A0-%E5%A4%9A%E7%A7%8D-i-o-%E5%87%BD%E6%95%B0-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 13 章 多种 I/O 函数 13.1 send &amp;amp; recv 函数 13.1.1 Linux 中的 send &amp;amp; recv 首先看 sned 函数定义：
1 2 3 4 5 6 7 8 9 #include &amp;lt;sys/socket.h&amp;gt; ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags); /* 成功时返回发送的字节数，失败时返回 -1 sockfd: 表示与数据传输对象的连接的套接字和文件描述符 buf: 保存带传输数据的缓冲地址值 nbytes: 待传输字节数 flags: 传输数据时指定的可选项信息 */ 下面是 recv 函数的定义：
1 2 3 4 5 6 7 8 9 #include &amp;lt;sys/socket.h&amp;gt; ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); /* 成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1 sockfd: 表示数据接受对象的连接的套接字文件描述符 buf: 保存接受数据的缓冲地址值 nbytes: 可接收的最大字节数 flags: 接收数据时指定的可选项参数 */ send 和 recv 函数都是最后一个参数是收发数据的可选项，该选项可以用位或（bit OR）运算符（| 运算符）同时传递多个信息。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 12 章 I/O 复用 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-12-%E7%AB%A0-i-o-%E5%A4%8D%E7%94%A8-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 02 Apr 2022 17:38:29 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-12-%E7%AB%A0-i-o-%E5%A4%8D%E7%94%A8-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 12 章 I/O 复用 12.1 基于 I/O 复用的服务器端 12.1.1 多进程服务端的缺点和解决方法 为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程要付出很大的代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法）
I/O 复用技术可以解决这个问题。
12.1.2 理解复用 「复用」在电子及通信工程领域很常见，向这些领域的专家询问其概念，可能会得到如下答复：
在 1 个通信频道中传递多个数据（信号）的技术
「复用」的含义：
为了提高物理设备的效率，只用最少的物理要素传递最多数据时使用的技术
上述两种方法的内容完全一致。可以用纸电话模型做一个类比：
上图是一个纸杯电话系统，为了使得三人同时通话，说话时要同事对着两个纸杯，接听时也需要耳朵同时对准两个纸杯。为了完成 3 人通话，可以进行如下图的改进：
如图做出改进，就是引入了复用技术。
复用技术的优点：
减少连线长度 减少纸杯个数 即使减少了连线和纸杯的量仍然可以进行三人同时说话，但是如果碰到以下情况：
「好像不能同时说话？」
实际上，因为是在进行对话，所以很少发生同时说话的情况。也就是说，上述系统采用的是**「时分复用」**技术。因为说话人声频率不同，即使在同时说话也能进行一定程度上的区分（杂音也随之增多）。因此，也可以说是「频分复用技术」。
12.1.3 复用技术在服务器端的应用 纸杯电话系统引入复用技术之后可以减少纸杯数量和连线长度。服务器端引入复用技术可以减少所需进程数。下图是多进程服务端的模型：
下图是引入复用技术之后的模型：
从图上可以看出，引入复用技术之后，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有一个。
12.2 理解 select 函数并实现服务端 select 函数是最具代表性的实现复用服务器的方法。在 Windows 平台下也有同名函数，所以具有很好的移植性。
12.2.1 select 函数的功能和调用顺序 使用 select 函数时可以将多个文件描述符集中到一起统一监视，项目如下：
是否存在套接字接收数据？ 无需阻塞传输数据的套接字有哪些？ 哪些套接字发生了异常？ 术语：「事件」。当发生监视项对应情况时，称「发生了事件」。
select 函数的使用方法与一般函数的区别并不大，更准确的说，他很难使用。但是为了实现 I/O 复用服务器端，我们应该掌握 select 函数，并运用于套接字编程当中。认为「select 函数是 I/O 复用的全部内容」也并不为过。select 函数的调用过程如下图所示：
12.2.2 设置文件描述符 利用 select 函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集中在一起。集中时也要按照监视项（接收、传输、异常）进行区分，即按照上述 3 种监视项分成 3 类。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 11 章 进程间通信 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-11-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 01 Apr 2022 11:40:18 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-11-%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 11 章 进程间通信 进程间通信，意味着两个不同的进程中可以交换数据
11.1 进程间通信的基本概念 11.1.1 通过管道实现进程间通信 下图是基于管道（PIPE）的进程间通信的模型：
可以看出，为了完成进程间通信，需要创建进程。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是 fork 函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。下面是创建管道的函数。
1 2 3 4 5 6 7 #include &amp;lt;unistd.h&amp;gt; int pipe(int filedes[2]); /* 成功时返回 0 ，失败时返回 -1 filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口 filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口 */ 父进程创建函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。下面的例子是关于该函数的使用方法：
pipe1.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str[] = &amp;#34;Who are you?</description>
    </item>
    
    <item>
      <title>《模式识别&amp;机器学习》课后作业（1）</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A1/</link>
      <pubDate>Thu, 31 Mar 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A1/</guid>
      <description>《模式识别&amp;amp;机器学习》课后作业 作业一 写一个感知器算法，用来区分1到10里的任意两个数字，并与真实结果进行比较。
代码实现 Perceptron.m(主函数)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 %Perceptron.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 10 章 多进程服务器端 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-10-%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 30 Mar 2022 15:59:25 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-10-%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 10 章 多进程服务器端 10.1 进程概念及应用 10.1.1 并发服务端的实现方法 通过改进服务端，使其同时向所有发起请求的客户端提供服务，以提高平均满意度。而且，网络程序中数据通信时间比 CPU 运算时间占比更大，因此，向多个客户端提供服务是一种有效的利用 CPU 的方式。接下来讨论同时向多个客户端提供服务的并发服务器端。下面列出的是具有代表性的并发服务端的实现模型和方法：
多进程服务器：通过创建多个进程提供服务 多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务 多线程服务器：通过生成与客户端等量的线程提供服务 先是第一种方法：多进程服务器
10.1.2 理解进程 进程的定义如下：
占用内存空间的正在运行的程序
假如你下载了一个游戏到电脑上，此时的游戏不是进程，而是程序。只有当游戏被加载到主内存并进入运行状态，这是才可称为进程。
10.1.3 进程 ID 在说进程创建方法之前，先要简要说明进程 ID。无论进程是如何创建的，所有的进程都会被操作系统分配一个 ID。此 ID 被称为「进程ID」，其值为大于 2 的证书。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。
1 ps au 通过上面的命令可查看当前运行的所有进程。需要注意的是，该命令同时列出了 PID（进程ID）。参数 a 和 u列出了所有进程的详细信息。
10.1.4 通过调用 fork 函数创建进程 创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。
1 2 3 #include &amp;lt;unistd.h&amp;gt; pid_t fork(void); // 成功时返回进程ID,失败时返回 -1 fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都执行 fork 函数调用后的语句（准确的说是在 fork 函数返回后）。但因为是通过同一个进程、复制相同的内存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特点区分程序执行流程。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 9 章 套接字的多种可选项 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-9-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 29 Mar 2022 17:37:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-9-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 9 章 套接字的多种可选项 9.1 套接字可选项和 I/O 缓冲大小 我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也很重要
9.1.1 套接字多种可选项 我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。
协议层 选项名 读取 设置 SOL_SOCKET SO_SNDBUF O O SOL_SOCKET SO_RCVBUF O O SOL_SOCKET SO_REUSEADDR O O SOL_SOCKET SO_KEEPALIVE O O SOL_SOCKET SO_BROADCAST O O SOL_SOCKET SO_DONTROUTE O O SOL_SOCKET SO_OOBINLINE O O SOL_SOCKET SO_ERROR O X SOL_SOCKET SO_TYPE O X IPPROTO_IP IP_TOS O O IPPROTO_IP IP_TTL O O IPPROTO_IP IP_MULTICAST_TTL O O IPPROTO_IP IP_MULTICAST_LOOP O O IPPROTO_IP IP_MULTICAST_IF O O IPPROTO_TCP TCP_KEEPALIVE O O IPPROTO_TCP TCP_NODELAY O O IPPROTO_TCP TCP_MAXSEG O O 从表中可以看出，套接字可选项是分层的。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 8 章 域名及网络地址 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-8-%E7%AB%A0-%E5%9F%9F%E5%90%8D%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 28 Mar 2022 18:09:27 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-8-%E7%AB%A0-%E5%9F%9F%E5%90%8D%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 8 章 域名及网络地址 8.1 域名系统 DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器
8.1.1 什么是域名 域名就是我们常常在地址栏里面输入的地址，将比较难记忆的IP地址变成人类容易理解的信息。
8.1.2 DNS 服务器 相当于一个字典，可以查询出某一个域名对应的IP地址
如图所示，显示了 DNS 服务器的查询路径。
8.2 IP地址和域名之间的转换 8.2.1 程序中有必要使用域名吗？ 一句话，需要，因为IP地址可能经常改变，而且也不容易记忆，通过域名可以随时更改解析，达到更换IP的目的
8.2.2 利用域名获取IP地址 使用以下函数可以通过传递字符串格式的域名获取IP地址
1 2 3 4 5 #include &amp;lt;netdb.h&amp;gt; struct hostent *gethostbyname(const char *hostname); /* 成功时返回 hostent 结构体地址，失败时返回 NULL 指针 */ 这个函数使用方便，只要传递字符串，就可以返回域名对应的IP地址。只是返回时，地址信息装入 hostent 结构体。此结构体的定义如下：
1 2 3 4 5 6 7 8 struct hostent { char *h_name; /* Official name of host. */ char **h_aliases; /* Alias list.</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 7 章 优雅的断开套接字的连接 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-7-%E7%AB%A0-%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%AD%E5%BC%80%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 26 Mar 2022 11:25:41 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-7-%E7%AB%A0-%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%AD%E5%BC%80%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 7 章 优雅的断开套接字的连接 本章讨论如何优雅的断开套接字的连接，之前用的方法不够优雅是因为，我们是调用 close 函数或 closesocket 函数单方面断开连接的。
7.1 基于 TCP 的半关闭 TCP 的断开连接过程比建立连接更重要，因为连接过程中一般不会出现大问题，但是断开过程可能发生预想不到的情况。因此应该准确掌控。所以要掌握半关闭（Half-close），才能明确断开过程。
7.1.1 单方面断开连接带来的问题 Linux 和 Windows 的 closesocket 函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。因此在某些情况下，通信一方单方面的断开套接字连接，显得不太优雅。如图所示：
图中描述的是 2 台主机正在进行双向通信，主机 A 发送完最后的数据后，调用 close 函数断开了最后的连接，之后主机 A 无法再接受主机 B 传输的数据。实际上，是完全无法调用与接受数据相关的函数。最终，由主机 B 传输的、主机 A 必须要接受的数据也销毁了。
为了解决这类问题，「只关闭一部分数据交换中使用的流」的方法应运而生。断开一部分连接是指，可以传输数据但是无法接收，或可以接受数据但无法传输。顾名思义就是只关闭流的一半。
7.1.2 套接字和流（Stream） 两台主机通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看作一种流。
此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也止呕能向一个方向流动。因此，为了进行双向通信，需要如图所示的两个流：
一旦两台主机之间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一个主机的输出流相连，而输出流则与另一个主机的输入流相连。另外，本章讨论的「优雅的断开连接方式」只断开其中 1 个流，而非同时断开两个流。Linux 和 Windows 的 closesocket 函数将同时断开这两个流，因此与「优雅」二字还有一段距离。
7.1.3 针对优雅断开的 shutdown 函数 shutdown 用来关闭其中一个流：
1 2 3 4 5 6 7 #include &amp;lt;sys/socket.h&amp;gt; int shutdown(int sock, int howto); /* 成功时返回 0 ，失败时返回 -1 sock: 需要断开套接字文件描述符 howto: 传递断开方式信息 */ 调用上述函数时，第二个参数决定断开连接的方式，其值如下所示：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 6 章 基于 UDP 的服务端/客户端 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-6-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 25 Mar 2022 16:10:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-6-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 6 章 基于 UDP 的服务端/客户端 TCP 是内容较多的一个协议，而本章中的 UDP 内容较少，但是也很重要。
6.1 理解 UDP 6.1.1 UDP 套接字的特点 通过寄信来说明 UDP 的工作原理，这是讲解 UDP 时使用的传统示例，它与 UDP 的特点完全相同。寄信前应现在信封上填好寄信人和收信人的地址，之后贴上邮票放进邮筒即可。当然，信件的特点使我们无法确认信件是否被收到。邮寄过程中也可能发生信件丢失的情况。也就是说，信件是一种不可靠的传输方式，UDP 也是一种不可靠的数据传输方式。
因为 UDP 没有 TCP 那么复杂，所以编程难度比较小，性能也比 TCP 高。在更重视性能的情况下可以选择 UDP 的传输方式。
TCP 与 UDP 的区别很大一部分来源于流控制。也就是说 TCP 的生命在于流控制。
6.1.2 UDP 的工作原理 如图所示：
从图中可以看出，IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。
6.1.3 UDP 的高效使用 UDP 也具有一定的可靠性。对于通过网络实时传递的视频或者音频时情况有所不同。对于多媒体数据而言，丢失一部分数据也没有太大问题，这只是会暂时引起画面抖动，或者出现细微的杂音。但是要提供实时服务，速度就成为了一个很重要的因素。因此流控制就显得有一点多余，这时就要考虑使用 UDP 。TCP 比 UDP 慢的原因主要有以下两点：</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 5 章 基于 TCP 的服务端/客户端（2） 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-5-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF2-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 24 Mar 2022 15:57:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-5-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF2-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 5 章 基于 TCP 的服务端/客户端（2） 上一章仅仅是从编程角度学习实现方法，并未详细讨论 TCP 的工作原理。因此，本章将想次讲解 TCP 中必要的理论知识，还将给出第 4 章客户端问题的解决方案。
5.1 回声客户端的完美实现 5.1.1 回声服务器没有问题，只有回声客户端有问题？ 问题不在服务器端，而在客户端，只看代码可能不好理解，因为 I/O 中使用了相同的函数。先回顾一下服务器端的 I/O 相关代码：
1 2 while ((str_len = read(clnt_sock, message, BUF_SIZE)) != 0) write(clnt_sock, message, str_len); 接着是客户端代码:
1 2 write(sock, message, strlen(message)); str_len = read(sock, message, BUF_SIZE - 1); 二者都在村换调用 read 和 write 函数。实际上之前的回声客户端将 100% 接受字节传输的数据，只不过接受数据时的单位有些问题。扩展客户端代码回顾范围，下面是，客户端的代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 while (1) { fputs(&amp;#34;Input message(Q to quit): &amp;#34;, stdout); fgets(message, BUF_SIZE, stdin); if (!</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 4 章 基于 TCP 的服务端/客户端（1） 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-4-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF1-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 20 Mar 2022 13:10:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-4-%E7%AB%A0-%E5%9F%BA%E4%BA%8E-tcp-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF1-%E7%AC%94%E8%AE%B0/</guid>
      <description>第 4 章 基于 TCP 的服务端/客户端（1） 4.1 理解 TCP 和 UDP 根据数据传输方式的不同，基于网络协议的套接字一般分为 TCP 套接字和 UDP 套接字。因为 TCP 套接字是面向连接的，因此又被称为基于流（stream）的套接字。
TCP 是 Transmission Control Protocol （传输控制协议）的简写，意为「对数据传输过程的控制」。因此，学习控制方法及范围有助于正确理解 TCP 套接字。
4.1.1 TCP/IP 协议栈 TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题
4.1.2 链路层 链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准。
4.1.3 IP 层 转备好物理连接候就要传输数据。为了再复杂网络中传输数据，首先要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP。
IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。
4.1.4 TCP/UDP 层 IP 层解决数据传输中的路径选择问题，秩序照此路径传输数据即可。TCP 和 UDP 层以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称为传输层。UDP 比 TCP 简单，现在我们只解释 TCP 。 TCP 可以保证数据的可靠传输，但是它发送数据时以 IP 层为基础（这也是协议栈层次化的原因）
IP 层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中可能只收到A和C，甚至收到的C可能已经损毁 。反之，若添加 TCP 协议则按照如下对话方式进行数据交换。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 3 章 网络地址的初始化与分配 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-3-%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%88%86%E9%85%8D-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Mar 2022 13:13:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-3-%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%88%86%E9%85%8D-%E7%AC%94%E8%AE%B0/</guid>
      <description>第三章.地址族与数据序列 3.1 分配给套接字的ip地址与端口号 IP是为了收发网络数据而分配给计算机的值；端口号是为了区分程序中创建的套接字的序号。
3.1.1 网络地址 IP地址分为两类：
Ipv4：4字节地址 IPv6：16字节地址 地址分为网络号和主机号： 3.1.2 网络地址分类与主机地址边界 只需通过IP地址的第一个字节即可判断网络地址占用的总字节数，因为我们根据IP地址的边界区分网络地址，如下所示：
A 类地址的首字节范围为：0~127
B 类地址的首字节范围为：128~191
C 类地址的首字节范围为：192~223 还有如下这种表示方式：
A 类地址的首位以 0 开始
B 类地址的前2位以 10 开始
C 类地址的前3位以 110 开始
3.1.3 用于区分套接字的端口号 端口号用于同一操作系统内区分不同的套接字而设立的。端口号由16位构成，范围为0～65536，但0～1023是知名端口，一般分配给特定应用程序。
虽然端口号不能重复，但是 TCP 套接字和 UDP 套接字不会共用端接口号，所以允许重复。
3.2 地址信息的表示 3.2.1 IPv4地址结构体 结构体的定义:
1 2 3 4 5 6 7 struct sockaddr_in { sa_family_t sin_family; //地址族（Address Family） uint16_t sin_port; //16 位 TCP/UDP 端口号 struct in_addr sin_addr; //32位 IP 地址 char sin_zero[8]; //不使用 }; 该结构体中提到的另一个结构体 in_addr 定义如下，它用来存放 32 位IP地址:</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 2 章 套接字类型与协议设置 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-2-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 18 Mar 2022 11:15:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-2-%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE-%E7%AC%94%E8%AE%B0/</guid>
      <description>第二章.套接字类型和协议设置 2.1 套接字类型和数据传输特性 如果两个端口需要通信，必须使用相同的协议。协议就是为了完成数据交换定好的约定。
2.1.1 创建套接字 1 2 3 4 5 6 7 8 #include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); /* 成功时返回文件描述符，失败时返回-1 domain: 套接字中使用的协议族（Protocol Family） type: 套接字数据传输的类型信息 protocol: 计算机间通信中使用的协议信息 */ 2.1.2 协议族 协议族其实就是协议分类信息。
头文件sys/socket.h中声明的协议族
名称 协议族 PF_INET IPV4互联网协议族 PF_INET6 IPV6互联网协议族 PF_LOCAL 本地通信Unix协议族 PF_PACKET 底层套接字的协议族 PF_IPX IPX Novel协议族 本书着重讲 PF_INET 对应的 IPV4 互联网协议族。其他协议并不常用，或并未普及。另外，套接字中采用的最终的协议信息是通过 socket 函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。
2.1.3 面向连接的套接字（SOCK_DGRAM） 首先说明，socket函数的第一个参数决定使用的协议族，第二个参数指定数据传输类型。也就是说一个协议族中有多种传输方式。
面向连接的数据传输方式特征（有连接）：
传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界（Boundary） 这里的不存在数据边界是指接收方会制定数据的大小，但发送方不需要一次性发送这么大的消息，可以分多次传输。接收方可以在没有达到指定大小就接受数据，也可以收集够指定大小的数据才会打包接收数据！
收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。只要不超过数组容量，那么数据填满缓冲后过 1 次 read 函数的调用就可以读取全部，也有可能调用多次来完成读取。</description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》第 1 章 理解网络编程和套接字 笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-1-%E7%AB%A0-%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 17 Mar 2022 13:12:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC-1-%E7%AB%A0-%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97-%E7%AC%94%E8%AE%B0/</guid>
      <description>第一章.理解网络编程和套接字 系统环境：CentOS 7 宿主机：macOS Big Sur
1.1 理解网络编程和套接字 1.1.1 “打电话”过程 服务器端：
1.调用socket函数创建套接字 2.调用bind函数分配IP地址和端口号 3.调用listen函数转为可接收请求状态 4.调用accept函数受理连接请求 客户端：
1.调用socket函数创建套接字 2.调用connect函数向服务器端发送连接请求 1.1.2 实操 文件编写：
hello_server.c hello_client.c 进入文件所在的根目录，编译并进行“打电话”：
服务器端： 1 2 gcc hello_server.c -o hserver //编译生成hserver ./hserver 9190 //运行hserver生成9190端口等待客户端的连接请求 客户端(这里的ip地址为服务器端的ip地址)： 1 2 gcc hello_client.c -o hclient //编译生成hserver ./hclient 172.16.127.128 9190 //运行hserver生成9190端口等待客户端的连接请求 结果：服务器端输出“Hello World!”
注意：
1.服务端和客户端要分开：如果为同一台电脑，可以使用两个终端进行；如果不同的电脑需要搞清楚输入ip为服务端的本地ip。
2.通过终端ifcong，查看分配的本地ip
3.顺序一定是先服务器端再客户端
4.运行一次过后就需要更改服务器的端口号
1.2 基于Linux的文件操作 在Linux中，socket也被认为是一种文件，因此在网络数据传输时可以使用文件I/O的相关函数，而Windows需要调用特殊的数据传输相关的函数。
1.2.1 文件描述符 文件描述符是指为了方便称呼操作系统创建的文件或套接字而赋予的数。
1.2.2 打开/关闭/读/写文件/文件描述符和套接字 打开文件用open函数 打开模式有5种：
打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 维持现有数据，保存到其后面 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 关闭文件使用close函数 数据写入使用write函数 数据读取使用read函数 创建文件和套接字，并用整数形态比较返回的文件描述符值 1.</description>
    </item>
    
    <item>
      <title>《数字图像处理》第三章——图像增强</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</link>
      <pubDate>Mon, 14 Mar 2022 19:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</guid>
      <description>《数字图像处理》第三章——图像增强 图像增强是突出图像中的某些部分，将图像变得易于人眼观察，通常用于去噪，平滑，锐化，阈值处理。
处理方式：
空间域处理 点处理 邻域处理 频率域处理 点像素处理法 阈值处理：最常用的是二分阈值，也就是像素值大于某个阈值全部变成255，小于该阈值全部变成0。 图像反转：常用于灰度图的黑白反转，使得想要显示的图像细节变成低像素值，其他变成高像素值，公式如下： $$ s = L - 1 -r $$ 伽马校正：原理是将图像的像素点再有效范围内分布更加均匀。它通常用于常用显示器显示图像或者对整体过亮的图像进行延展。公式如下： $$ s = cr^{\gamma} $$ 注：这里通过调整上标伽马的参数来进行校正 像素拉伸：原理是在低像素和高像素区域的像素值都乘以一个小于1的系数，处于中间像素区域的像素值都乘以一个大于1的系数。 图像均衡 直方图均衡化 直方图的定义：横坐标为像素值，纵坐标为像素的个数。 直方图归一化：横坐标依然为像素值，纵坐标变成了该像素值出现的概率。 直方图的目的是通过一个函数来使原图像的直方图分布从不均匀到一个均匀分布，公式如下： $$ s = T(r) = (L - 1)\int_{0}^{r}P_{r}(w)dw $$
注：其中L为256（8bit的最大数加1），P为概率分布函数
该函数为一个递增函数，由旧的像素值（整数）变成新的像素值（浮点数），又一个取整的过程，所以直方图均衡化之后，直方图分布并不是完全平均
直方图匹配 直方图匹配是指给定一张图像，要将其直方图分布变换成特定直方图分布。
直方图匹配的实现：
1.先对原图像进行直方图均衡化处理，得到结果T 2.对目标直方图进行直方图均衡化处理，得到映射关系 3.对T进行步骤2的逆映射处理 邻域矩阵处理法 这也就是我们通常所说的滤波。通常使用一个n×n矩阵和图像中的所有n×n子块进行求内积的操作
均值滤波（局部）：使用全为1的矩阵进行求内积。注意矩阵乘法之前必须进行归一化，防止数据超过原有的范围。 $$\sum_{i}(a - a_{i})^2取最小时就是其均值（误差较大）$$
高斯滤波：使用高斯滤波进行局部平均，相当于离中间像素值越大的其权重分配的越小，差值越小的权重分配的越大。
中值滤波：对图像的n×n子块，排序取中间值来替代原像素的值。（通常用于去除椒盐噪声，效果很好）
$$\sum_{i}\lvert a - a_{i} \rvert取最小时就是其中值（误差鲁棒性更小）$$
非局部均值滤波：根据图像的自相似性，我们可以将相似的局部区域一起做一个平均。 1 2 3 4 5 6 7 -p0指所有相似区域p1～pn的相同的部分 -s1～sn指所有区域不同的部分 p1 = p0 + s1 p2 = p0 + s2 ··· pn = p0 + sn 如何进行相似区域的寻找？</description>
    </item>
    
    <item>
      <title>Open cv模块学习</title>
      <link>https://caixiongjiang.github.io/blog/2022/opencv%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 04 Mar 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/opencv%E5%AD%A6%E4%B9%A0/</guid>
      <description>图像基本操作 数据读取-图像 cv2.IMREAD_COLOR:彩色图像 cv2.IMREAD_GRAYSCALE:灰度图像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import cv2 as cv # opencv模块，读取图片的的格式是BGR import matplotlib.pyplot as plt # 制做图表的模块 import numpy as np # 数据处理模块 img1 = cv.imread(&amp;#34;cat.jpg&amp;#34;) # 读取图片（彩色图片） # 输出img1为一个三个的二维矩阵，dtype为 uint8（代表0～255之间的整数） # 图像的显示 cv.imshow(&amp;#34;image&amp;#34;, img1) #参数：（图片标题，图片名） # 等待时间，毫秒级，0表示按任意键终止图像显示 cv.watKey(0) cv.destroyAllWindows() # 可以将显示图像放到一个函数当中 def cv_show(name, img): cv.</description>
    </item>
    
    <item>
      <title>《Effective C&#43;&#43;》导读&amp;条款1~3</title>
      <link>https://caixiongjiang.github.io/blog/2022/effective-c&#43;&#43;/effective-c&#43;&#43;%E5%AF%BC%E8%AF%BB%E6%9D%A1%E6%AC%BE1~3/</link>
      <pubDate>Tue, 01 Mar 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/effective-c&#43;&#43;/effective-c&#43;&#43;%E5%AF%BC%E8%AF%BB%E6%9D%A1%E6%AC%BE1~3/</guid>
      <description>《Effective c++》学习笔记 导读部分 正式开始55条条款之前，这本书的目的是为了让c++程序员如何写出更加安全高效的程序准备的，属于进阶书籍，如果观看本书还有很多不明白的地方，还需要去学基础，推荐《c++ Primer》,看本书前需要知道的有：c++面向过程，c++面向对象，c++泛型编程，c++ STL标准库， c++多线程编程。
术语 1.std命名空间是几乎所有c++标准程序库元素的栖息地，所以在导入c++头文件的时候，一定要在std命名空间内写程序
2.size_t是一个typedef，是c++计算个数（字符串内的个数或者STL容器内的元素个数）时使用的，它属于无符号整数
3.一个类的构造函数使用explicit关键字可以阻止它们被用来隐式类型转换，但他们仍然可被用于显示类型转化。被声明为explicit关键字的构造函数通常比没有它更受欢迎，因为它们禁止编译器执行非预期的类型
demo：
头文件（.h）:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A{ public: A(); //default构造函数 }; class B{ public: explicit B(int x = 0, bool b = true);//default构造函数 两个参数都已经设置默认值 }; class C{ public: explicit C(int x);//不是default构造函数 }; 执行文件（.cpp）:
1 2 3 4 5 6 7 8 9 10 void doSomething(B bObject); //函数声明，接收一个类型为B的对象 B bObj1; doSomething(bObj1); B bObj2(28);//正确，根据int28建立一个B doSomething(28);//错误！doSomething应该接收一个B //int至B之间没有隐式类型转化 doSomething(B(28));//正确，使用B构造函数将int显示转换 4.</description>
    </item>
    
    <item>
      <title>《数字图像处理》第二章——图像压缩</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Mon, 28 Feb 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</guid>
      <description>《数字图像处理》第二章——图像压缩 图像压缩基本概念 压缩比： Cr = n1 / n2 相对数据冗余： Rd = 1 - 1 / Cr 无损压缩： 压缩编码冗余和像素冗余称为无损压缩 图像压缩标准（包括视频） 主流的静态图像压缩标准（JPEG家族）：JPEG, JPEG-LS(无损压缩), JPEG-2000 主流的视频压缩标准（MPEG家族）：MPEG-1, MPEG-2, MPEG-3, MPEG-4 AVC 图像压缩的流程 以JPEG的压缩流程为例：
输入的图像——&amp;gt;图像分块——&amp;gt;映射器——&amp;gt;量化器——&amp;gt;编码器 解码器——&amp;gt;反映射——&amp;gt;输出图片 量化器是该过程中唯一对图像质量有损耗的
JPEG压缩 编码器 JPEG使用的是哈夫曼编码，哈夫曼编码得到的是一种无前缀编码，这会使得出现概率越高的元素编码长度越短，出现概率越低的元素编码长度越长，最后总的编码长度编程最短
哈夫曼编码使用规则：
1.每次取集合中最小的两个值，相加之后再加入原有的集合，再重复取最小的两个值，到最后只剩一个元素 2.将原有集合的数字进行编码，层数越高，编码长度越短 在JPEG中应用为：对像素出现的概率高低进行编码！
demo：
a1 - 0.4 a2 - 0.3 a3 - 0.1 对应编码： a1 - 1 a2 - 01 a3 - 00 编码熵：$ -\sum_{i = 1}^n p(s)log_2^{p(s)}$ （概率*对应的自信息）
图像分块 在JPEG中采用8✖️8的小块进行分别处理，这么做的原因是分别对小块进行处理比对整张图像进行处理更加高效、
若JPEG为RGB的彩色图像，我们需要先将RGB通道转化为YCbCr通道，再对每个通道进行分块处理
模式“RGB”转换为“YCbCr”的公式如下：
Y= 0.</description>
    </item>
    
    <item>
      <title>Linux环境搭建：虚拟机上运行CentOS</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sun, 30 Jan 2022 20:55:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>为什么选择CentOS环境而不选择Ubuntu 原本我的windows笔记本上已经装了Ubuntu,已经有了Linux环境。
最近听了网上大佬的说法，说国内的互联网公司基本都在使用另一个Linux操作系统CentOS,加之其比Ubuntu更加稳定，最重要的是可视化界面更少，这一点是我选择它的原因。
windows端部署 大家有mac就用mac，没有条件就用windows，毕竟macbook这么贵。
不得不说mac系统真的比windows好用很多，特别是配置环境和下载软件这方面真的有些操蛋！
软件准备 1.虚拟机软件VMware workstation
社区免费版下载地址：	https://customerconnect.vmware.com/en/downloads/info/slug/desktop_end_user_computing/vmware_workstation_player/16_0
2.CentOS 7 镜像文件：
复制这段内容后打开百度网盘手机App，操作更方便哦 链接：https://pan.baidu.com/s/1tmxews_LiAWS9DXLIi8egA 提取码：6wZd
3.SSH终端连接工具：
因为SecurCRT软件不是免费的，需要破解，windows端找软件真的找破天，非常多站点下的都有问题，甚至有病毒。我在这里提供两种下载方式，安装版和解压版：
Securecrt安装版破解版 v8.5下载地址：https://www.32r.com/soft/49437.html
此种方式的破解方法视频：https://www.bilibili.com/video/BV1QC4y1H7zR?spm_id_from=333.1007.top_right_bar_window_history.content.click
注意注册机文件的放入位置和patch，以及各种信息的填写。如果这种方式无效，就直接去下解压版吧。
Securecrt解压版下载地址：
复制这段内容后打开百度网盘手机App，操作更方便哦 链接：https://pan.baidu.com/s/1ebeOqNtbdEkGVdJOCOvAQQ 提取码：6wZd
解压完就可以使用了。
4.SFTP传输工具WinSCP:
这个软件可以在windows端和Linux端传文件的工具，下载地址：https://winscp.net/eng/docs/guide_install#downloading
CentOS安装 首先说一下用虚拟机安装系统的好处：
如果系统被你玩坏了，重新装就好了，不会让你的电脑的文件丢失，而如果装双系统极有可能会丢失文件。 而虚拟机可以设置多个节点，可以做服务器集群，而双系统就只能用一个。 如果你觉得虚拟机装Linux没得灵魂，记住你这句话，你会说“真香“的！ 1.安装好虚拟机软件之后，打开，点击新建虚拟机，浏览找到安装镜像源的位置，点击下一步，输入节点的名字
2.设置好登录的用户名和密码以及root密码（root密码要记住，以后在命令行中使用root操作需要输入此密码）
3.进入一段黑屏绿字的安装时间之后进入设置安装内容界面。
安装设置界面：
语言支持选择中文，安装位置选择自动配置分区，然后再点击软件选择，考虑到以后可能用到很多服务器开发有关的东西，我选择开发及生成工作站，勾选如下选项。
然后开始你漫长的安装过程，出现如下画面,就代表装好了。
初始界面：
检查连通性以及SSH连接 在windows端一般来说都是直接配好的，可以通过命令行检查与外网和宿主机的连通性：
与外网连通性：
1 $ ping www.baidu.com 如果出现跳出毫秒信息等信息，说明已经连通了，按Ctrl+c取消。
如果跳出未知的名称或服务，说明不连通
与宿主机连通性：
Linux连接宿主机：
1.宿主机按Ctrl+R，输入cmd运行，输入：
1 ipconfig/all 找到ipv4地址，复制，在命令行输入：
1 $ ping 192.168.31.11 查看连通性。
宿主机连接Linux：
1.在Linux命令行输入：
1 ifconfig 出现如下画面：
复制第一个inet后面的ip地址，注意这个ip地址虽然是DHCP动态分配的，但在windows上基本每次分配都是同一个ip地址
然后打开windows终端，输入：
1 ping 192.</description>
    </item>
    
    <item>
      <title>Docsify：最简易的知识库生成器</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/docsify%E7%9F%A5%E8%AF%86%E5%BA%93%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Fri, 28 Jan 2022 16:15:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/docsify%E7%9F%A5%E8%AF%86%E5%BA%93%E6%90%AD%E5%BB%BA/</guid>
      <description>我的个人知识库搭建：蜜蜂网 docsify是一款比Hugo更加轻便的网站部署软件，它比Hugo少了生成html文件这一步，而且少了许多配置文件，真正的本地文件也就只有几个。
许多人用它来搭建博客，但我认为正因为它参数配置很少，不利于搭建自己想要的风格，反而作为自己的知识库会更加便利。我们都不想哪里忘了去翻那厚重的书本吧！
下面是一些参考网站：
docsify官网 Codesheep程序羊关于个人知识库搭建的b站视频 为了书写方便，后文中提到的命令在windows端在Git中运行，在mac端在terminal中运行。
环境配置 Node.js安装 Node.js是为你使你的电脑上确保有npm工具，因为docsify的安装需要用到npm工具。
Node.js官网下载地址 下载安装好之后，可以查看一下npm是否已经安装好了：
windows端：在桌面点击右键，选择Git bash here，如果出现了，其实就已经安装好了。如果不放心还是可以输入：
1 npm -v 如果出现了版本号信息，则表示已经安装好了。
mac端：打开终端terminal同样输入上述的命令：
1 npm -v 如果出现了版本号信息，则表示已经安装好了。
docsify安装 这里的docsify安装其实安装的是它的二进制命令行工具。
windows/mac端输入：
1 npm install -g docsify-cli 安装完成后输入：
1 docsify -v 如果出现版本号则说明安装好了。
新建站点 这里用我的站点名称jarson-cai-blog作为例子：
1.新建知识库的文件夹jarson-cai-blog
2.使用命令行工具进入知识库文件夹（根据你的路径不同而不同），并对其进行初始化，输入：
1 2 3 cd Desktop/jarson-cai-blog docsify init y //提示你是否初始化，选择y 你的站点已经生成了，进入之后会有两个文件，一个是html文件，一个是Markdown文件。
本地启动服务端口（https） 这个功能主要用于修改配置参数时，查看预览效果的功能，是非常重要的。
输入：
1 docsify serve 会提示Web Server is available at //localhost:3000/，复制//localhost:3000/在网页端预览。
写知识库文件 docsify统一采用Markdown格式进行书写。而且其中的语法与markdown基本一致，没有个人特殊的配置。
新建Github仓库，作为部署网站的仓库 注意事项：新建的仓库名必须与你的github用户名相同，以我的github名字caixiongjiang为例。
我的仓库名为：caixiongjiang.github.io，点击创建，注意先不要生成README.md文件，否则你在第一次推送文件前还需要先拉取文件。
如果你没有VPN，不能稳定访问github，可以使用Gitee，这个仓库名就没有限制了
生成知识库站点 这里特别要说的一点就是docsify不需要生成站点，也就是没有Hugo中有.</description>
    </item>
    
    <item>
      <title>Hugo：最轻量级博客框架</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 26 Jan 2022 10:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
      <description>我的Hugo博客搭建 原本想使用hexo搭建我的个人静态博客，但是前两天使用了之后发现写了大量文章之后生成博客会特别慢。
所以采用了新的基于go语言的博客框架Hugo来搭建我的个人博客
下面是一些参考文档：
Hugo官网 Hugo中文文档 Codesheep程序羊关于Hugo博客搭建的b站视频 环境配置 Git安装 这个工具是在后序部署博客到github pages上必须的，mac端和windows端都是ok的
Git官网下载地址 下载安装好之后，可以查看一下Git是否已经安装好了：
windows端：在桌面点击右键，选择Git bash here，如果出现了，其实就已经安装好了。如果不放心还是可以输入：
1 git version 如果出现了版本号信息，则表示已经安装好了。
mac端：打开终端terminal同样输入上述的命令：
1 git version 如果出现了版本号信息，则表示已经安装好了。
Hugo安装 Hugo安装总共有两种方式：
1.文件下载方式（Linux，mac，windows）：
Hugo最新releases版本下载官网
2.命令行下载的方式：
​	Hugo普通版本：
windows端：最好采用文件下载方式，因为后续还要找到hugo.exe的地址，并配置环境变量。
mac端：使用brew安装：
1 brew install hugo Hugo配置 这是windows端特有的步骤(与java的jdk配置相似)：
1.找到安装好的hugo.exe
2.点击复制文件路径
3.找到到windows系统设置的高级系统设置，点击环境变量,在用户变量的path中添加你复制好的hugo路径,应用了之后就配好了
4.右键桌面，点击Git bash here，输入
1 hugo version 若能显示版本信息，就说明安装成功了。
Hugo扩展版本： 这个是否选择安装与你安装的主题有关，如果你选择的主题需要扩展版本，那么就需要安装，如果不需要则忽略这个模块的内容！
windows端：
1.在桌面右键Git bash here输入：
1 iwr -useb get.scoop.sh | iex 如果出错了，就输入：
1 Set-ExecutionPolicy RemoteSigned -scope CurrentUser 2.使用scoop安装扩展版本，输入:
1 scoop install hugo-extended mac端：我没有试过，应该命令是差不多的</description>
    </item>
    
    <item>
      <title>我的力扣刷题笔记</title>
      <link>https://caixiongjiang.github.io/blog/2021/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%82%9F/%E6%88%91%E7%9A%84%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 26 Aug 2021 10:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2021/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%82%9F/%E6%88%91%E7%9A%84%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</guid>
      <description>本仓库代码攻略部分在代码随想录的基础上写的 转载自代码随想录主页 仅用于个人学习。
强烈推荐小白的刷题顺序，经过上万网友的印证！
🌱vim命令使用指南，让你摆脱鼠标敲代码
🌱力扣周赛+双周赛 数组 🔥关于数组 🔥二分法 🔥移除元素 🔥滑动窗口 🔥螺旋矩阵(绕晕人的循环) 链表 🔥关于链表 🔥移除链表元素 🔥链表的常用操作 🔥反转链表 🔥删除倒数第N个节点(经典双指针法) 🔥寻找环的入口 哈希表 🔥关于哈希表 🔥用数组实现哈希表（表长固定的情况） 🔥Set使用：两个数组的交集 🔥用Set来判断快乐数 🔥map使用：两数之和 🔥map使用：四数相加Ⅱ 🔥map使用：赎金信 🔥map使用：三数之和 字符串 🔥简单字符串反转 🔥进阶字符串反转 🔥替换空格 🔥翻转字符串里的单词(花式翻转) 🔥左旋字符串 🔥KMP算法核心：next数组的生成 栈与队列 🔥关于栈和队列 🔥用栈实现队列 🔥用队列实现栈 🔥栈的应用(括号匹配) 🔥栈的应用(删除字符串中所有相邻重复项，本质同为匹配问题) 🔥栈的应用(计算后缀表达式) 🔥队列应用(单调队列经典题目) 🔥前k个高频元素和队列有什么关系 二叉树 二叉树的题目类型分类：
🔥关于二叉树 🔥二叉树的递归遍历 🔥二叉树的迭代遍历 🔥二叉树的层序遍历 🔥翻转二叉树 🔥判断二叉树是否对称 🔥求树的最大深度 🔥求树的最小深度 🔥完全二叉树的节点个数 🔥判断是否是平衡二叉树 🔥寻找二叉树的所有路径 🔥二叉树的左叶子值之和 🔥二叉树：判断是否存在根节点到叶子节点值的和等于给定值 🔥二叉树：找到所有根节点到叶子节点值的和等于给定值的所有路径 🔥构造二叉树(中序+后序) 🔥构造二叉树(前序+中序) 🔥构造最大的二叉树 🔥合并两个二叉树 🔥二叉搜索树：搜索给定的值的节点为根节点的子树 🔥判断是否为二叉搜索树 🔥搜索树的最小绝对差 🔥二叉搜索树中的众数 🔥二叉树的最近公共祖先 🔥二叉搜索树的最近公共祖先 🔥二叉搜索树中的插入操作 🔥二叉搜索树中的删除操作 🔥修剪二叉搜索树 🔥有序数组构造二叉搜索树 🔥二叉搜索树转换为累加树 回溯算法 题目类型大纲如下： 🔥关于回溯算法 🔥回溯算法：组合问题 🔥回溯算法：组合总和Ⅲ 🔥回溯算法:电话号码的字母组合 🔥回溯算法:求组合总和(二) 🔥回溯算法:求组合总和(三) 🔥回溯算法:分割回文串 🔥回溯算法:复制IP地址 🔥回溯算法:子集 🔥回溯算法:子集Ⅱ 🔥回溯算法:递增子序列 🔥回溯算法:全排列 🔥回溯算法:全排列Ⅱ (!</description>
    </item>
    
  </channel>
</rss>
