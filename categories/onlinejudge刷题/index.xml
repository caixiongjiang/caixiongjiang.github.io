<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OnlineJudge刷题 on 🌀riba2534&#39;s Blog</title>
    <link>https://caixiongjiang.github.io/categories/onlinejudge%E5%88%B7%E9%A2%98/</link>
    <description>Recent content in OnlineJudge刷题 on 🌀riba2534&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 07 Nov 2020 16:41:38 +0800</lastBuildDate><atom:link href="https://caixiongjiang.github.io/categories/onlinejudge%E5%88%B7%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 327 区间和的个数（树状数组、线段树）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Sat, 07 Nov 2020 16:41:38 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：区间和的个数
给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。 区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。
说明: 最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。
示例:
输入: nums = [-2,5,-1], lower = -2, upper = 2,输出: 3 解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。思路 (树状数组) $O(nlogn)$
这道题一个很直观的做法就是记录前缀和，然后使用双层循环遍历所有的区间，时间复杂度$O(n^2)$。我们考虑如何来优化这个这个双层循环，我们在固定子数组的右边界的时候，采用遍历的方式求出所有区间和在[lower,upper]之间的数组个数，我们可以以更优的方式求解所有可行的区间。假设右区间为A[j]，前缀和为preSum[j]，其实我们需要求的是所有preSum[j] - upper &amp;lt;= preSum[i] &amp;lt;= preSum[j] - lower(i&amp;lt;j)的个数。求某一个区间内的个数，我们可以使用树状数组或者线段树来求解。
我们每次读到一个数，先把合法区间内前缀和的个数求出来（区间查询），然后将当前前缀和出现的次数加上一（单点更新）。因为只需要上面两个操作，所以可以使用树状数组来减少代码难度。整体代码思路如下：
 求出数组的前缀和数组（包括0），并将前缀和数组离散化。 使用三个哈希表，分别记录每一个前缀和离散化后的大小，以该数字为右边界对应的左边界前缀和的区间[preSum[j] - upper,preSum[j] - lower]对应的区间左右端点离散化后的值。  lower_bound查找大于等于preSum[j] - upper最小值对应的下标；</description>
    </item>
    
    <item>
      <title>LeetCode LCP18 早餐组合（贪心，思路）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-lcp18-%E6%97%A9%E9%A4%90%E7%BB%84%E5%90%88%E8%B4%AA%E5%BF%83%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 15 Sep 2020 00:56:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-lcp18-%E6%97%A9%E9%A4%90%E7%BB%84%E5%90%88%E8%B4%AA%E5%BF%83%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：早餐组合
小扣在秋日市集选择了一家早餐摊位，一维整型数组 staple 中记录了每种主食的价格，一维整型数组 drinks 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 x 元。请返回小扣共有多少种购买方案。
注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1
示例 1：
 输入：staple = [10,20,5], drinks = [5,5,2], x = 15
输出：6
解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是： 第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15； 第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15； 第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12； 第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10； 第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10； 第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。</description>
    </item>
    
    <item>
      <title>LeetCode 37 解数独（dfs）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%ACdfs/</link>
      <pubDate>Tue, 15 Sep 2020 00:53:33 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%ACdfs/</guid>
      <description>题目链接：解数独
编写一个程序，通过已填充的空格来解决数独问题。
一个数独的解法需遵循如下规则：
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  空白格用 &#39;.&#39; 表示。
一个数独。
答案被标成红色。
Note:
 给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。  思路 经典的解数独游戏。
首先记录下来所有的需要填数字的坐标信息，然后从第一个需要填数的地方开始填数，依次判断数字 1-9 ，当前位置是否可以填数，可以的话填数，继续搜索下一层，最后回溯的时候需要取消填数继续试。如果找到答案，就记录一下，这里可以剪枝。
要判断一个地方能不能填数字，要满足：
 这一行中有没有相同数字 这一列中有没有相同数字 当前的小9宫格中，有没有相同数字（对当前坐标*3和/3的操作是为了确定当前小九宫格的起始点坐标）  如果满足这个条件，证明这个地方可以填数。
具体看代码
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  class Solution { public: vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; point; vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; ans; bool flag; bool check(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board, int k, int step) { for (int i = 0; i &amp;lt; 9; i++) if (board[point[step].</description>
    </item>
    
    <item>
      <title>超级码力在线编程大赛初赛 第2场 题解</title>
      <link>https://caixiongjiang.github.io/blog/2020/%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B-%E7%AC%AC2%E5%9C%BA-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Sun, 30 Aug 2020 13:05:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B-%E7%AC%AC2%E5%9C%BA-%E9%A2%98%E8%A7%A3/</guid>
      <description>超级码力在线编程大赛初赛 第2场 题解 下面的题解仅代表个人观点，出了问题，概不负责。
比赛链接：https://tianchi.aliyun.com/oj/15165469968503404?spm=5176.15098393.J_6210563800.8.6b8b5cd6dK6WtT
1. 三角魔法 描述 小栖必须在一个三角形中才能施展魔法，现在他知道自己的坐标和三个点的坐标，他想知道他能否施展魔法
 −109&amp;lt;=x,y&amp;lt;=109 点在边上也属于三角形内  示例 输入: triangle = [[0,0],[2,0],[1,2]] point= [1,1]输出: &amp;quot;Yes&amp;quot;输入: triangle = [[0,0],[2,0],[1,1]] point= [2,1]输出: &amp;quot;No&amp;quot;思路 判断是否在三角形内，模板题。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  class Vector2d { public: double x_; double y_; public: Vector2d(double x, double y) : x_(x), y_(y) {} Vector2d() : x_(0), y_(0) {} //二维向量叉乘, 叉乘的结果其实是向量，方向垂直于两个向量组成的平面，这里我们只需要其大小和方向  double CrossProduct(const Vector2d vec) { return x_ * vec.</description>
    </item>
    
    <item>
      <title>LeetCode 214 最短回文串(kmp、next应用)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2kmpnext%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sat, 29 Aug 2020 02:41:03 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2kmpnext%E5%BA%94%E7%94%A8/</guid>
      <description>题目链接：最短回文串
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
示例 1:
输入: &amp;quot;aacecaaa&amp;quot;输出: &amp;quot;aaacecaaa&amp;quot;示例 2:
输入: &amp;quot;abcd&amp;quot;输出: &amp;quot;dcbabcd&amp;quot;思路 kmp
首先我们回归一下 kmp 中 next 数组的含义：
 next[i] 代表 从 [0,i-1] 的最长的相同真前后缀的长度  那么对于这个题目而言，已知题目让我们在字符串前面增加字符让他变成回文串。
我们知道，对于一个回文串而言，它的所有的前缀和后缀是相同的。
假设现在给出的字符串是：abacd，可以确定把字符串的逆序加在这个字符串前面一定回文，比如 dcabaabacd 就一定是个回文串，但是我们可以发现原串的前缀和逆序后的后缀 有重合，对于刚刚给出的例子来说。原串是 abacd，逆序是 dcaba，则前后缀重合的部分是 aba，那么我们拼字符串的时候，这一块就不用动，只需要把原串中 aba后面的字符串 cd 逆序后的字符串 dc 加在原串前，变成 dcabacd 就是答案。
如何求得这个原串的前缀和逆序后的后缀的最大长度呢，正好kmp的next数组就是专门干这个事的，我们给原串和逆序串中间加一个 # 号(防止出现原串中字符都相同的情况)，组成一个新串，然后对这个新串求 next，则新的next数组的最后的值就是最长真前后缀的长度。
知道这个长度后，只需要把这个长度之后的串逆序，加在原串前即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: vector&amp;lt;int&amp;gt; nxt; void get_next(string &amp;amp;p) { int len = p.</description>
    </item>
    
    <item>
      <title>LeetCode 332 重新安排行程(输出欧拉路经)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%E8%BE%93%E5%87%BA%E6%AC%A7%E6%8B%89%E8%B7%AF%E7%BB%8F/</link>
      <pubDate>Thu, 27 Aug 2020 02:00:55 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%E8%BE%93%E5%87%BA%E6%AC%A7%E6%8B%89%E8%B7%AF%E7%BB%8F/</guid>
      <description>题目链接：重新安排行程
给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。
说明:
 如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGA&amp;rdquo;] 与 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGB&amp;rdquo;] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程。  示例 1:
输入: [[&amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;], [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;], [&amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;], [&amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;]]输出: [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;]示例 2:
输入: [[&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;],[&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]]输出: [&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]解释: 另一种有效的行程是 [&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]。但是它自然排序更大更靠后。思路 看到类似于「一笔画问题」，第一时间想到欧拉路。
 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。 具有欧拉回路的无向图称为欧拉图。 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。  因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。
所以我们可以直接从起点进行 DFS，然后但是要注意走过的边不能重复走，直到走完所有边最后就是答案。
官方题解的实现比较骚，没想到。
用了一个哈希到优先队列的映射，一个字符串映射一个最小堆，这样就可以根据贪心思路来保证字典序了。
搞一个栈存答案，因为是dfs从后网前回溯，所以答案是反着的，最后反转一下即可。
关于欧拉路的判断，可以看 NYOJ42 一笔画问题(欧拉路+并查集)
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: unordered_map&amp;lt;string, priority_queue&amp;lt;string, vector&amp;lt;string&amp;gt;, greater&amp;lt;string&amp;gt;&amp;gt;&amp;gt; e; vector&amp;lt;string&amp;gt; stk; void dfs(string u) { while (!</description>
    </item>
    
    <item>
      <title>LeetCode 491 递增子序列(枚举子集)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/</link>
      <pubDate>Tue, 25 Aug 2020 01:22:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/</guid>
      <description>题目链接：递增子序列
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
示例:
输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]说明:
 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。  思路 先看一眼数据范围，是15，猜一下复杂度，大概 $2^{15}$ 能过，应该就是二进制枚举子集了。
关于枚举子集，可以看我之前写的博客 ：二进制枚举子集详解
枚举子集可以求出，所有的组合方式。接下来我们只需要判断
 这个序列是不是一个递增序列 去重  关于判断是否是一个递增序列，我们只需要找一个比较小的数 t ，其值一直跟随当前遍历的数的值，如果遍历到的数小于t，则这肯定是一个递减序列。
关于去重，可以用 unordered_map 做一个 string 的映射，比如现在有列表 [1,12,-3,4]，我们给每个数字加上分隔符，变成一个字符串 1|12|-3|4，将这个值进行映射，可以保证不重复。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsequences(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; unordered_map&amp;lt;string, int&amp;gt; mp; int n = nums.</description>
    </item>
    
    <item>
      <title>LeetCode 679 24 点游戏(暴力，递归)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-679-24-%E7%82%B9%E6%B8%B8%E6%88%8F%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92/</link>
      <pubDate>Sat, 22 Aug 2020 01:57:03 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-679-24-%E7%82%B9%E6%B8%B8%E6%88%8F%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：24 点游戏
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
示例 1:
输入: [4, 1, 8, 7]输出: True解释: (8-4) * (7-1) = 24示例 2:
输入: [1, 2, 1, 2]输出: False注意:
 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。  思路 首先括号可以直接忽略掉，因为我们可以从数组中任意取数并组合。括号没啥用。</description>
    </item>
    
    <item>
      <title>LeetCode 529 扫雷游戏（DFS）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-529-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8Fdfs/</link>
      <pubDate>Thu, 20 Aug 2020 01:59:22 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-529-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8Fdfs/</guid>
      <description>题目链接：扫雷游戏
让我们一起来玩扫雷游戏！
给定一个代表游戏板的二维字符矩阵。 &amp;lsquo;M&amp;rsquo; 代表一个未挖出的地雷，&amp;lsquo;E&amp;rsquo; 代表一个未挖出的空方块，&amp;lsquo;B&amp;rsquo; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（&amp;lsquo;1&amp;rsquo; 到 &amp;lsquo;8&amp;rsquo;）表示有多少地雷与这块已挖出的方块相邻，&amp;lsquo;X&amp;rsquo; 则表示一个已挖出的地雷。
现在给出在所有未挖出的方块中（&amp;lsquo;M&amp;rsquo;或者&amp;rsquo;E&amp;rsquo;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：
 如果一个地雷（&amp;lsquo;M&amp;rsquo;）被挖出，游戏就结束了- 把它改为 &amp;lsquo;X&amp;rsquo;。 如果一个没有相邻地雷的空方块（&amp;lsquo;E&amp;rsquo;）被挖出，修改它为（&amp;lsquo;B&amp;rsquo;），并且所有和其相邻的未挖出方块都应该被递归地揭露。 如果一个至少与一个地雷相邻的空方块（&amp;lsquo;E&amp;rsquo;）被挖出，修改它为数字（&amp;lsquo;1&amp;rsquo;到&#39;8&amp;rsquo;），表示相邻地雷的数量。 如果在此次点击中，若无更多方块可被揭露，则返回面板。  示例 1：
输入: [[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],[&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]Click : [3,0]输出: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]解释:示例 2：
输入: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]Click : [1,2]输出: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],[&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]解释:注意：</description>
    </item>
    
    <item>
      <title>LeetCode 647 回文子串(Manacher)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher/</link>
      <pubDate>Wed, 19 Aug 2020 02:35:42 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher/</guid>
      <description>题目链接：回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：
输入：&amp;quot;abc&amp;quot;输出：3解释：三个回文子串: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;示例 2：
输入：&amp;quot;aaa&amp;quot;输出：6解释：6个回文子串: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;提示：
 输入的字符串长度不会超过 1000 。  思路 首先这题长度不超过1000，那$O(n^2)$ 算法肯定能做。
但是标程肯定是用 Manacher 算法来做的。
关于此算法原理，可以看 最长回文子串——Manacher 算法
首先给原串间隔的添加一个不相关的符号隔开。
在这里我们知道几点关键点即可：
 p[i] 代表以第 i 个位置为中心的最长回文半径（包括 i） p[i]-1 代表，原串中以第 i 个位置为中心的最长回文串长度 pos 代表当前最右边为 max_right 元素时的回文串中心 max_right 代表当前访问到的所有回文子串，所能触及的最右一个字符的位置。  对于本题，我们可以知道所有的 p[i] ，则 p[i]-1 就是当前位置最长回文串长度，我们对于每个位置的长度向上取整除以2，累加起来就是不同子串数量。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Solution { public: vector&amp;lt;int&amp;gt; p; int pos, max_right; string init(string s) { string ans = &amp;#34;#&amp;#34;; for (char ch : s) ans = ans + ch + &amp;#39;#&amp;#39;; return ans; } int countSubstrings(string s) { int ans = 0; s = init(s); p.</description>
    </item>
    
    <item>
      <title>LeetCode 5 最长回文子串(Manacher)  </title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher-/</link>
      <pubDate>Wed, 19 Aug 2020 02:34:55 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher-/</guid>
      <description>题目链接：最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &amp;quot;babad&amp;quot;输出: &amp;quot;bab&amp;quot;注意: &amp;quot;aba&amp;quot; 也是一个有效答案。示例 2：
输入: &amp;quot;cbbd&amp;quot;输出: &amp;quot;bb&amp;quot;思路 Manacher 算法模板题，关于此算法原理，可以看 最长回文子串——Manacher 算法
首先给原串间隔的添加一个不相关的符号隔开。
在这里我们知道几点关键点即可：
 p[i] 代表以第 i 个位置为中心的最长回文半径（包括 i） p[i]-1 代表，原串中以第 i 个位置为中心的最长回文串长度 pos 代表当前最右边为 max_right 元素时的回文串中心 max_right 代表当前访问到的所有回文子串，所能触及的最右一个字符的位置。  本题我们只需要求出来最大的 p[i] 的位置即可，然后构造答案。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  class Solution { public: vector&amp;lt;int&amp;gt; p; int pos, max_right; string init(string s) { string ans = &amp;#34;#&amp;#34;; for (char ch : s) ans = ans + ch + &amp;#39;#&amp;#39;; return ans; } string longestPalindrome(string s) { s = init(s); p.</description>
    </item>
    
    <item>
      <title>LeetCode 546 移除盒子(区间dp，记忆化搜索)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-546-%E7%A7%BB%E9%99%A4%E7%9B%92%E5%AD%90%E5%8C%BA%E9%97%B4dp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sat, 15 Aug 2020 12:32:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-546-%E7%A7%BB%E9%99%A4%E7%9B%92%E5%AD%90%E5%8C%BA%E9%97%B4dp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</guid>
      <description>题目链接：移除盒子
给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &amp;gt;= 1），这样一轮之后你将得到 k*k 个积分。 当你将所有盒子都去掉之后，求你能获得的最大积分和。
示例：
输入：boxes = [1,3,2,2,2,3,4,3,1]输出：23解释：[1, 3, 2, 2, 2, 3, 4, 3, 1] ----&amp;gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) ----&amp;gt; [1, 3, 3, 3, 1] (1*1=1 分) ----&amp;gt; [1, 1] (3*3=9 分) ----&amp;gt; [] (2*2=4 分)提示：
 1 &amp;lt;= boxes.length &amp;lt;= 100 1 &amp;lt;= boxes[i] &amp;lt;= 100  思路 区间dp，记忆化搜索。
令 $dp[l][r][k]$ 表示消除区间 $[l,r]$ 内的所有盒子，以及消除 $r$ 之后 $k$ 个等于 $A_r$ 的盒子组成的序列的最大积分，则当前值为 $A_r$ 的盒子有 $(k+1)$ 个，产生的价值为：$(k+1)^2$，则：</description>
    </item>
    
    <item>
      <title>LeetCode 336 回文对（字典树，思路）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-336-%E5%9B%9E%E6%96%87%E5%AF%B9%E5%AD%97%E5%85%B8%E6%A0%91%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Thu, 06 Aug 2020 09:28:51 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-336-%E5%9B%9E%E6%96%87%E5%AF%B9%E5%AD%97%E5%85%B8%E6%A0%91%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：回文对
给定一组唯一的单词， 找出所有*不同* 的索引对 (i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。
示例 1:
输入: [&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;]输出: [[0,1],[1,0],[3,2],[2,4]] 解释: 可拼接成的回文串为 [&amp;quot;dcbaabcd&amp;quot;,&amp;quot;abcddcba&amp;quot;,&amp;quot;slls&amp;quot;,&amp;quot;llssssll&amp;quot;]示例 2:
输入: [&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;]输出: [[0,1],[1,0]] 解释: 可拼接成的回文串为 [&amp;quot;battab&amp;quot;,&amp;quot;tabbat&amp;quot;]思路  枚举所有的串，利用某种数据结构，存储后缀是否存在 对于每个串，假设一个串的取值范围是 [0,m-1]，以 j为界，把串分成两个子串 [0,j-1]和 [j,m-1] 处理这两个子串，如果 [0,j-1]是回文串，那么只需要找到 [j,m-1]这个串的镜像串，这样就可以组成一个大回文串。同理 [j,m-1]回文，那么只需要找到 [0,j-1]的镜像串，保存答案即可。  对于存储后缀，可以用哈希也可以用字典树，对于这种如果数据量太大的话，无意字典树更节省空间。
本代码采用标程中给的字典树。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  class Solution { public: struct node { int ch[26]; int flag; node() { flag = -1; memset(ch, 0, sizeof(ch)); } }; vector&amp;lt;node&amp;gt; tree; void insert(string &amp;amp;s, int id) { int len = s.</description>
    </item>
    
    <item>
      <title>LeetCode 337 打家劫舍 III（树形dp）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii%E6%A0%91%E5%BD%A2dp/</link>
      <pubDate>Wed, 05 Aug 2020 01:07:53 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii%E6%A0%91%E5%BD%A2dp/</guid>
      <description>题目链接：打家劫舍 III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
示例 1:
输入: [3,2,3,null,3,null,1]3/ \2 3\ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.示例 2:
输入: [3,4,5,1,3,null,1]3/ \4 5/ \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.思路 树形dp裸题。
题目给出一棵二叉树，每一个点有一个权值，你需要选择树上的一些点，选择的两个点不能相邻，问可以取到的最大权值是多少。这个题意大概是 POJ2342 的变形。
我们定义：
 dp[node][0] 代表以 node为根，不选 node 这个点可以取到的最大权值。 dp[node][1] 代表以 node为根，选择 node 这个点可以取到的最大权值。  遍历其子节点，记为 son，则可以得到状态转移方程：</description>
    </item>
    
    <item>
      <title>LeetCode 207 课程表(拓扑排序)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 04 Aug 2020 01:19:39 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接：课程表
你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]
给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？
示例 1:
输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2:
输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。提示：
 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &amp;lt;= numCourses &amp;lt;= 10^5  思路 这种有先决顺序的工程安排问题一般就是拓扑排序，这道题是拓扑排序的裸题。
方法1：删入度，bfs
拓扑排序有一个显然的算法，每次删除有向无环图中的入度为0的点，直到没有入度为0的点为止。因为如果存在环，则一个点必将同时有入度和出度。
所以这个算法在实现的时候可以使用一个队列，每次把入度为0的点加入队列中，然后遍历这个点所有的出边，并删除掉这个点的入度。如果点的进队次数等于点数，则证明此图无环。
方法2：深搜
每一个点开始进行深搜，如果搜到了自己，则存在环。
不存在环时再搜的过程中需要标记路线。
代码 bfs删入度：</description>
    </item>
    
    <item>
      <title>LeetCode 632 最小区间(贪心，堆)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E5%A0%86/</link>
      <pubDate>Mon, 03 Aug 2020 01:50:13 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E5%A0%86/</guid>
      <description>题目链接：最小区间
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a &amp;lt; d-c 或者在 b-a == d-c 时 a &amp;lt; c，则区间 [a,b] 比 [c,d] 小。
示例 1:
输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]输出: [20,24]解释: 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。注意:
 给定的列表可能包含重复元素，所以在这里升序表示 &amp;gt;= 。 1 &amp;lt;= k &amp;lt;= 3500 -105 &amp;lt;= 元素的值 &amp;lt;= 105 对于使用Java的用户，请注意传入类型已修改为List&amp;lt;List&amp;gt;。重置代码模板后可以看到这项改动。  思路 题意可以等价转化为：从k个数组中每个数组中找出一个数，使得其中的最大值与最小值的差值最小。</description>
    </item>
    
    <item>
      <title>LeetCode 392 判断子序列(dp)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97dp/</link>
      <pubDate>Mon, 27 Jul 2020 01:32:09 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97dp/</guid>
      <description>题目链接：判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &amp;lt;=100）。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&amp;quot;ace&amp;quot;是 &amp;quot;abcde&amp;quot;的一个子序列，而 &amp;quot;aec&amp;quot;不是）。
**示例 1:**s = &amp;quot;abc&amp;quot;, t = &amp;quot;ahbgdc&amp;quot;
返回 true.
**示例 2:**s = &amp;quot;axc&amp;quot;, t = &amp;quot;ahbgdc&amp;quot;
返回 false.
后续挑战**:**
如果有大量输入的 S，称作S1, S2, &amp;hellip; , Sk 其中 k &amp;gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
致谢:
特别感谢 @pbrother 添加此问题并且创建所有测试用例。
思路 方案1：双指针 直接模拟，挨个试就行
方案2：dp 定义 dp[i][j]表示从位置 i开始往后的字符 j第一次出现的位置。则在状态转移过程中，如果t中位置为 i的字符就是 j，则$dp[i][j]=j$，否则$dp[i][j]=dp[i+1][j]$，所以需要从后往前枚举。</description>
    </item>
    
    <item>
      <title>LeetCode 410 分割数组的最大值(二分,dp)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%BA%8C%E5%88%86dp/</link>
      <pubDate>Sat, 25 Jul 2020 17:31:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%BA%8C%E5%88%86dp/</guid>
      <description>题目链接：分割数组的最大值
给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。
注意: 数组长度 n 满足以下条件:
 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n)  示例:
输入:nums = [7,2,5,10,8]m = 2输出:18解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。思路 方案一：二分 枚举满足题意的和的最大值，每一次check按照贪心原则最大化分段，如果最后分段出来的段的数量大于0，代表右区间可以缩小，反之左区间增大。
时间复杂度：$O(n*log(sum-max_n))$
方案二：dp 定义 dp[i][j]表示把前$i$个数分成$j$段，所能达到的段内和的最大值最小的值。
则考虑第 j段的范围，可以枚举k，把第 j段分为：[0,k]和 [k+1,j]这两段，则 dp[i][j]的值就等于 [0,k]这一段的最优解的值与 [k+1,j]这一段的和的最大值，枚举k，使这个值最小即可，即：
$ dp[i][j] = min(dp[i][j], max(dp[k][j - 1], sub[i] - sub[k]))$
对于 [k+1,j]这一段的和，可以预处理出前缀和，直接做减法得到。
时间复杂度：$O(n^2m)$
代码 方案一：二分代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public: bool check(vector&amp;lt;int&amp;gt; &amp;amp;nums, int m, int target) { long long i = 0, sum = 0; while (i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>LeetCode 210 课程表 II（拓扑排序）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 17 May 2020 00:57:15 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接：课程表 II
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
示例 1:
输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:
输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明:
 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。  提示:
 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。  思路 这题算是一个拓扑排序的裸题。如果存在环，就输出空，不存在环就输出正确的顺序。</description>
    </item>
    
    <item>
      <title>LeetCode 560 和为K的子数组(前缀和，思路)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 15 May 2020 00:47:06 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：和为K的子数组
给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :
 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。  思路 有多少个子数组的区间和为 k，假设要统计区间 $[l,r]$ 中的区间和为 k 的数量，我们先对数组求一个前缀和，易得： $$sum[r]-sum[l-1]=k$$ 移项得： $$sum[l-1]=sum[r]-k$$ 其中k是题目中已经给出的，sum[r]是当前求的前缀和的那一项，所以我们只需要累加sum[l-1]的个数即可。用一个哈希存一下前缀和的个数，求前缀和时因为满足l&amp;lt;r，所以不需要开数组，一直累加即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int subarraySum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { unordered_map&amp;lt;long long, int&amp;gt; mp; mp[0] = 1; long long sum = 0, ans = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>LeetCode 236 二叉树的最近公共祖先(递归)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%80%92%E5%BD%92/</link>
      <pubDate>Sun, 10 May 2020 01:00:01 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。说明:
 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。  思路 乍一看是LCA的板子题，对于LCA问题，我们一般用 离线tarjan或者在线倍增来处理，或者用树链剖分
这几种算法，可以在我的ACM模板中找到 最近公共祖先</description>
    </item>
    
    <item>
      <title>LeecCode 221 最大正方形(dp)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leeccode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2dp/</link>
      <pubDate>Fri, 08 May 2020 01:56:15 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leeccode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2dp/</guid>
      <description>题目链接：最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4思路 定义dp[i][j]代表以当前坐标(i,j)为正方形右下角的点的最大边长。
我们只需要考虑矩阵中为1的点，只有为1的点才会对答案产生影响，易得dp[i][0]=dp[0][j]=1
对于其他的点，可以由左,上,左上转移过来，对这三个值取最小值，再加上当前点就是答案。即：
$dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { public: int maximalSquare(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;matrix) { if (matrix.</description>
    </item>
    
    <item>
      <title>LeetCode 572 另一个树的子树(dfs,树哈希)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91dfs%E6%A0%91%E5%93%88%E5%B8%8C/</link>
      <pubDate>Thu, 07 May 2020 02:05:57 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91dfs%E6%A0%91%E5%93%88%E5%B8%8C/</guid>
      <description>题目链接：另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
示例 1: 给定的树 s:
 3/ \4 5/ \1 2给定的树 t：
 4 / \1 2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
示例 2: 给定的树 s：
 3/ \4 5/ \1 2/0给定的树 t：
 4/ \1 2返回 false。
思路 方法一：
刚一看这个题，没啥思路，一看难度是简单，就试着写了一发暴力，结果还过了，还超越了70%，那这题基本考察点应该就是暴力dfs了。</description>
    </item>
    
    <item>
      <title>LeetCode 983 最低票价(dp)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7dp/</link>
      <pubDate>Wed, 06 May 2020 01:14:04 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7dp/</guid>
      <description>题目链接：最低票价
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
 一张为期一天的通行证售价为 costs[0] 美元； 一张为期七天的通行证售价为 costs[1] 美元； 一张为期三十天的通行证售价为 costs[2] 美元。  通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
示例 1：
输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, .</description>
    </item>
    
    <item>
      <title>LeetCode 98 验证二叉搜索树（递归，中序遍历）</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 05 May 2020 01:03:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目链接：验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。  示例 1:
输入:2/ \1 3输出: true示例 2:
输入:5/ \1 4/ \3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4 。思路 方法一：
首先考虑递归的解法，要保证满足二叉搜索树的条件。需要保证左子树的每一个值都要小于当前节点，右子树的每一个值，都要大于当前节点。我们可以维护一个最小值和最大值的范围，当一个点满足小于最大值且大于最小值就是一颗BST。
方法二：
对这棵树进行一次中序遍历，如果是一颗BST，那么遍历结果肯定是一个递增的序列，我们检查一下这个序列是不是递增的即可。
代码 方法一：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: bool dfs(TreeNode *root, long long minn, long long maxx) { if (!</description>
    </item>
    
    <item>
      <title>LeetCode 45 跳跃游戏 II(贪心)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Mon, 04 May 2020 01:56:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii%E8%B4%AA%E5%BF%83/</guid>
      <description>题目链接：跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
示例:
输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明:
假设你总是可以到达数组的最后一个位置。
思路 题目已经给出总是可以到达最后一个位置。
我们考虑贪心的思路，比如样例，第一个数字为2，所以能到达的最大区间为 [i+1,i+nums[i]] ，也就是能跳到的范围为 [1,2]，我们肯定是想尽量到达的比较远，那么我们就从1,2这个区间选出跳的最远的，以这个点为起跳点进行跳，也就是样例中下标为1这个位置的值3，它所能到达的范围是[2,4]，由于2这个位置上一次起跳已经能跳到了，所以就是跳到下标为3或者4的地方时，下标需要加一。
我们维护一个当前能跳到的最远位置maxPos，和当前能跳到的边界end（在不超过end的范围内不用额外跳），遍历一遍数组即可。时间复杂度为$O(n)$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int maxPos = 0, n = nums.size(), end = 0, step = 0; for (int i = 0; i &amp;lt; n - 1; ++i) { if (maxPos &amp;gt;= i) { maxPos = max(maxPos, i + nums[i]); if (i == end) { end = maxPos; ++step; } } } return step; } };   </description>
    </item>
    
    <item>
      <title>LeetCode 1095 山脉数组中查找目标值(二分)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%E4%BA%8C%E5%88%86/</link>
      <pubDate>Wed, 29 Apr 2020 01:42:19 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%E4%BA%8C%E5%88%86/</guid>
      <description>题目链接：山脉数组中查找目标值
（这是一个 交互式问题 ）
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length &amp;gt;= 3
其次，在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：
 A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]  你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
 MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始） MountainArray.length() - 会返回该数组的长度  注意：
对 MountainArray.</description>
    </item>
    
    <item>
      <title>LeetCode 23 合并K个排序链表(堆)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%A0%86/</link>
      <pubDate>Sun, 26 Apr 2020 02:40:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%A0%86/</guid>
      <description>题目链接：合并K个排序链表
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
示例:
输入:[1-&amp;gt;4-&amp;gt;5,1-&amp;gt;3-&amp;gt;4,2-&amp;gt;6]输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6思路 题意很清楚，现在的问题就是应该怎么合并。
由于每一个链表都是递增的，所以我们维护这三个链表中的三个头节点，每次取出值最小放在最终的答案链表中，这个过程可以使用优先队列来维护，时间复杂度$O(kn*logk)$,空间复杂度为$O(k)$.
代码 优先队列：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public: struct status { ListNode *ptr; int val; bool operator&amp;lt;(const status &amp;amp;rhs) const { return val &amp;gt; rhs.</description>
    </item>
    
    <item>
      <title>LeetCode 面试题51 数组中的逆序对(线段树&#43;树状数组&#43;离散化)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%A6%BB%E6%95%A3%E5%8C%96/</link>
      <pubDate>Fri, 24 Apr 2020 02:40:25 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%A6%BB%E6%95%A3%E5%8C%96/</guid>
      <description>题目链接：数组中的逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
示例 1:
输入: [7,5,6,4]输出: 5限制：
0 &amp;lt;= 数组长度 &amp;lt;= 50000思路 逆序数的定义，题目已经给出。我们的核心诉求就是，对于每一项nums[i]，求出在这个数之前，比它大的数的个数，累加起来就是答案。我们考虑如何解决这个问题。
由于只给出了数字的数量，没有给出数字的大小范围，所以先用离散化处理一下，保证所有数的区间都在[1,50000]内。
方法1：线段树
首先此题可以用一个线段树来维护，线段树的功能是区间求和。依次遍历数组，先求出当前线段树中，大于当前遍历的nums[i]的数的个数，然后再把当前的数更新到线段树上去（为了保证线段树上的数都是遍历的数之前的），让树上的这个点加一，然后累加起来就是答案。
方法2：树状数组
顺着这个思路，我们可以同样考虑一下用树状数组来实现，离散化不用说。首先，要知道树状数组的功能是啥，功能是：单点更新，可以求出[1,n]的和。那么这个性质如何在逆序数中使用呢？考虑，数字的数量是固定的，对于当前遍历到的nums[i]，可以求出[1,num[i]]的和，代表比nums[i]小的数有多少个，那么i-sum(1,nums[i])就求出了它之前比它大的有多少个。同样也是边遍历边更新。
代码 线段树：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  class Solution { public: int sum[4 * 50001]; void pushup(int rt) { sum[rt] = sum[rt &amp;lt;&amp;lt; 1] + sum[rt &amp;lt;&amp;lt; 1 | 1]; } void build(int l, int r, int rt) { sum[rt] = 0; if (l == r) return; int m = (l + r) &amp;gt;&amp;gt; 1; build(l, m, rt &amp;lt;&amp;lt; 1); build(m + 1, r, rt &amp;lt;&amp;lt; 1 | 1); } void update(int p, int l, int r, int rt) { if (l == r) { sum[rt]++; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, l, m, rt &amp;lt;&amp;lt; 1); else update(p, m + 1, r, rt &amp;lt;&amp;lt; 1 | 1); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R) { return sum[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1; int ret = 0; if (L &amp;lt;= m) ret += query(L, R, l, m, rt &amp;lt;&amp;lt; 1); if (R &amp;gt; m) ret += query(L, R, m + 1, r, rt &amp;lt;&amp;lt; 1 | 1); return ret; } int reversePairs(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.</description>
    </item>
    
    <item>
      <title>LeetCode 面试题 08.11. 硬币(dp)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-08.11.-%E7%A1%AC%E5%B8%81dp/</link>
      <pubDate>Thu, 23 Apr 2020 01:48:52 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-08.11.-%E7%A1%AC%E5%B8%81dp/</guid>
      <description>题目链接：硬币
硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
示例1:
 输入: n = 5输出：2解释: 有两种方式可以凑成总金额:5=55=1+1+1+1+1示例2:
 输入: n = 10输出：4解释: 有四种方式可以凑成总金额:10=1010=5+510=5+1+1+1+1+110=1+1+1+1+1+1+1+1+1+1说明：
注意:
你可以假设：
 0 &amp;lt;= n (总金额) &amp;lt;= 1000000  思路 类似于完全背包，求方案数。
定义dp[n]表示用这些硬币凑成面额为n的方案数。如果需要凑出一个面额，假设当前硬币面额为v[i]，则方案数可以累加为：dp[n]+=dp[n-v[i]]，代表用已知的可以凑成n-v[i]面额的方案数加上当前的硬币面额，可以凑出n。
时间复杂度：$O(n)$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: int mod = 1e9 + 7; int v[4] = {1, 5, 10, 25}; int waysToChange(int n) { vector&amp;lt;int&amp;gt; dp(n + 1, 0); dp[0] = 1; for (int i = 0; i &amp;lt; 4; i++) for (int j = v[i]; j &amp;lt;= n; j++) dp[j] = (dp[j] + dp[j - v[i]]) % mod; return dp[n]; } };   </description>
    </item>
    
    <item>
      <title>LeetCode 199 二叉树的右视图(dfs)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEdfs/</link>
      <pubDate>Wed, 22 Apr 2020 01:49:22 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEdfs/</guid>
      <description>题目链接：二叉树的右视图
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例:
输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:1 &amp;lt;---/ \2 3 &amp;lt;---\ \5 4 &amp;lt;---思路 题目要求二叉树的右视图，直接用dfs遍历，那么我们就需要尽量往右找，因为可能右子树遍历完了，左子树的深度还有更深的。需要用一个哈希来记录一下，当前层是不是已经找到了最右边的点，找到了就标记一下，没找到就加入到答案的列表中。最后输出结果即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; ans; unordered_map&amp;lt;int, int&amp;gt; mp; void dfs(TreeNode *node, int deep) { if (!</description>
    </item>
    
    <item>
      <title>LeetCode 1248 统计「优美子数组」(前缀和，思路)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-1248-%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 21 Apr 2020 11:06:37 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-1248-%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：统计「优美子数组」
给你一个整数数组 nums 和一个整数 k。
如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。
请返回这个数组中「优美子数组」的数目。
示例 1：
输入：nums = [1,1,2,1,1], k = 3输出：2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。示例 2：
输入：nums = [2,4,6], k = 1输出：0解释：数列中不包含任何奇数，所以不存在优美子数组。示例 3：
输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2输出：16提示：
 1 &amp;lt;= nums.length &amp;lt;= 50000 1 &amp;lt;= nums[i] &amp;lt;= 10^5 1 &amp;lt;= k &amp;lt;= nums.length  思路 根据题意，偶数是没有用的，先预处理一下，通过 nums[i]&amp;amp;1 的方式处理成01字符串，题目就变成了有多少个子数组的区间和为k，假设要统计区间$[l,r]$中的区间和为k的数量，我们先对数组求一个前缀和，易得：$sum[r]-sum[l-1]=k$，移项得：$sum[l-1]=sum[r]-k$，其中k是题目中已经给出的，sum[r]是当前求的前缀和的那一项，所以我们只需要累加sum[l-1]的个数即可。用一个哈希存一下前缀和的个数，求前缀和时因为满足l&amp;lt;r，所以不需要开数组，一直累加即可。
和560题一模一样。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int numberOfSubarrays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { unordered_map&amp;lt;long long, int&amp;gt; mp; mp[0] = 1; int sum = 0, ans = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>LeetCode 466 统计重复个数(找循环节)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-466-%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/</link>
      <pubDate>Sun, 19 Apr 2020 14:30:15 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-466-%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/</guid>
      <description>题目链接：统计重复个数
由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[&amp;quot;abc&amp;quot;,3]=“abcabcabc”。
如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，&amp;ldquo;abc&amp;rdquo; 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。
现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。
请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。
示例：
输入：s1 =&amp;quot;acb&amp;quot;,n1 = 4s2 =&amp;quot;ab&amp;quot;,n2 = 2返回：2思路 题意翻译成白话就是给了你两个串s1和s2，然后问s1中最多包含多少个s2。其中，这两个串的给出方式是给一个前缀串和一个数字，最后的串等于前缀串重复几次。
思路就是找循环节，最后用除法计算一下出现了多少次，这一部分可以参考 官方题解 。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  class Solution { public: int getMaxRepetitions(string s1, int n1, string s2, int n2) { if (n1 == 0) return 0; int s1cnt = 0, s2cnt = 0, index = 0; // mp[index]={s1cnt,s2cnt}表示，第index个字符在遍历s1cnt次s1和s2cnt次s2出现的  unordered_map&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; mp; pair&amp;lt;int, int&amp;gt; pre, in; while (1) { s1cnt++; for (char ch : s1) { if (ch == s2[index]) { index++; if (index == s2.</description>
    </item>
    
    <item>
      <title>LeetCode 11 盛最多水的容器(双指针)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 18 Apr 2020 11:44:52 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>题目链接：盛最多水的容器
给你 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
**说明：**你不能倾斜容器，且 n 的值至少为 2。
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例：
输入：[1,8,6,2,5,4,8,3,7]输出：49思路 根据题意，对于题目的问题，我们假设左右端点为l和r，那么面积为：$S=(r-l)*min(height[l],height[r])$，我们需要求出最大的$S$。
做法是我们开始让l和r指向序列的头和尾，此时需要移动双指针，那么如何移动呢，做法是移动左右端点值比较小的那个，如果是左端点就向右移，如果是右端点就向左移，中途每算出一次面积，就求最大值，最后的结果就是答案。
那么如何证明这个策略的正确性呢，我们考虑，根据上面的公式，如果我们移动大的而不是小的，那么移动后$min(height[l],height[r])$的值并没有改变，只可能减小，不可能增大，因为我们进行了移动，则$(r-l)$一定会减小，这样的话，面积$S$一定会减小，所以我们的策略要移动小的，而不是大的。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int maxArea(vector&amp;lt;int&amp;gt; &amp;amp;height) { // s = (r-l)*min(a[l],a[r]) ,求 max(s)  int maxx = 0, l = 0, r = height.</description>
    </item>
    
    <item>
      <title>LeetCode 55 跳跃游戏(贪心)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Fri, 17 Apr 2020 11:46:08 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%BF%83/</guid>
      <description>题目链接：跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。示例 2:
输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。思路 刚开始看题感觉是个dp，于是没想到状态转移，写了发暴搜验证一下正确性，交了一下超时了。然后考虑了一下，这道题应该$O(n)$过，所以应该是个贪心了。
我们从第一个位置开始，维护一下最远能到达的位置，$O(n)$遍历，当当前位置不能到达的时候，那么肯定是到不了最后一个的，直接返回false，如果能正常遍历完，那么肯定是可以到最后一个位置的，代码特别简单。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int limit_pos = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>LeetCode 56 合并区间(贪心)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Thu, 16 Apr 2020 14:31:58 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</guid>
      <description>题目链接：合并区间
给出一个区间的集合，请合并所有重叠的区间。
示例 1:
输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].示例 2:
输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。思路 一个小贪心，把区间按照左端点排序。初始值设置为第一个区间的左和右。
然后遍历排序好的区间，如果遍历到的区间左端点小于等于r，就扩展r，等到不满足条件时证明这个区间最多就包含这么多，继续下一个区间即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public: static bool cmp(pair&amp;lt;int, int&amp;gt; a, pair&amp;lt;int, int&amp;gt; b) { return a.</description>
    </item>
    
    <item>
      <title>LeetCode 542 01 矩阵(BFS)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-542-01-%E7%9F%A9%E9%98%B5bfs/</link>
      <pubDate>Wed, 15 Apr 2020 11:44:49 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-542-01-%E7%9F%A9%E9%98%B5bfs/</guid>
      <description>题目链接：01 矩阵
给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
示例 1: 输入:
0 0 00 1 00 0 0输出:
0 0 00 1 00 0 0示例 2: 输入:
0 0 00 1 01 1 1输出:
0 0 00 1 01 2 1注意:
 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。  思路 广搜BFS，和 1162 地图分析有点像，题目要求出每个元素与0最近的距离是多少，那么不用问，肯定值为0的点的距离还是0，其余的可以搜出来。
首先把值为0的坐标全部入队，像四个方向搜索，如果是1，当前的步数就+1，如果是0，那步数不变，只需要在搜索的时候，一直给答案的距离与当前步数取最小值即可。</description>
    </item>
    
    <item>
      <title>LeetCode 887 鸡蛋掉落(dp,记忆化搜索，二分)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BDdp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%88%86/</link>
      <pubDate>Sat, 11 Apr 2020 15:59:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BDdp%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%88%86/</guid>
      <description>题目链接：鸡蛋掉落
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。
你的目标是确切地知道 F 的值是多少。
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
示例 1：
输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。示例 2：</description>
    </item>
    
    <item>
      <title>LeetCode 22 括号生成(递归)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 09 Apr 2020 11:55:17 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：
输入：n = 3输出：[&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;]思路 方法1：暴力 观察易得，符合括号序列和$n$的关系是，括号序列的个数有$2^{2n}$个，我们先把所有$2^{2n}$的括号全部打表打出来，然后再检验是否合法，最后输出合法的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  class Solution { public: bool valid(string &amp;amp;str) { int balance = 0; for (char c : str) { if (c == &amp;#39;(&amp;#39;) balance++; else { balance--; if (balance &amp;lt; 0) return false; } } return balance == 0; } void generate_all(string &amp;amp;cur, int n, vector&amp;lt;string&amp;gt; &amp;amp;result) { if (n == cur.</description>
    </item>
    
    <item>
      <title>LeetCode 72 编辑距离(dp)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBdp/</link>
      <pubDate>Mon, 06 Apr 2020 11:50:20 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBdp/</guid>
      <description>题目链接：编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
 插入一个字符 删除一个字符 替换一个字符  示例 1：
输入：word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot;输出：3解释：horse -&amp;gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&amp;gt; rose (删除 &#39;r&#39;)rose -&amp;gt; ros (删除 &#39;e&#39;)示例 2：
输入：word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot;输出：5解释：intention -&amp;gt; inention (删除 &#39;t&#39;)inention -&amp;gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&amp;gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&amp;gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&amp;gt; execution (插入 &#39;u&#39;)思路 简单dp，定义dp[i][j]代表把第一个串的前i个字符，变成第2个串的前j个字符，需要花费的代价。</description>
    </item>
    
    <item>
      <title>LeetCode 460 LFU缓存(模拟)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-460-lfu%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Mon, 06 Apr 2020 11:49:42 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-460-lfu%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目描述：LFU缓存
设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。
get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。 put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。
一个项目的使用次数就是该项目被插入后对其调用 get 和 put 函数的次数之和。使用次数会在对应项目被移除后置为 0。
进阶： 你是否可以在 O(1) 时间复杂度内执行两项操作？
示例：
LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 去除 key 2cache.get(2); // 返回 -1 (未找到key 2)cache.get(3); // 返回 3cache.put(4, 4); // 去除 key 1cache.get(1); // 返回 -1 (未找到 key 1)cache.</description>
    </item>
    
    <item>
      <title>LeetCode 289 接雨水(单调栈)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-289-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Mon, 06 Apr 2020 11:48:56 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-289-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>题目链接：接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6思路 用单调栈的思路，维护一个递减的单调栈，当不满足递减条件的时候，每弹出一个元素，就计算出这一块区域能接的水量，最后的和就是答案，复杂度为$O(n)$
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { int ans = 0; stack&amp;lt;int&amp;gt; st; for (int i = 0; i &amp;lt; height.size(); i++) { while (!st.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[st.</description>
    </item>
    
    <item>
      <title>LeetCode 289 生命游戏(模拟)</title>
      <link>https://caixiongjiang.github.io/blog/2020/leetcode-289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Thu, 02 Apr 2020 14:40:49 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2020/leetcode-289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目链接：生命游戏
根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；  根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。
示例：
输入：
[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]输出：
[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]进阶：
你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？
思路 中文题意，刚开始看到题以为是个搜索之类的，用手推了一下样例。发现一个格子的状态改变不会，以后的格子计算状态还是按照格子上原来的数字计算状态的，所以问题就非常简单了，把原数组复制一遍，计算八个方向的活细胞的数量，直接按照题意改一下活细胞或死细胞状态即可，最后用复制出来的数组覆盖原数组。
或者也可以不复制数组，直接在原数组上做一些标记也可以实现。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Solution { public: int go[8][2] = {1, 0, -1, 0, 0, 1, 0, -1, 1, 1, 1, -1, -1, 1, -1, -1}; void gameOfLife(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;board) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; grid = board; int n = board.</description>
    </item>
    
    <item>
      <title>LeetCode 76 最小覆盖子串(尺取法)</title>
      <link>https://caixiongjiang.github.io/blog/2019/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%E5%B0%BA%E5%8F%96%E6%B3%95/</link>
      <pubDate>Sat, 16 Mar 2019 10:43:40 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%E5%B0%BA%E5%8F%96%E6%B3%95/</guid>
      <description>题目链接：最小覆盖子串
给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。
示例：
输入: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot;输出: &amp;quot;BANC&amp;quot;说明：
 如果 S 中不存这样的子串，则返回空字符串 &amp;quot;&amp;quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。  思路 (滑动窗口) $O(n)$ 首先用哈希表统计出 $T$ 中所有字符出现的次数。 然后我们用两个指针 $i, j(i \ge j)$来扫描整个字符串，同时用一个哈希表统计 $i, j$ 之间每种字符出现的次数，每次遍历需要的操作如下：
 加入 $s[i]$，同时更新哈希表； 检查 $s[j]$ 是否多余，如果是，则移除 $s[j]$； 检查当前窗口是否已经满足 $T​$ 中所有字符，如果是，则更新答案；  时间复杂度分析：两个指针都严格递增，最多移动 $n$ 次，所以总时间复杂度是 $O(n)$。
思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public: //s中最短的一段，包含t中的所有字符  string minWindow(string s, string t) { string res; unordered_map&amp;lt;char, int&amp;gt; S, T; int total = t.</description>
    </item>
    
    <item>
      <title>LeetCode 726 原子的数量(递归,map)</title>
      <link>https://caixiongjiang.github.io/blog/2019/leetcode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F%E9%80%92%E5%BD%92map/</link>
      <pubDate>Sat, 16 Mar 2019 10:43:15 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/leetcode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F%E9%80%92%E5%BD%92map/</guid>
      <description>题目链接：原子的数量
给定一个化学式formula（作为字符串），返回每种原子的数量。
原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。
如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。
两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。
一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。
给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。
示例 1:
输入: formula = &amp;quot;H2O&amp;quot;输出: &amp;quot;H2O&amp;quot;解释: 原子的数量是 {&#39;H&#39;: 2, &#39;O&#39;: 1}。示例 2:
输入: formula = &amp;quot;Mg(OH)2&amp;quot;输出: &amp;quot;H2MgO2&amp;quot;解释: 原子的数量是 {&#39;H&#39;: 2, &#39;Mg&#39;: 1, &#39;O&#39;: 2}。示例 3:
输入: formula = &amp;quot;K4(ON(SO3)2)2&amp;quot;输出: &amp;quot;K4N2O14S4&amp;quot;解释: 原子的数量是 {&#39;K&#39;: 4, &#39;N&#39;: 2, &#39;O&#39;: 14, &#39;S&#39;: 4}。注意:</description>
    </item>
    
    <item>
      <title>POJ3249 Test for Job(拓扑排序，dp)</title>
      <link>https://caixiongjiang.github.io/blog/2019/poj3249-test-for-job%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp/</link>
      <pubDate>Sun, 03 Mar 2019 20:57:03 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/poj3249-test-for-job%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp/</guid>
      <description>Description  Mr.Dog was fired by his company. In order to support his family, he must find a new job as soon as possible. Nowadays, It&amp;rsquo;s hard to have a job, since there are swelling numbers of the unemployed. So some companies often use hard tests for their recruitment.
The test is like this: starting from a source-city, you may pass through some directed roads to reach another city. Each time you reach a city, you can earn some profit or pay some fee, Let this process continue until you reach a target-city.</description>
    </item>
    
    <item>
      <title>POJ2796 Feel Good(单调栈)</title>
      <link>https://caixiongjiang.github.io/blog/2019/poj2796-feel-good%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Sun, 03 Mar 2019 20:55:30 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/poj2796-feel-good%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>Description  Bill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent people&amp;rsquo;s memories about some period of life.
A new idea Bill has recently developed assigns a non-negative integer value to each day of human life.
Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it.</description>
    </item>
    
    <item>
      <title>LeetCode 4. Median of Two Sorted Arrays(思路，递归)</title>
      <link>https://caixiongjiang.github.io/blog/2019/leetcode-4.-median-of-two-sorted-arrays%E6%80%9D%E8%B7%AF%E9%80%92%E5%BD%92/</link>
      <pubDate>Sat, 02 Mar 2019 16:43:22 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/leetcode-4.-median-of-two-sorted-arrays%E6%80%9D%E8%B7%AF%E9%80%92%E5%BD%92/</guid>
      <description>题目链接：寻找两个有序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:
nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:
nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5思路 (递归) $O(log(n + m))$ 原问题难以直接递归求解，所以我们先考虑这样一个问题：
 在两个有序数组中，找出第k大数。
 如果该问题可以解决，那么第 $(n + m) / 2$ 大数就是我们要求的中位数.
先从简单情况入手，假设 $m, n \geq k/2$，我们先从 $nums1$ 和 $nums2$ 中各取前 $k/2$ 个元素：</description>
    </item>
    
    <item>
      <title>LeetCode 440. K-th Smallest in Lexicographical Order(思路)</title>
      <link>https://caixiongjiang.github.io/blog/2019/leetcode-440.-k-th-smallest-in-lexicographical-order%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 01 Mar 2019 09:03:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/leetcode-440.-k-th-smallest-in-lexicographical-order%E6%80%9D%E8%B7%AF/</guid>
      <description>题目链接：440. K-th Smallest in Lexicographical Order
Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.
Note: 1 ≤ k ≤ n ≤ 109.
Example:
Input:n: 13 k: 2Output:10Explanation:The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.思路 题目的意思就是求从 1 到 n 中字典序为 k 的那个数.</description>
    </item>
    
    <item>
      <title>HihoCoder - 1044 状态压缩一 (状压dp)</title>
      <link>https://caixiongjiang.github.io/blog/2019/hihocoder-1044-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%B8%80-%E7%8A%B6%E5%8E%8Bdp/</link>
      <pubDate>Tue, 29 Jan 2019 16:07:37 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/hihocoder-1044-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%B8%80-%E7%8A%B6%E5%8E%8Bdp/</guid>
      <description>描述  小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即将举行美食节！
但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。
不仅如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。
小Hi和小Ho本着礼让他们的心情——当然还因为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。
将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多的清扫垃圾。
小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可能多的垃圾。
提示一：无论是什么动态规划，都需要一个状态转移方程！
提示二：好像什么不对劲？状态压缩哪里去了？
 输入  每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。
每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。
对于100%的数据，满足N&amp;lt;=1000, 2&amp;lt;=M&amp;lt;=10,1&amp;lt;=Q&amp;lt;=M, Wi&amp;lt;=100
 输出  对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。
 样例输入 5 2 136 9 80 69 85 样例输出 201思路 题意是给出有 $n$ 个数的数组，每一个位置有一个权值 $w[i]$ ，现在你需要选择一些位置，使得取得的权值和最大。
选择位置的条件是：对于任意长度为 $m$ 的区间，选择的位置的数量必须小于等于 $q$ 个。
思路是状态压缩。因为 $m$ 的范围是 $10$ ,那么用二进制的思想，二进制为 $1$ 表示当前位置被选择，为 $0$ 表示没有被选择，那么一共需要 $m$ 个二进制位来表示状态，那么压缩成十进制，就需要 $2^m-1$ 个状态来表示。
定义：
 $dp[i][j]$ 表示前 $i$ 个位置，选择的状态为 $j$ 时所能达到的最大价值。 $j$ 表示的状态是，以第 $i$ 个位置为结尾的连续 $m$ 个位置的选取状态。  举个例子，假设当 $m=3$ 时，所有的状态为：</description>
    </item>
    
    <item>
      <title>牛客网-拼多多2018笔试 迷宫寻路(状态压缩&#43;bfs)</title>
      <link>https://caixiongjiang.github.io/blog/2019/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%8B%BC%E5%A4%9A%E5%A4%9A2018%E7%AC%94%E8%AF%95-%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9bfs/</link>
      <pubDate>Sat, 19 Jan 2019 20:17:59 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2019/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%8B%BC%E5%A4%9A%E5%A4%9A2018%E7%AC%94%E8%AF%95-%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9bfs/</guid>
      <description>题目来源：迷宫寻路
题目描述  假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是路。迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。请设计一个算法，帮助探险家找到脱困的最短路径。如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下 0-墙，1-路，2-探险家的起始位置，3-迷宫的出口，大写字母-门，小写字母-对应大写字母所代表的门的钥匙
 输入描述:  迷宫的地图，用二维矩阵表示。第一行是表示矩阵的行数和列数M和N 后面的M行是矩阵的数据，每一行对应与矩阵的一行（中间没有空格）。M和N都不超过100, 门不超过10扇。
 输出描述:  路径的长度，是一个整数
 输入 5 50211101a0A010030100101111输出 7思路 简单状压，利用10个二进制位，遇到一个门，检查一下能不能开门，不能开门就不能走。遇到钥匙的时候用位运算「或」把这个状态添加进去，bfs 搜出来的就是结果。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Good Bye 2018 C. New Year and the Sphere Transmission(数学)</title>
      <link>https://caixiongjiang.github.io/blog/2018/good-bye-2018-c.-new-year-and-the-sphere-transmission%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Mon, 31 Dec 2018 16:41:02 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2018/good-bye-2018-c.-new-year-and-the-sphere-transmission%E6%95%B0%E5%AD%A6/</guid>
      <description>题目链接：C. New Year and the Sphere Transmission
 There are $n$ people sitting in a circle, numbered from $1$ to $n$ in the order in which they are seated. That is, for all $i$ from $1$ to $n-1$, the people with id $i$ and $i+1$ are adjacent. People with id $n$ and $1$ are adjacent as well.
The person with id $1$ initially has a ball. He picks a positive integer $k$ at most $n$, and passes the ball to his $k$-th neighbour in the direction of increasing ids, that person passes the ball to his $k$-th neighbour in the same direction, and so on until the person with the id $1$ gets the ball back.</description>
    </item>
    
    <item>
      <title> 牛客网-网易2017笔试 合唱团(dp)</title>
      <link>https://caixiongjiang.github.io/blog/2018/-%E7%89%9B%E5%AE%A2%E7%BD%91-%E7%BD%91%E6%98%932017%E7%AC%94%E8%AF%95-%E5%90%88%E5%94%B1%E5%9B%A2dp/</link>
      <pubDate>Sun, 30 Dec 2018 16:16:00 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2018/-%E7%89%9B%E5%AE%A2%E7%BD%91-%E7%BD%91%E6%98%932017%E7%AC%94%E8%AF%95-%E5%90%88%E5%94%B1%E5%9B%A2dp/</guid>
      <description>题目来源:合唱团
题目描述  有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？
 输入描述:  每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &amp;lt;= n &amp;lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &amp;lt;= ai &amp;lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &amp;lt;= k &amp;lt;= 10, 1 &amp;lt;= d &amp;lt;= 50)。
 输出描述:  输出一行表示最大的乘积。
 输入 37 4 72 50输出 49思路 给出 n 个数字，要求按顺序选择 k 个，使得选出的数的乘积最大。且要求选择的相邻两个人的距离必须小于等于 d.
定义 dp[n][k] 为以位置为 n 的人为结尾（位置为 n 的人就是选择的第k个人），选择 k 个人(包括自己)所能获得的最大乘积</description>
    </item>
    
  </channel>
</rss>
