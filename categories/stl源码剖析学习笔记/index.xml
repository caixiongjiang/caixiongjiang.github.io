<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>《STL源码剖析》学习笔记 on 🌀Jarson Cai&#39;s Blog</title>
    <link>https://caixiongjiang.github.io/categories/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 《STL源码剖析》学习笔记 on 🌀Jarson Cai&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 08 Apr 2022 18:18:05 +0800</lastBuildDate><atom:link href="https://caixiongjiang.github.io/categories/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《STL源码剖析》第六讲 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC6%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC6%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第六讲：迭代器设计的原则&amp;amp;iterator traits的作用与设计 iterator traits iterator traits是为了提取出迭代器的特点，迭代器必须有能力回答algorithm提出的问题。
c++标准库设计了5种回答方式,集成在class中（迭代器相关的类型，迭代器模版中本身必须定义出来）：
 iterator_category：迭代器的类型，具体表现在能否++或者&amp;ndash;或者一下加减很多步 difference_type：代表两个iterator的距离应该用什么type来表现（随机访问：unsign interger，实现链表的都用ptrdiff_t类型） value_type：iterator所指元素的类型 reference：引用（暂未使用） pointer：指针（暂未使用）  但如果iterator本身不是class，例如native pointer（退化的iterator），如何回答算法的5个问题？
iterator traits用于分离class iiterators和non-class iterators</description>
    </item>
    
    <item>
      <title>《STL源码剖析》第五讲 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC5%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 13:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC5%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第五讲：深入理解容器 容器的结构再分类  heap 和 priority_queue中有vector的结构 stack 和 queue中有deque的结构 set 和 map系列有rb_tree的结构 unordered系列容器中有hashtable的结构 在c++11中：slist &amp;ndash;&amp;gt; forward_list； hash_~ &amp;ndash;&amp;gt; unordered_~。  深度探索list list（环状双向链表）其本身是一个指针，指向一个node节点，其结构为两个指针（一个向前一个向后）+数据值
1  sizeof(list&amp;lt;int&amp;gt;()) //其值为4Bytes（GNU2.9） 8Bytes(GNU4.9)   list的结构  node的设计（GNU2.9）：  1 2 3 4 5 6 7  tempalate&amp;lt;class T&amp;gt; struct __list_node { typedef void* void_pointer;//一个空的指针置于尾端的一个空白节点，符合&amp;#34;前闭后开&amp;#34;的要求  void_pointer prev;//向前的指针  void_pointer next;//向后的指针  T data;//数据 };    iterator的设计（GNU2.9）：  1 2 3 4 5 6 7 8  tempalte&amp;lt;class T, class Ref, class Ptr&amp;gt; struct __list_iterator { typedef T value_type; typedef Ptr pointer; typedef Ref reference; ··· //具体看《STL源码剖析》p131 };   G4.</description>
    </item>
    
    <item>
      <title>《STL源码剖析》第四讲 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC4%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 10:54:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC4%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第四讲：深入理解分配器 operator new() &amp;amp; malloc() operator() new会调用malloc(), malloc()作用是分配内存。
看图：
size部分为我们所需要的内存，可以看出malloc()分配的内存比所需要的内存多。多分配的内存空间如果称为开销的话，也就是说我们的单个内存越大，开销所占比例就越小！
分配器最重要的两个函数：allocate &amp;amp; deallocate VC++下和BC++下：
申请内存：allocator--&amp;gt;operator new()--&amp;gt;malloc()释放内存：deallocator--&amp;gt;operator delete()--&amp;gt;free()分配512个int整数：
1 2  int *p = allocator&amp;lt;int&amp;gt;().allocate(512, (int*)0); allocator&amp;lt;int&amp;gt;().deallocate(p, 512);   注：一个type +（）形成了一个临时对象，才能调用其中的成员函数。举例：queue&amp;lt;int&amp;gt;()
alloc的优点 GNU2.9下：
申请内存：allocator--&amp;gt;allocate()--&amp;gt;operator new()--&amp;gt;malloc()释放内存：deallocator--&amp;gt;deallocate()-&amp;gt;operator delete()--&amp;gt;free()注：虽然GNU标准allocator被设计出来，但它的容器基本都不用标准的allocator，而是使用alloc
 使用malloc()和free()会带来很大的额外开销，如果区块小，开销比例会很大。 额外开销中的cookie记录内存的大小，但因为容器元素的大小是一样的，所以alloc使用一个长链表（i = 0～15），第i个对应cookie大小为8(i + 1)Bytes的内存大小，容器的内存大小会被调整为8的倍数，这样就只需要用少量cookie来记录内存大小！ 所以使用alloc存放1000000个元素，可以省掉cookie开销大约8000000个Bytes  GNU4.9下：
 容器使用的分配器又变为了allocator，继承于new_allocator，使用operator new() 和 operator delete() 2.9下的alloc被更名为__pool_alloc，属于__gnu_cxx::__pool_alloc  </description>
    </item>
    
    <item>
      <title>《STL源码剖析》第三讲 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC3%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 15:21:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC3%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第三讲:泛型编程和模版技术 源代码之分布  VC的标准库文件夹:   GNU c++标准库文件夹:  OOP(面向对象编程) vs GP(泛型编程)   OOP将datas和methods关联在一起（成员变量和成员函数都放在类里面） demo:list内部本身存在有sort()算法，使用语法如下：
1  c.sort()     GP是将datas和methods分开来
demo：vector和deque内部都没有sort()函数，sort()函数是放在算法里面的，使用语法如下：
1  ::sort(c.begin(), c.end());   注：list本身是链式容器，无法支持随机访问，所以需要本身自己重新定义sort()。
  采用GP的好处：
 容器和算法团队可以各自写自己的东西，其间用迭代器来进行关联。 算法通过迭代器确定操作范围，并通过迭代器取用容器的元素。 两个石头如何比较大小不需要类来决定，而是用仿函数来决定。    max()算法的demo：
第二个版本的参数3接收的是函数对象或者是仿函数，用于自定义的比较规则制定！
  操作符重载复习 操作符操作单个数或者多个数，以及能否成为类内部的成员函数
模版Template复习  类模版:   函数模版:   成员模版  模版中泛化 vs 特化  泛化的特点是可以接收大多数type的数据结构 特化的特点是为了某些特殊的数据（数据有不同的特点）进行的模版中特殊化的写法  demo:
特化中的偏特化（局部特化）  个数的偏特化:   范围的偏特化：  </description>
    </item>
    
    <item>
      <title>《STL源码剖析》第二讲 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC2%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 10:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC2%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第二讲:容器之分类及各种测试 容器结构及分类  序列式容器  数组（Array）：定长数组，无法扩充 vector：可扩充的数组（分配器做内存扩充） Deque：双端队列 List：双向链表 Forward-List：单向链表   关联式容器（key-&amp;gt;value）  Set/Multiset（Multiset中的值可以重复）：内部为红黑数 Map/Multimap（Multimap中的value值可以重复）：内部为红黑树   无序容器（unordered,大类上属于关联式容器）  介绍一个常用的结构hashtable：根据公式进行分类， 但会产生碰撞， 产生碰撞的元素全部放在一个链表中。但如果链表太长如何做呢？后面会继续介绍。
先写用于测试的几个辅助函数:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  using std::cin; using std::cout; using std::string; long get_a_target_long() { long target = 0; cout &amp;lt;&amp;lt; &amp;#34;target (0~&amp;#34; &amp;lt;&amp;lt; RAND_MAX &amp;lt;&amp;lt; &amp;#34;):&amp;#34;; return target; } string get_a_target_string() { long target = 0; char buf[10]; cout &amp;lt;&amp;lt; &amp;#34;target (0~&amp;#34; &amp;lt;&amp;lt; RAND_MAX &amp;lt;&amp;lt; &amp;#34;):&amp;#34;; cin &amp;gt;&amp;gt; target; //snprintf功能为格式化成字符串  // 1-- 目标字符串 2 -- 拷贝字节数 3 -- 格式化成字符串。4 -- 可变参数。  snprintf(buf, 10, &amp;#34;%d&amp;#34;, target); return string(buf); } //比较两个long数据是否相等 int compareLongs(const void* a, const void* b) { return (*(long*)a - *(long*)b); } //比较两个string数据是否相等 int compareStrings(const void* a, const void* b) { if(*(string*)a &amp;gt; *(string*)b) return 1; else if(*(string*)a &amp;lt; *(string*)b) return -1; else return 0; }   顺序容器使用及测试   使用容器array：array.</description>
    </item>
    
    <item>
      <title>《STL源码剖析》第一讲 学习笔记</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC1%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 08:15:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC1%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第一讲:STL体系结构介绍 c++标准库 vs c++ Standard Library 总体来说 c++标准库 &amp;gt; c++ Standard Library
标准库以头文件（.h）的形式呈现:
 c++标准库的header files不带副档名（.h）, 例如#include  新式c header files 不带副档名（.h），例如 #include  旧式c header files 带有副档名（.h）仍然可用，例如 #include &amp;lt;stdio.h&amp;gt; 新式headers内的组件封装为 namespace &amp;ldquo;std&amp;rdquo;  using namespace std;（相当于把std文件全部打开） using std::cout;   旧式headers内的组件不封装在namespace &amp;ldquo;std&amp;rdquo;  demo：
1 2 3 4 5 6  #include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;   重要的网站（c++标准库）  cplusplus.com cppreference.com gcc.gnu.org  STL六大部件  容器（containers） 分配器（allocators） 算法（algorithms） 迭代器（iterators） 适配器（addpters） 仿函数（functors）  六大部件的关系：</description>
    </item>
    
  </channel>
</rss>
