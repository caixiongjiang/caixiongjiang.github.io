<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据密集型应用系统设计 on 🌀riba2534&#39;s Blog</title>
    <link>https://blog.riba2534.cn/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
    <description>Recent content in 数据密集型应用系统设计 on 🌀riba2534&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 09 Sep 2021 17:34:48 +0800</lastBuildDate><atom:link href="https://blog.riba2534.cn/categories/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据密集型应用系统设计_分布式系统的挑战</title>
      <link>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/</link>
      <pubDate>Thu, 09 Sep 2021 17:34:48 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/</guid>
      <description>分布式系统的挑战 本章对分布式系统可能出现的故障做了一个全面、近乎悲观的总结。故障可能来自网络问题、时钟时序问题等，并讨论这些问题的可控程度。
故障与部分失效 计算机设计一个非常谨慎的选择是：如果发生了某种内部错误，宁愿使计算机全部崩溃，而不是返回一个错误的结果，错误的结果往往更难处理。计算机隐藏了一切模糊的物理世界，呈现一个理想化的物理模型，以数学的方式完美运行。
但是涉及到多个节点时，情况发生了根本性的变化。对于这种分布式系统，理想化的标准模型不再适用，我们必须面对一个可能混乱的现实：在一个现实世界中，各种各样的事情都可能出错。
在分布式系统中，可能出现系统的一部分工作正常，但其他某些部分出现难以预测的故障，我们称之为「部分失效」。问题的难点就在于这种失效是不确定性的：如果涉及多个节点和网络，几乎肯定会碰到有时候网络正常，有时候则莫名的失败，这种不确定性和部分失效大大提高了分布式系统的复杂性
云计算和超算 关于如何构建大规模计算系统有以下几种不同的思路：
 规模的一个极端是高性能计算（HPC）。包含成千上万个CPU的超级计算机构建出一个庞大的集群，通常用于计算密集型的科学任务 另一个极端是云计算。虽然云计算的定义并非那么明确，但是通常他具有一下特征：  多租户数据中心 通用计算机 用 IP 以太网链接 弹性/按需资源分配   传统企业一般处于这两个极端之间  不同集群构建方式所对应的错误处理方法也不同，对于高性能计算，通常会定期对任务进行快照，然后保存在持久性存储上，当某个节点出现故障，就干脆让系统停下来，等故障节点修复之后，从最近的快照点继续执行，
本书重点是基于互联网的服务系统，这些系统与高性能计算有许多不同之处：
 我们的互联网服务都是在线的，需要随时（7X24h）不间断运行，为用户提供低延迟服务，任何服务不可用的情况，都是不可取的。相比之下，对于高性能计算，比如天气模拟这种离线任务则可以暂停下来然后重启，影响相对较小 高性能计算通常采用专有硬件，每个节点的可靠性很高，节点之间主要通过共享内存来进行通信，或者远程内存直接访问（RDMA）等技术进行通信。而云计算中的节点大多数是由通用机器构建，且成本相对低廉 大型数据中心通常基于IP和以太网，采用 Clos 拓扑结构提供等分带宽。他们可以为 HPC 特定工作负载提供了更好的性能。 系统越大，其中局部组件失效的概率就越大，在长时间运行期间，我们几乎总是可以假定某些东西发生了失效。 如果系统可以容忍某些失败的节点，而使整体继续工作，则对系统运行帮助极大，例如：支持滚动升级（我们目前就是这样做的） 对于全球分散部署的多数据中心，通信需要经过广域网，与本地网络相比，速度更慢且更加不可靠，而高性能计算通常假设所有节点位置靠近，紧密相连。  要是分布式系统可靠工作，就必然面临部分失效，这就需要依靠系统软件系统来提供容错机制。在分布式系统中，怀疑，悲观和偏执狂才能生存。
不可靠的网络 本书主要关注分布式无共享系统，即通过网络连接多个节点。所以有以下几点假定：
 网络是跨节点通信的唯一路径 每台机器都有自己的内存和磁盘 一个机器不能直接访问另一台机器的内存或磁盘，除非通过网络发起请求  互联网以及大多数数据中心的内部网络都是异步网络，这种网络中，一个节点可以发送消息到另一个节点，但是网络并不保证它什么时候到达，甚至一定到达。发送之后，有很多事情可能出错：
 请求可能已经丢失（比如有人拔掉网线） 请求可能正在某个队列中等待，无法马上发送 远程节点已经失效 远程接收节点可能暂时无法响应 远程接收节点已经完成了请求处理，但是回复却在网络中 丢失/延迟  处理这种问题，我们一般采用超时机制：在等待了一段时间后，如果仍旧没有收到回复则放弃，并且认为响应不会到达。但是，即使判断他超时，仍然不清楚远程节点是否接收到了请求
现实中的网络故障 一些系统研究和大量的侧面证据表明，网络问题出人意料的普遍，包括哪些由公司运营的数据中心。一家中型数据中心完成的调查发现，没有有12次网络故障，其中有一半涉及单台机器。一家中型数据中心调查发现，每月大约有12次网络故障。
 在头条内部，我们也经常经历由机房故障导致的网络不可用，服务报警等。。大家应该也遇到很多次了
 我们必须处理或者测试网络故障，例如：集群可能死锁，即使网络恢复了也无法提供服务，甚至可能误删数据。如果触发了一些软件未定义的情形，则发生了任何意外都不奇怪。
处理网络故障并不意味着总是需要复杂的容错设施：假定你的网络非常可靠，而万一出现问题，一种简单的方法是向用户提供错误信息。前提是，必须非常清楚接下来软件应该如何应对，以确保系统最终可以恢复。
我们推荐人为有计划的触发网络问题，以测试系统的反应。
 在字节内部，我们总是进行容灾演练，这一点做的还是不错的
 检测故障 许多系统都需要自动检测节点失效这样的功能，例如：
 负载均衡器需要避免向已失效的节点继续分发请求 对于主从复制的分布式数据库，如果主节点失效，我们需要将某个节点提升成主节点。但，网络的不准确性很难准确判断节点是否失效 由于网络的不准确性使得判断节点是否失效变的非常困难，而只有在某些特定场景下，获取可以明确的知道哪里错了 假设可以登录节点，但发现服务器上没有监听目标端口（可能进程挂了），那操作系统会返回 RST 或 FIN 标志的数据包来辅助关闭或拒绝 TCP 链接。如果节点在处理请求的过程中发生了崩溃，就很难知道节点处理了多少数据 如果服务进程崩溃，但是os仍在运行，可以通过脚本通知其他节点，以便新节点能快速接管而跳过等待超时。HBase 使用了这种方法  总之，如果出了问题，你可能会在应用堆栈的某个级别拿到了一个关于错误的回复，但是最好假定最终收不到任何错误报告，接下来尝试重试，等待超时之后，如果还是没有收到响应，则最终声明节点已经失效。</description>
    </item>
    
    <item>
      <title>数据密集型应用系统设计_数据存储与检索</title>
      <link>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</link>
      <pubDate>Fri, 09 Jul 2021 21:32:17 +0800</pubDate>
      
      <guid>https://blog.riba2534.cn/blog/2021/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</guid>
      <description>数据存储与检索 从最基本的层面看，数据库只需要做两件事：
 向它插入数据时，它就保存数据 查询数据时，它就返回数据  本章主要从数据库的角度来探讨：
 如何存储输入的数据 收到查询请求时，如何重新找到数据  作为一名普通的开发人员，我们不太可能从头实现一个自己的存储引擎，但是我们在做技术选型的时候，需要从众多的存储引擎中选一个最适合自己应用的，就需要对各种存储引擎底层机制有一个大概的了解。
我们将研究两个存储引擎家族：
 日志结构的存储引擎 面向页的存储引擎（如 B-Tree）  数据库的核心：数据结构 一个简单的例子： 1 2 3 4 5 6 7 8 9  #!/bin/bash  de_set() { echo &amp;#34;$1,$2&amp;#34; &amp;gt;&amp;gt;database } db_get() { grep &amp;#34;^$1,&amp;#34; database | sed -e &amp;#34;s/^$1,//&amp;#34; | tail -n 1 }   我们实现了一个简单的 kv 存储的数据库，key 可以是任意值，value可以是一个 json，我们每次查找，都会获取key的最新值返回。
我们来看一下这样做的特点
 每次对数据进行追加，且旧值不会被覆盖，最后一次的值就是最新的值 这种追加到文件末尾的方式通常足够高效，许多数据库内部也是使用日志（log），日志是一个仅支持追加式更新的数据文件，但是一个真正的数据库需要考虑的更多（并发控制、回收磁盘、控制日志文件大小） 虽然写入的时候高效，但是如果日志文件产生了大量记录， do_get 性能会非常差，他只能进行 O(n) 扫描全表  那如何快速查找我们想要找的 key 的值呢，那就需要一个数据结构来索引它，最基本的想法就是存一些额外的数据，作为这些元数据的路标，帮助我们定位，但是引入额外的数据结构来维护索引，也是有开销的，每次写入数据不仅仅是简单的追加数据，还需要更新索引，因此任何类型的索引都会降低写入速度。</description>
    </item>
    
  </channel>
</rss>
