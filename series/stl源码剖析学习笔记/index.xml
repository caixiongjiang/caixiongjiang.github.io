<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>《STL源码剖析》学习笔记 on 🌀Jarson Cai&#39;s Blog</title>
    <link>https://caixiongjiang.github.io/series/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 《STL源码剖析》学习笔记 on 🌀Jarson Cai&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 20 Apr 2022 18:18:05 +0800</lastBuildDate><atom:link href="https://caixiongjiang.github.io/series/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第十讲：rb_tree深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC10%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 20 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC10%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第十讲：rb_tree深度探索 rb_tree vs AVL树  AVL是一个高度平衡的二叉树，而红黑树不是 红黑树每次插入一个元素，最多只需要两次旋转；而AVL可能需要更多次平衡操作 搜索速度：AVL树更加快，因为其严格遵守高度平衡，搜索查找的平均时间复杂度为log2(n) 插入速度：红黑树更加快，因为最多只需要两次旋转再加一些重新着色。 AVL树是rb_tree的子集  红黑树的结构   红黑树是平衡二分搜索树中常常使用的一种，平衡二分搜索树的特性：排列规则有利search和insert，并保持适度平衡。
  红黑树提供遍历的功能及iterators。按正常规则（++ite）遍历，便能获得排序状态。
  红黑树的结构样例：
排序的状态为红黑树的中序遍历，begin()在左下，end()是在右下
  红黑树的规则(首先需要是一颗二分查找树{BST})：
 1.每个节点不是红色就是黑色 2.根节点为黑色 3.如果节点为红，其子节点必须是黑（如果节点为黑，其子节点既可以是红也可以是黑） 4.任一节点至NULL(树尾端)的任何路径，所含黑色节点数必须相同  根据规则4，新增节点必须为红；根据规则3，新增节点之父节点必须为黑，当新节点根据二叉搜索树的规则到达其插入点， 但未能符合上述要求，就必须调整颜色并旋转树形
  我们不应该用红黑树的iterators改变元素值（因为元素有其严谨的排序规则）。但是编程层面并未阻止此事，rb_tree将会为set和map服务，而map允许元素的data被改变， 只有元素的key才是不能被改变的。
  rb_tree提供两种insertion操作（红黑树本身对重复与否没有限制，而取决于insert的方式）：insert_unique()和insert_equal()。前者表示节点的key一定在整个树中独一无二， 否则安插失败；后者表示节点的key可以重复。
  部分源码（在这里将key和data合起来的节点合成value）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //这里的Value是key和data的组合，如果value只传一个值说明没有value（set） template &amp;lt;class Key, class Value, class KeyOfValue, class Compare, class Alloc = alloc&amp;gt; class rb_tree { protected: typedef __rb_tree_node&amp;lt;Value&amp;gt; rb_tree_node;//红黑树的结构  ··· public: // 注意，没有定义iterator（喔，不，定义在后面）  typedef rb_tree_node* link_type;//指向红黑树节点的指针  ··· protected: //rb_tree只以三个资料表现它自己  size_type node_count;//rb_tree的大小（节点数量）  link_type header; Compare key_compare;//key的大小比较准则；应会是个function object  ··· }   测试rb_tree（GNU2.</description>
    </item>
    
    <item>
      <title>第九讲：deque，queue，stack深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC9%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 20 Apr 2022 18:14:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC9%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第九讲：deque，queue，stack深度探索 容器deque deque的结构和设计 deque的底层结构：
如上图所示：
 deque的迭代器是一个class，内部有四个元素cur，first，last，node  node指向某一个buffer，first和last分别指向这一个buffer的头部和尾部，cur指向当前元素 cur一旦走到了一个buffer的边界，则直接走到下一个buffer的开头（维持左闭右开）   deque向前扩充和向后扩充都是使用buffer来进行的（之前已经讲过了） start和finish是为了维护改容器的begin()和end()  源码如下(GNU2.9)：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  template&amp;lt;class T, class Alloc=alloc, size_t BufSiz=0&amp;gt; class deque { public: typedef T value_type; typedef __deque_iterator&amp;lt;T, T&amp;amp;, T*, BufSiz&amp;gt; iterator; protected: typedef pointer* map_pointer;//T** 指向指针的指针 protected: iterator start;//对应begin()的iterator类  iterator finish;//对应end()的iterator类  map_pointer map;//单个buffer  size_type map_size;//控制中心的大小（也就是有多少个buffer） public: iterator begin() { return start; } iterator edn() { return finish; } size_type size() const { return finish - start; } };   谈一谈参数的设置：如果BufSiz传入5，则为5；如果没有指定，则默认为0；如果元素大小sz大于512Bytes ，它就让一个缓冲区只放一个元素；如果小于512Bytes,则传回512/sz。（不过新版本不允许指定大小）</description>
    </item>
    
    <item>
      <title>第八讲：array和forward_list深度探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC8%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 19 Apr 2022 18:14:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC8%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第八讲：array和forward_list深度探索 容器array array在c中本身就存在，为什么array要成为一个容器？
array成为容器的好处：array可以使用迭代器，可以使用标准算法，更加地快捷。
使用标准array的方法：
1 2 3 4 5  array&amp;lt;int, 10&amp;gt; myArray; auto it = myArray.begin(); //array&amp;lt;int, 10&amp;gt;::iterator it = myArray.begin(); it += 3; cout &amp;lt;&amp;lt; *it;   源码如下图，较简单(TR1版本)：
forward_list 单向链表的结构与list双向链表的结构类似，可以类推。（c++11以前为slist）</description>
    </item>
    
    <item>
      <title>第七讲：vector容器深入探索</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC7%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 17 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC7%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第七讲：vector容器深入探索 vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。
vector扩容机制(GNU 2.9版) 从途中可以看出，有三个非常关键的指针start，finish，end_of_storage:
 start指向第一个元素的内存空间，也就是begin()方法指向的内存空间。 finish指向当前使用中的最后一个元素的后一个位置的内存空间，也就是end()方法指向的内存空间！ end_of_storage指向当前最大可用空间的尾。  源码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  template &amp;lt;class T, class Alloc = alloc&amp;gt; // 預設使用 alloc 為配置器 class vector { public: // 以下標示 (1),(2),(3),(4),(5)，代表 iterator_traits&amp;lt;I&amp;gt; 所服務的5個型別。  typedef T value_type;	// (1)  typedef value_type* pointer; // (2)  typedef const value_type* const_pointer; typedef const value_type* const_iterator; typedef value_type&amp;amp; reference; // (3)  typedef const value_type&amp;amp; const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; // (4)  // 以下，由於vector 所維護的是一個連續線性空間，所以不論其元素型別為何，  // 原生指標都可以做為其迭代器而滿足所有需求。  typedef value_type* iterator; /* 根據上述寫法，如果客端寫出這樣的碼： vector&amp;lt;Shape&amp;gt;::iterator is; is 的型別其實就是Shape* 而STL 內部運用 iterator_traits&amp;lt;is&amp;gt;::reference 時，獲得 Shape&amp;amp; 運用iterator_traits&amp;lt;is&amp;gt;::iterator_category 時，獲得 random_access_iterator_tag	(5) （此乃iterator_traits 針對原生指標的特化結果） */ // vector採用簡單的線性連續空間。以兩個迭代器start和end分別指向頭尾，  // 并以迭代器end_of_storage指向容量尾端。容量可能比(尾-头)还大 protected: iterator start; iterator finish; iterator end_of_storage; public: iterator begin() { return start; } const_iterator begin() const { return start; } iterator end() { return finish; } /*通过函数相减有利于后期修改指针时，不需要修改size()方法*/ size_type size() const { return size_type(end() - begin()); } /*capacity代表最大容量*/ size_type capacity() const { return size_type(end_of_storage - begin()); } bool empty() const { return begin() == end(); } /*连续空间的容器都会有[]的运算符重载*/ reference operator[](size_type n) { return *(begin() + n); } // 取出第一個元素內容  reference front() { return *begin(); } // 取出最後一個元素內容  reference back() { return *(end() - 1); } }   通过push_back()方法来看扩容机制：</description>
    </item>
    
    <item>
      <title>第六讲：迭代器设计的原则&amp;iterator traits的作用与设计</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC6%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 18:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC6%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第六讲：迭代器设计的原则&amp;amp;iterator traits的作用与设计 iterator traits iterator traits是为了提取出迭代器的特点，迭代器必须有能力回答algorithm提出的问题。
c++标准库设计了5种回答方式,集成在class中（迭代器相关的类型，迭代器模版中本身必须定义出来）：
 iterator_category：迭代器的类型，具体表现在能否++或者&amp;ndash;或者一下加减很多步 difference_type：代表两个iterator的距离应该用什么type来表现（随机访问：unsign interger，实现链表的都用ptrdiff_t类型） value_type：iterator所指元素的类型 reference：引用（暂未使用） pointer：指针（暂未使用）  但如果iterator本身不是class，例如native pointer（退化的iterator），如何回答算法的5个问题？
iterator traits用于分离class iiterators和non-class iterators</description>
    </item>
    
    <item>
      <title>第五讲：深入理解容器</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC5%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 13:18:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC5%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第五讲：深入理解容器 容器的结构再分类  heap 和 priority_queue中有vector的结构 stack 和 queue中有deque的结构 set 和 map系列有rb_tree的结构 unordered系列容器中有hashtable的结构 在c++11中：slist &amp;ndash;&amp;gt; forward_list； hash_~ &amp;ndash;&amp;gt; unordered_~。  深度探索list list（环状双向链表）其本身是一个指针，指向一个node节点，其结构为两个指针（一个向前一个向后）+数据值
1  sizeof(list&amp;lt;int&amp;gt;()) //其值为4Bytes（GNU2.9） 8Bytes(GNU4.9)   list的结构  node的设计（GNU2.9）：  1 2 3 4 5 6 7  tempalate&amp;lt;class T&amp;gt; struct __list_node { typedef void* void_pointer;//一个空的指针置于尾端的一个空白节点，符合&amp;#34;前闭后开&amp;#34;的要求  void_pointer prev;//向前的指针  void_pointer next;//向后的指针  T data;//数据 };    iterator的设计（GNU2.9）：  1 2 3 4 5 6 7 8  tempalte&amp;lt;class T, class Ref, class Ptr&amp;gt; struct __list_iterator { typedef T value_type; typedef Ptr pointer; typedef Ref reference; ··· //具体看《STL源码剖析》p131 };   G4.</description>
    </item>
    
    <item>
      <title>第四讲：深入理解分配器</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC4%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 08 Apr 2022 10:54:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC4%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第四讲：深入理解分配器 operator new() &amp;amp; malloc() operator() new会调用malloc(), malloc()作用是分配内存。
看图：
size部分为我们所需要的内存，可以看出malloc()分配的内存比所需要的内存多。多分配的内存空间如果称为开销的话，也就是说我们的单个内存越大，开销所占比例就越小！
分配器最重要的两个函数：allocate &amp;amp; deallocate VC++下和BC++下：
申请内存：allocator--&amp;gt;operator new()--&amp;gt;malloc()释放内存：deallocator--&amp;gt;operator delete()--&amp;gt;free()分配512个int整数：
1 2  int *p = allocator&amp;lt;int&amp;gt;().allocate(512, (int*)0); allocator&amp;lt;int&amp;gt;().deallocate(p, 512);   注：一个type +（）形成了一个临时对象，才能调用其中的成员函数。举例：queue&amp;lt;int&amp;gt;()
alloc的优点 GNU2.9下：
申请内存：allocator--&amp;gt;allocate()--&amp;gt;operator new()--&amp;gt;malloc()释放内存：deallocator--&amp;gt;deallocate()-&amp;gt;operator delete()--&amp;gt;free()注：虽然GNU标准allocator被设计出来，但它的容器基本都不用标准的allocator，而是使用alloc
 使用malloc()和free()会带来很大的额外开销，如果区块小，开销比例会很大。 额外开销中的cookie记录内存的大小，但因为容器元素的大小是一样的，所以alloc使用一个长链表（i = 0～15），第i个对应cookie大小为8(i + 1)Bytes的内存大小，容器的内存大小会被调整为8的倍数，这样就只需要用少量cookie来记录内存大小！ 所以使用alloc存放1000000个元素，可以省掉cookie开销大约8000000个Bytes  GNU4.9下：
 容器使用的分配器又变为了allocator，继承于new_allocator，使用operator new() 和 operator delete() 4.9下的alloc被更名为__pool_alloc，属于__gnu_cxx::__pool_alloc  </description>
    </item>
    
    <item>
      <title>第三讲:泛型编程和模版技术</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC3%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 15:21:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC3%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第三讲:泛型编程和模版技术 源代码之分布  VC的标准库文件夹:   GNU c++标准库文件夹:  OOP(面向对象编程) vs GP(泛型编程)   OOP将datas和methods关联在一起（成员变量和成员函数都放在类里面） demo:list内部本身存在有sort()算法，使用语法如下：
1  c.sort()     GP是将datas和methods分开来
demo：vector和deque内部都没有sort()函数，sort()函数是放在算法里面的，使用语法如下：
1  ::sort(c.begin(), c.end());   注：list本身是链式容器，无法支持随机访问，所以需要本身自己重新定义sort()。
  采用GP的好处：
 容器和算法团队可以各自写自己的东西，其间用迭代器来进行关联。 算法通过迭代器确定操作范围，并通过迭代器取用容器的元素。 两个石头如何比较大小不需要类来决定，而是用仿函数来决定。    max()算法的demo：
第二个版本的参数3接收的是函数对象或者是仿函数，用于自定义的比较规则制定！
  操作符重载复习 操作符操作单个数或者多个数，以及能否成为类内部的成员函数
模版Template复习  类模版:   函数模版:   成员模版  模版中泛化 vs 特化  泛化的特点是可以接收大多数type的数据结构 特化的特点是为了某些特殊的数据（数据有不同的特点）进行的模版中特殊化的写法  demo:
特化中的偏特化（局部特化）  个数的偏特化:   范围的偏特化：  </description>
    </item>
    
    <item>
      <title>第二讲:容器之分类及各种测试</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC2%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 10:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC2%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第二讲:容器之分类及各种测试 容器结构及分类  序列式容器  数组（Array）：定长数组，无法扩充 vector：可扩充的数组（分配器做内存扩充） Deque：双端队列 List：双向链表 Forward-List：单向链表   关联式容器（key-&amp;gt;value）  Set/Multiset（Multiset中的值可以重复）：内部为红黑数 Map/Multimap（Multimap中的value值可以重复）：内部为红黑树   无序容器（unordered,大类上属于关联式容器）  介绍一个常用的结构hashtable：根据公式进行分类， 但会产生碰撞， 产生碰撞的元素全部放在一个链表中。但如果链表太长如何做呢？后面会继续介绍。
先写用于测试的几个辅助函数:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  using std::cin; using std::cout; using std::string; long get_a_target_long() { long target = 0; cout &amp;lt;&amp;lt; &amp;#34;target (0~&amp;#34; &amp;lt;&amp;lt; RAND_MAX &amp;lt;&amp;lt; &amp;#34;):&amp;#34;; return target; } string get_a_target_string() { long target = 0; char buf[10]; cout &amp;lt;&amp;lt; &amp;#34;target (0~&amp;#34; &amp;lt;&amp;lt; RAND_MAX &amp;lt;&amp;lt; &amp;#34;):&amp;#34;; cin &amp;gt;&amp;gt; target; //snprintf功能为格式化成字符串  // 1-- 目标字符串 2 -- 拷贝字节数 3 -- 格式化成字符串。4 -- 可变参数。  snprintf(buf, 10, &amp;#34;%d&amp;#34;, target); return string(buf); } //比较两个long数据是否相等 int compareLongs(const void* a, const void* b) { return (*(long*)a - *(long*)b); } //比较两个string数据是否相等 int compareStrings(const void* a, const void* b) { if(*(string*)a &amp;gt; *(string*)b) return 1; else if(*(string*)a &amp;lt; *(string*)b) return -1; else return 0; }   顺序容器使用及测试   使用容器array：array.</description>
    </item>
    
    <item>
      <title>第一讲:STL体系结构介绍</title>
      <link>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC1%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Apr 2022 08:15:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC1%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>第一讲:STL体系结构介绍 c++标准库 vs c++ Standard Library 总体来说 c++标准库 &amp;gt; c++ Standard Library
标准库以头文件（.h）的形式呈现:
 c++标准库的header files不带副档名（.h）, 例如#include  新式c header files 不带副档名（.h），例如 #include  旧式c header files 带有副档名（.h）仍然可用，例如 #include &amp;lt;stdio.h&amp;gt; 新式headers内的组件封装为 namespace &amp;ldquo;std&amp;rdquo;  using namespace std;（相当于把std文件全部打开） using std::cout;   旧式headers内的组件不封装在namespace &amp;ldquo;std&amp;rdquo;  demo：
1 2 3 4 5 6  #include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;   重要的网站（c++标准库）  cplusplus.com cppreference.com gcc.gnu.org  STL六大部件  容器（containers） 分配器（allocators） 算法（algorithms） 迭代器（iterators） 适配器（addpters） 仿函数（functors）  六大部件的关系：</description>
    </item>
    
  </channel>
</rss>
