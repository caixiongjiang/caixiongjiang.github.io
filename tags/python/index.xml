<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on 🌀Jarson Cai&#39;s Blog</title>
    <link>https://caixiongjiang.github.io/tags/python/</link>
    <description>Recent content in python on 🌀Jarson Cai&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 05 May 2022 19:07:05 +0800</lastBuildDate><atom:link href="https://caixiongjiang.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《数字图像处理》课程设计——表格图片文字识别</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%A1%A8%E6%A0%BC%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</link>
      <pubDate>Thu, 05 May 2022 19:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%A1%A8%E6%A0%BC%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</guid>
      <description>《数字图像处理》课程设计——表格图片文字识别 目标任务  1、将图片中的信息提取为表格：提取“姓名”、“准考证号”、“已录取”，保存为新表格 2、在已有表格中查找指定数据并进行标注；将“已录取”数据增加到原有表格中  思路步骤  1.使用灰度方法读取图片，并利用局部阈值分割方法分割为像素只有0和255的图片 2.使用基于形态学腐蚀操作和膨胀操作，分别识别横线和竖线 3.找出横线和竖线的交点，并把交点像素的位置保存起来 4.通过图片相减得到纯文字的图片，根据像素位置来分割图片 5.对分割好的图片使用cnocr文字识别识别中文，使用tesseract识别数字，并将其保存到数组中 6.将书组中的内容分别放入新的excel表格并保存，并根据名字信息对原有表格进行修改  思路具体实现 灰度读取图片&amp;amp;自适应阈值分割  灰度读取图片的目的是为了消除色彩对后续处理的影响 自适应阈值分割的目的是为了将图片的背景变为纯黑色（像素值为0），文字以及其他信息变为纯白色（像素值为255）  为什么使用阈值分割的方法？
 图像分割思想：控制背景环境，降低分割难度；聚焦于感兴趣的部分。在这里其实就是将图片中的文字信息都集中起来，将图片的背景设置为黑色 基本策略：根据图像的像素灰度值的相似性来选择分割的阈值  为什么使用自适应阈值分割？
 整副图像的对比度较低，存在多个目标（多个单峰灰度分布），需要使用多阈值分割方法。 自适应阈值分割的阈值选取的方法：根据图像不同区域亮度分布，计算其局部阈值，所以对于图像不同区域，能够自适应计算不同的阈值。 自适应的阈值确定方法有两种：计算某个邻域(局部)的均值、高斯加权平均(高斯滤波)来确定阈值，这里采用高斯加权平均。 二值化方法：这里采用THRESH_BINARY方法;超过阈值则设为最大像素值，不超过则设为0  形态学腐蚀 形态学腐蚀原理
 使用卷积模版在图像上移动，如果发现有像素等于目标图像，就将其模板中原点的位置变成1 使用基于形态学的腐蚀和膨胀，可以将不同于该形态的区域剔除，保留相似的部分  实现
 构建一个类似于横线和竖线的形态学模版，对目标图像进行腐蚀和膨胀操作，单独提取出横线和竖线  寻找横线竖线的交点 横线竖线交点寻找很简单，但因为交点的大小不一，可能一个交点包含很多个像素，但我们只需要一个。所以在选取像素的横纵坐标时需要进行特别的处理
根据交点进行图片分割  首先通过原图减去横线图和竖线图得到纯文字图片，再进行图片分割 这里的图片分割不同于上面，其代表的是字面意思，也就是根据保存好的横纵坐标选取不同的区域的图片 注意根据提取的信息，还需要对子图片再次进行分割，还有就是一些冗余信息的去除。  包含多个信息： 包含冗余信息：    中英文文字识别  为什么不自己写文字识别？因为本课程主要是为了学习opencv而不是机器学习，所以这里只调用第三方库。 中文使用cnocr库识别。 英文或数字使用tesseract程序+pytesseract库进行识别。  其中tesseract需要下载文件，下载地址：https://digi.bib.uni-mannheim.de/tesseract/    向表格添加数据  使用openpyxl库进行excel表格的操作。 注意添加数据的函数，因为需要识别多张图片进行多次添加数据，每次添加时索引需要重新定位没有数据的第一行位置。  源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333  import math import cv2 as cv import openpyxl #图像二值化 &amp;#39;&amp;#39;&amp;#39; 使用自适应阈值分割： 它的思想不是计算全局图像的阈值，而是根据图像不同区域亮度分布，计算其局部阈值，所以对于图像不同区域，能够自适应计算不同的阈值，因此被称为自适应阈值法。 如何确定局部阈值呢？可以计算某个邻域(局部)的均值、中值、高斯加权平均(高斯滤波)来确定阈值。 cv2.</description>
    </item>
    
    <item>
      <title>爬虫：使用selenium模拟12306购票</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E6%8B%9F12306%E8%B4%AD%E7%A5%A8/</link>
      <pubDate>Thu, 28 Apr 2022 10:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E6%8B%9F12306%E8%B4%AD%E7%A5%A8/</guid>
      <description>使用selenium模拟12306购票 selenium介绍  selenium是一种自动化测试工具，可以通过浏览器引擎来自动化帮人类做某些事。 selenium也可以作为一种轻量化爬虫工具。优点是它能绕过网站自身加密后的源码，通过浏览器解析后来获取网页中的元素，也就是文本信息；缺点也很明显，就是它本身是通过浏览器去运行的，非常容易受浏览器访问时网络波动的影响，因此通常要设置睡眠短暂时间来等待浏览器的加载，整体效率就不高。 总体来说，selenium适合轻量化数据的爬虫。  本小程序原理介绍  通过python使用selenium自动操控浏览器引擎模拟人的购票动作。 通过第三方图像识别破解复杂验证码。（以前的12306登录有这个环节，现在取消了） 本小程序没有涉及UI界面的设计，只为学习爬虫工具，粗浅了解网页结构。  资源准备   1.谷歌浏览器（你也可以使用火狐浏览器）
  2.下载谷歌浏览器驱动：
 查看浏览器的版本：点击浏览器右上角的三个点按钮，找到帮助中的关于Google Chrome，点击就可以看到自己的版本号了 打开网址：https://registry.npmmirror.com/binary.html?path=chromedriver/,选择浏览器版本对应的镜像，根据操作系统来选择下载哪一个镜像 下载解压后，将文件改为chromedriver，放入python解释器所在的文件夹，也就是你python环境配置的地方，这里我使用的PyCharm,所以把它放在了我的项目目录下的bin文件中。    3.下载selenium库（哪种ok就哪种）:
1 2  pip install selenium pip install selenium -i 清华源     破解12306检测自动化控制   12306的滑窗验证会自动检测自动化测试，导致机器滑窗验证失败。
  反识别自动化控制工具使用：
  如果你的chrome版本小于88，在启动浏览器的时候（此时没有加载任何内容），向页面潜入js代码，去掉webdriver：
1 2 3 4 5 6 7 8 9 10 11  from selenium.webdriver import Chrome web = Chrome() web.</description>
    </item>
    
    <item>
      <title>《数字图像处理》第三章——图像增强</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</link>
      <pubDate>Mon, 14 Mar 2022 19:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</guid>
      <description>《数字图像处理》第三章——图像增强 图像增强是突出图像中的某些部分，将图像变得易于人眼观察，通常用于去噪，平滑，锐化，阈值处理。
处理方式：
 空间域处理  点处理 邻域处理   频率域处理  点像素处理法  阈值处理：最常用的是二分阈值，也就是像素值大于某个阈值全部变成255，小于该阈值全部变成0。 图像反转：常用于灰度图的黑白反转，使得想要显示的图像细节变成低像素值，其他变成高像素值，公式如下： $$ s = L - 1 -r $$ 伽马校正：原理是将图像的像素点再有效范围内分布更加均匀。它通常用于常用显示器显示图像或者对整体过亮的图像进行延展。公式如下： $$ s = cr^{\gamma} $$ 注：这里通过调整上标伽马的参数来进行校正 像素拉伸：原理是在低像素和高像素区域的像素值都乘以一个小于1的系数，处于中间像素区域的像素值都乘以一个大于1的系数。  图像均衡 直方图均衡化  直方图的定义：横坐标为像素值，纵坐标为像素的个数。 直方图归一化：横坐标依然为像素值，纵坐标变成了该像素值出现的概率。  直方图的目的是通过一个函数来使原图像的直方图分布从不均匀到一个均匀分布，公式如下： $$ s = T(r) = (L - 1)\int_{0}^{r}P_{r}(w)dw $$
注：其中L为256（8bit的最大数加1），P为概率分布函数
该函数为一个递增函数，由旧的像素值（整数）变成新的像素值（浮点数），又一个取整的过程，所以直方图均衡化之后，直方图分布并不是完全平均
直方图匹配 直方图匹配是指给定一张图像，要将其直方图分布变换成特定直方图分布。
直方图匹配的实现：
 1.先对原图像进行直方图均衡化处理，得到结果T 2.对目标直方图进行直方图均衡化处理，得到映射关系 3.对T进行步骤2的逆映射处理  邻域矩阵处理法 这也就是我们通常所说的滤波。通常使用一个n×n矩阵和图像中的所有n×n子块进行求内积的操作
 均值滤波（局部）：使用全为1的矩阵进行求内积。注意矩阵乘法之前必须进行归一化，防止数据超过原有的范围。  $$\sum_{i}(a - a_{i})^2取最小时就是其均值（误差较大）$$
  高斯滤波：使用高斯滤波进行局部平均，相当于离中间像素值越大的其权重分配的越小，差值越小的权重分配的越大。</description>
    </item>
    
    <item>
      <title>Open cv模块学习</title>
      <link>https://caixiongjiang.github.io/blog/2022/opencv%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 04 Mar 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/opencv%E5%AD%A6%E4%B9%A0/</guid>
      <description>图像基本操作 数据读取-图像  cv2.IMREAD_COLOR:彩色图像 cv2.IMREAD_GRAYSCALE:灰度图像  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import cv2 as cv # opencv模块，读取图片的的格式是BGR import matplotlib.pyplot as plt # 制做图表的模块 import numpy as np # 数据处理模块 img1 = cv.imread(&amp;#34;cat.jpg&amp;#34;) # 读取图片（彩色图片） # 输出img1为一个三个的二维矩阵，dtype为 uint8（代表0～255之间的整数） # 图像的显示 cv.imshow(&amp;#34;image&amp;#34;, img1) #参数：（图片标题，图片名） # 等待时间，毫秒级，0表示按任意键终止图像显示 cv.</description>
    </item>
    
    <item>
      <title>《数字图像处理》第二章——图像压缩</title>
      <link>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Mon, 28 Feb 2022 18:07:05 +0800</pubDate>
      
      <guid>https://caixiongjiang.github.io/blog/2022/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</guid>
      <description>《数字图像处理》第二章——图像压缩 图像压缩基本概念  压缩比： Cr = n1 / n2 相对数据冗余： Rd = 1 - 1 / Cr 无损压缩： 压缩编码冗余和像素冗余称为无损压缩  图像压缩标准（包括视频）  主流的静态图像压缩标准（JPEG家族）：JPEG, JPEG-LS(无损压缩), JPEG-2000 主流的视频压缩标准（MPEG家族）：MPEG-1, MPEG-2, MPEG-3, MPEG-4 AVC  图像压缩的流程 以JPEG的压缩流程为例：
输入的图像——&amp;gt;图像分块——&amp;gt;映射器——&amp;gt;量化器——&amp;gt;编码器解码器——&amp;gt;反映射——&amp;gt;输出图片量化器是该过程中唯一对图像质量有损耗的
JPEG压缩 编码器 JPEG使用的是哈夫曼编码，哈夫曼编码得到的是一种无前缀编码，这会使得出现概率越高的元素编码长度越短，出现概率越低的元素编码长度越长，最后总的编码长度编程最短
哈夫曼编码使用规则：
 1.每次取集合中最小的两个值，相加之后再加入原有的集合，再重复取最小的两个值，到最后只剩一个元素 2.将原有集合的数字进行编码，层数越高，编码长度越短  在JPEG中应用为：对像素出现的概率高低进行编码！
demo：
a1 - 0.4a2 - 0.3a3 - 0.1对应编码：a1 - 1a2 - 01a3 - 00编码熵：$ -\sum_{i = 1}^n p(s)log_2^{p(s)}$ （概率*对应的自信息）</description>
    </item>
    
  </channel>
</rss>
